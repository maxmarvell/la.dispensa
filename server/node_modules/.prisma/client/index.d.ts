
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model Ingredient
 * 
 */
export type Ingredient = $Result.DefaultSelection<Prisma.$IngredientPayload>
/**
 * Model Connection
 * 
 */
export type Connection = $Result.DefaultSelection<Prisma.$ConnectionPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model RecipeEditors
 * 
 */
export type RecipeEditors = $Result.DefaultSelection<Prisma.$RecipeEditorsPayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Instruction
 * 
 */
export type Instruction = $Result.DefaultSelection<Prisma.$InstructionPayload>
/**
 * Model TimeAndTemperature
 * 
 */
export type TimeAndTemperature = $Result.DefaultSelection<Prisma.$TimeAndTemperaturePayload>
/**
 * Model RecipeIngredient
 * 
 */
export type RecipeIngredient = $Result.DefaultSelection<Prisma.$RecipeIngredientPayload>
/**
 * Model Component
 * 
 */
export type Component = $Result.DefaultSelection<Prisma.$ComponentPayload>
/**
 * Model Iteration
 * 
 */
export type Iteration = $Result.DefaultSelection<Prisma.$IterationPayload>
/**
 * Model IngredientIteration
 * 
 */
export type IngredientIteration = $Result.DefaultSelection<Prisma.$IngredientIterationPayload>
/**
 * Model InstructionIteration
 * 
 */
export type InstructionIteration = $Result.DefaultSelection<Prisma.$InstructionIterationPayload>
/**
 * Model TimeAndTemperatureIteration
 * 
 */
export type TimeAndTemperatureIteration = $Result.DefaultSelection<Prisma.$TimeAndTemperatureIterationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TemperatureUnit: {
  C: 'C',
  K: 'K'
};

export type TemperatureUnit = (typeof TemperatureUnit)[keyof typeof TemperatureUnit]


export const IngredientUnit: {
  G: 'G',
  KG: 'KG',
  CUP: 'CUP',
  ML: 'ML',
  L: 'L',
  OZ: 'OZ'
};

export type IngredientUnit = (typeof IngredientUnit)[keyof typeof IngredientUnit]

}

export type TemperatureUnit = $Enums.TemperatureUnit

export const TemperatureUnit: typeof $Enums.TemperatureUnit

export type IngredientUnit = $Enums.IngredientUnit

export const IngredientUnit: typeof $Enums.IngredientUnit

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.ingredient`: Exposes CRUD operations for the **Ingredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingredients
    * const ingredients = await prisma.ingredient.findMany()
    * ```
    */
  get ingredient(): Prisma.IngredientDelegate<ExtArgs>;

  /**
   * `prisma.connection`: Exposes CRUD operations for the **Connection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Connections
    * const connections = await prisma.connection.findMany()
    * ```
    */
  get connection(): Prisma.ConnectionDelegate<ExtArgs>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs>;

  /**
   * `prisma.recipeEditors`: Exposes CRUD operations for the **RecipeEditors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeEditors
    * const recipeEditors = await prisma.recipeEditors.findMany()
    * ```
    */
  get recipeEditors(): Prisma.RecipeEditorsDelegate<ExtArgs>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs>;

  /**
   * `prisma.instruction`: Exposes CRUD operations for the **Instruction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instructions
    * const instructions = await prisma.instruction.findMany()
    * ```
    */
  get instruction(): Prisma.InstructionDelegate<ExtArgs>;

  /**
   * `prisma.timeAndTemperature`: Exposes CRUD operations for the **TimeAndTemperature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeAndTemperatures
    * const timeAndTemperatures = await prisma.timeAndTemperature.findMany()
    * ```
    */
  get timeAndTemperature(): Prisma.TimeAndTemperatureDelegate<ExtArgs>;

  /**
   * `prisma.recipeIngredient`: Exposes CRUD operations for the **RecipeIngredient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecipeIngredients
    * const recipeIngredients = await prisma.recipeIngredient.findMany()
    * ```
    */
  get recipeIngredient(): Prisma.RecipeIngredientDelegate<ExtArgs>;

  /**
   * `prisma.component`: Exposes CRUD operations for the **Component** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Components
    * const components = await prisma.component.findMany()
    * ```
    */
  get component(): Prisma.ComponentDelegate<ExtArgs>;

  /**
   * `prisma.iteration`: Exposes CRUD operations for the **Iteration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Iterations
    * const iterations = await prisma.iteration.findMany()
    * ```
    */
  get iteration(): Prisma.IterationDelegate<ExtArgs>;

  /**
   * `prisma.ingredientIteration`: Exposes CRUD operations for the **IngredientIteration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IngredientIterations
    * const ingredientIterations = await prisma.ingredientIteration.findMany()
    * ```
    */
  get ingredientIteration(): Prisma.IngredientIterationDelegate<ExtArgs>;

  /**
   * `prisma.instructionIteration`: Exposes CRUD operations for the **InstructionIteration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstructionIterations
    * const instructionIterations = await prisma.instructionIteration.findMany()
    * ```
    */
  get instructionIteration(): Prisma.InstructionIterationDelegate<ExtArgs>;

  /**
   * `prisma.timeAndTemperatureIteration`: Exposes CRUD operations for the **TimeAndTemperatureIteration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeAndTemperatureIterations
    * const timeAndTemperatureIterations = await prisma.timeAndTemperatureIteration.findMany()
    * ```
    */
  get timeAndTemperatureIteration(): Prisma.TimeAndTemperatureIterationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.9.1
   * Query Engine version: 23fdc5965b1e05fc54e5f26ed3de66776b93de64
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Recipe: 'Recipe',
    Ingredient: 'Ingredient',
    Connection: 'Connection',
    Tag: 'Tag',
    RecipeEditors: 'RecipeEditors',
    Rating: 'Rating',
    Review: 'Review',
    Instruction: 'Instruction',
    TimeAndTemperature: 'TimeAndTemperature',
    RecipeIngredient: 'RecipeIngredient',
    Component: 'Component',
    Iteration: 'Iteration',
    IngredientIteration: 'IngredientIteration',
    InstructionIteration: 'InstructionIteration',
    TimeAndTemperatureIteration: 'TimeAndTemperatureIteration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'recipe' | 'ingredient' | 'connection' | 'tag' | 'recipeEditors' | 'rating' | 'review' | 'instruction' | 'timeAndTemperature' | 'recipeIngredient' | 'component' | 'iteration' | 'ingredientIteration' | 'instructionIteration' | 'timeAndTemperatureIteration'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      Ingredient: {
        payload: Prisma.$IngredientPayload<ExtArgs>
        fields: Prisma.IngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findFirst: {
            args: Prisma.IngredientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          findMany: {
            args: Prisma.IngredientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>[]
          }
          create: {
            args: Prisma.IngredientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          createMany: {
            args: Prisma.IngredientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          update: {
            args: Prisma.IngredientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          deleteMany: {
            args: Prisma.IngredientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientPayload>
          }
          aggregate: {
            args: Prisma.IngredientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredient>
          }
          groupBy: {
            args: Prisma.IngredientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientCountAggregateOutputType> | number
          }
        }
      }
      Connection: {
        payload: Prisma.$ConnectionPayload<ExtArgs>
        fields: Prisma.ConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConnectionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConnectionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findFirst: {
            args: Prisma.ConnectionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConnectionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          findMany: {
            args: Prisma.ConnectionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>[]
          }
          create: {
            args: Prisma.ConnectionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          createMany: {
            args: Prisma.ConnectionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConnectionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          update: {
            args: Prisma.ConnectionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          deleteMany: {
            args: Prisma.ConnectionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConnectionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConnectionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConnectionPayload>
          }
          aggregate: {
            args: Prisma.ConnectionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConnection>
          }
          groupBy: {
            args: Prisma.ConnectionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConnectionCountArgs<ExtArgs>,
            result: $Utils.Optional<ConnectionCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>,
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      RecipeEditors: {
        payload: Prisma.$RecipeEditorsPayload<ExtArgs>
        fields: Prisma.RecipeEditorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeEditorsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeEditorsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload>
          }
          findFirst: {
            args: Prisma.RecipeEditorsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeEditorsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload>
          }
          findMany: {
            args: Prisma.RecipeEditorsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload>[]
          }
          create: {
            args: Prisma.RecipeEditorsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload>
          }
          createMany: {
            args: Prisma.RecipeEditorsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeEditorsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload>
          }
          update: {
            args: Prisma.RecipeEditorsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload>
          }
          deleteMany: {
            args: Prisma.RecipeEditorsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeEditorsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeEditorsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeEditorsPayload>
          }
          aggregate: {
            args: Prisma.RecipeEditorsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeEditors>
          }
          groupBy: {
            args: Prisma.RecipeEditorsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeEditorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeEditorsCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeEditorsCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>,
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>,
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Instruction: {
        payload: Prisma.$InstructionPayload<ExtArgs>
        fields: Prisma.InstructionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload>
          }
          findFirst: {
            args: Prisma.InstructionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload>
          }
          findMany: {
            args: Prisma.InstructionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload>[]
          }
          create: {
            args: Prisma.InstructionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload>
          }
          createMany: {
            args: Prisma.InstructionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstructionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload>
          }
          update: {
            args: Prisma.InstructionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload>
          }
          deleteMany: {
            args: Prisma.InstructionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstructionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstructionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionPayload>
          }
          aggregate: {
            args: Prisma.InstructionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstruction>
          }
          groupBy: {
            args: Prisma.InstructionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstructionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructionCountArgs<ExtArgs>,
            result: $Utils.Optional<InstructionCountAggregateOutputType> | number
          }
        }
      }
      TimeAndTemperature: {
        payload: Prisma.$TimeAndTemperaturePayload<ExtArgs>
        fields: Prisma.TimeAndTemperatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeAndTemperatureFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeAndTemperatureFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload>
          }
          findFirst: {
            args: Prisma.TimeAndTemperatureFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeAndTemperatureFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload>
          }
          findMany: {
            args: Prisma.TimeAndTemperatureFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload>[]
          }
          create: {
            args: Prisma.TimeAndTemperatureCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload>
          }
          createMany: {
            args: Prisma.TimeAndTemperatureCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TimeAndTemperatureDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload>
          }
          update: {
            args: Prisma.TimeAndTemperatureUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload>
          }
          deleteMany: {
            args: Prisma.TimeAndTemperatureDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TimeAndTemperatureUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TimeAndTemperatureUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperaturePayload>
          }
          aggregate: {
            args: Prisma.TimeAndTemperatureAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTimeAndTemperature>
          }
          groupBy: {
            args: Prisma.TimeAndTemperatureGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TimeAndTemperatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeAndTemperatureCountArgs<ExtArgs>,
            result: $Utils.Optional<TimeAndTemperatureCountAggregateOutputType> | number
          }
        }
      }
      RecipeIngredient: {
        payload: Prisma.$RecipeIngredientPayload<ExtArgs>
        fields: Prisma.RecipeIngredientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeIngredientFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findFirst: {
            args: Prisma.RecipeIngredientFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeIngredientFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          findMany: {
            args: Prisma.RecipeIngredientFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>[]
          }
          create: {
            args: Prisma.RecipeIngredientCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          createMany: {
            args: Prisma.RecipeIngredientCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RecipeIngredientDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          update: {
            args: Prisma.RecipeIngredientUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          deleteMany: {
            args: Prisma.RecipeIngredientDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeIngredientUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RecipeIngredientUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RecipeIngredientPayload>
          }
          aggregate: {
            args: Prisma.RecipeIngredientAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecipeIngredient>
          }
          groupBy: {
            args: Prisma.RecipeIngredientGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecipeIngredientGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeIngredientCountArgs<ExtArgs>,
            result: $Utils.Optional<RecipeIngredientCountAggregateOutputType> | number
          }
        }
      }
      Component: {
        payload: Prisma.$ComponentPayload<ExtArgs>
        fields: Prisma.ComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findFirst: {
            args: Prisma.ComponentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findMany: {
            args: Prisma.ComponentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          create: {
            args: Prisma.ComponentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          createMany: {
            args: Prisma.ComponentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ComponentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          update: {
            args: Prisma.ComponentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          deleteMany: {
            args: Prisma.ComponentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ComponentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          aggregate: {
            args: Prisma.ComponentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComponent>
          }
          groupBy: {
            args: Prisma.ComponentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentCountArgs<ExtArgs>,
            result: $Utils.Optional<ComponentCountAggregateOutputType> | number
          }
        }
      }
      Iteration: {
        payload: Prisma.$IterationPayload<ExtArgs>
        fields: Prisma.IterationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IterationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IterationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload>
          }
          findFirst: {
            args: Prisma.IterationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IterationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload>
          }
          findMany: {
            args: Prisma.IterationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload>[]
          }
          create: {
            args: Prisma.IterationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload>
          }
          createMany: {
            args: Prisma.IterationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IterationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload>
          }
          update: {
            args: Prisma.IterationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload>
          }
          deleteMany: {
            args: Prisma.IterationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IterationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IterationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IterationPayload>
          }
          aggregate: {
            args: Prisma.IterationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIteration>
          }
          groupBy: {
            args: Prisma.IterationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IterationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IterationCountArgs<ExtArgs>,
            result: $Utils.Optional<IterationCountAggregateOutputType> | number
          }
        }
      }
      IngredientIteration: {
        payload: Prisma.$IngredientIterationPayload<ExtArgs>
        fields: Prisma.IngredientIterationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngredientIterationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngredientIterationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload>
          }
          findFirst: {
            args: Prisma.IngredientIterationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngredientIterationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload>
          }
          findMany: {
            args: Prisma.IngredientIterationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload>[]
          }
          create: {
            args: Prisma.IngredientIterationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload>
          }
          createMany: {
            args: Prisma.IngredientIterationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.IngredientIterationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload>
          }
          update: {
            args: Prisma.IngredientIterationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload>
          }
          deleteMany: {
            args: Prisma.IngredientIterationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.IngredientIterationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.IngredientIterationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$IngredientIterationPayload>
          }
          aggregate: {
            args: Prisma.IngredientIterationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIngredientIteration>
          }
          groupBy: {
            args: Prisma.IngredientIterationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IngredientIterationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngredientIterationCountArgs<ExtArgs>,
            result: $Utils.Optional<IngredientIterationCountAggregateOutputType> | number
          }
        }
      }
      InstructionIteration: {
        payload: Prisma.$InstructionIterationPayload<ExtArgs>
        fields: Prisma.InstructionIterationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstructionIterationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstructionIterationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload>
          }
          findFirst: {
            args: Prisma.InstructionIterationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstructionIterationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload>
          }
          findMany: {
            args: Prisma.InstructionIterationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload>[]
          }
          create: {
            args: Prisma.InstructionIterationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload>
          }
          createMany: {
            args: Prisma.InstructionIterationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InstructionIterationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload>
          }
          update: {
            args: Prisma.InstructionIterationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload>
          }
          deleteMany: {
            args: Prisma.InstructionIterationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InstructionIterationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InstructionIterationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InstructionIterationPayload>
          }
          aggregate: {
            args: Prisma.InstructionIterationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInstructionIteration>
          }
          groupBy: {
            args: Prisma.InstructionIterationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InstructionIterationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstructionIterationCountArgs<ExtArgs>,
            result: $Utils.Optional<InstructionIterationCountAggregateOutputType> | number
          }
        }
      }
      TimeAndTemperatureIteration: {
        payload: Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>
        fields: Prisma.TimeAndTemperatureIterationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeAndTemperatureIterationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeAndTemperatureIterationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload>
          }
          findFirst: {
            args: Prisma.TimeAndTemperatureIterationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeAndTemperatureIterationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload>
          }
          findMany: {
            args: Prisma.TimeAndTemperatureIterationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload>[]
          }
          create: {
            args: Prisma.TimeAndTemperatureIterationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload>
          }
          createMany: {
            args: Prisma.TimeAndTemperatureIterationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TimeAndTemperatureIterationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload>
          }
          update: {
            args: Prisma.TimeAndTemperatureIterationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload>
          }
          deleteMany: {
            args: Prisma.TimeAndTemperatureIterationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TimeAndTemperatureIterationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TimeAndTemperatureIterationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TimeAndTemperatureIterationPayload>
          }
          aggregate: {
            args: Prisma.TimeAndTemperatureIterationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTimeAndTemperatureIteration>
          }
          groupBy: {
            args: Prisma.TimeAndTemperatureIterationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TimeAndTemperatureIterationGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeAndTemperatureIterationCountArgs<ExtArgs>,
            result: $Utils.Optional<TimeAndTemperatureIterationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    connectedWith: number
    connectedBy: number
    ratings: number
    recipes: number
    recipeEditors: number
    reviews: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connectedWith?: boolean | UserCountOutputTypeCountConnectedWithArgs
    connectedBy?: boolean | UserCountOutputTypeCountConnectedByArgs
    ratings?: boolean | UserCountOutputTypeCountRatingsArgs
    recipes?: boolean | UserCountOutputTypeCountRecipesArgs
    recipeEditors?: boolean | UserCountOutputTypeCountRecipeEditorsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConnectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecipeEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeEditorsWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }



  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    parentRecipes: number
    components: number
    instructions: number
    iterations: number
    ratings: number
    editors: number
    ingredients: number
    reviews: number
    tags: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentRecipes?: boolean | RecipeCountOutputTypeCountParentRecipesArgs
    components?: boolean | RecipeCountOutputTypeCountComponentsArgs
    instructions?: boolean | RecipeCountOutputTypeCountInstructionsArgs
    iterations?: boolean | RecipeCountOutputTypeCountIterationsArgs
    ratings?: boolean | RecipeCountOutputTypeCountRatingsArgs
    editors?: boolean | RecipeCountOutputTypeCountEditorsArgs
    ingredients?: boolean | RecipeCountOutputTypeCountIngredientsArgs
    reviews?: boolean | RecipeCountOutputTypeCountReviewsArgs
    tags?: boolean | RecipeCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountParentRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountInstructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructionWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountIterationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IterationWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountRatingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeEditorsWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }


  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }



  /**
   * Count Type IngredientCountOutputType
   */

  export type IngredientCountOutputType = {
    iterations: number
    recipes: number
  }

  export type IngredientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    iterations?: boolean | IngredientCountOutputTypeCountIterationsArgs
    recipes?: boolean | IngredientCountOutputTypeCountRecipesArgs
  }

  // Custom InputTypes

  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientCountOutputType
     */
    select?: IngredientCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountIterationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientIterationWhereInput
  }


  /**
   * IngredientCountOutputType without action
   */
  export type IngredientCountOutputTypeCountRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
  }



  /**
   * Count Type IterationCountOutputType
   */

  export type IterationCountOutputType = {
    ingredients: number
    instructions: number
    children: number
  }

  export type IterationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredients?: boolean | IterationCountOutputTypeCountIngredientsArgs
    instructions?: boolean | IterationCountOutputTypeCountInstructionsArgs
    children?: boolean | IterationCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes

  /**
   * IterationCountOutputType without action
   */
  export type IterationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IterationCountOutputType
     */
    select?: IterationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * IterationCountOutputType without action
   */
  export type IterationCountOutputTypeCountIngredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientIterationWhereInput
  }


  /**
   * IterationCountOutputType without action
   */
  export type IterationCountOutputTypeCountInstructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructionIterationWhereInput
  }


  /**
   * IterationCountOutputType without action
   */
  export type IterationCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IterationWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    salt: string | null
    image: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    password: string | null
    salt: string | null
    image: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    password: number
    salt: number
    image: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    salt?: true
    image?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    salt?: true
    image?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    password?: true
    salt?: true
    image?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    password: string
    salt: string
    image: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    salt?: boolean
    image?: boolean
    connectedWith?: boolean | User$connectedWithArgs<ExtArgs>
    connectedBy?: boolean | User$connectedByArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    recipes?: boolean | User$recipesArgs<ExtArgs>
    recipeEditors?: boolean | User$recipeEditorsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    password?: boolean
    salt?: boolean
    image?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connectedWith?: boolean | User$connectedWithArgs<ExtArgs>
    connectedBy?: boolean | User$connectedByArgs<ExtArgs>
    ratings?: boolean | User$ratingsArgs<ExtArgs>
    recipes?: boolean | User$recipesArgs<ExtArgs>
    recipeEditors?: boolean | User$recipeEditorsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      connectedWith: Prisma.$ConnectionPayload<ExtArgs>[]
      connectedBy: Prisma.$ConnectionPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      recipes: Prisma.$RecipePayload<ExtArgs>[]
      recipeEditors: Prisma.$RecipeEditorsPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      password: string
      salt: string
      image: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    connectedWith<T extends User$connectedWithArgs<ExtArgs> = {}>(args?: Subset<T, User$connectedWithArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany'> | Null>;

    connectedBy<T extends User$connectedByArgs<ExtArgs> = {}>(args?: Subset<T, User$connectedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany'> | Null>;

    ratings<T extends User$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, User$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipes<T extends User$recipesArgs<ExtArgs> = {}>(args?: Subset<T, User$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'> | Null>;

    recipeEditors<T extends User$recipeEditorsArgs<ExtArgs> = {}>(args?: Subset<T, User$recipeEditorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'findMany'> | Null>;

    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly salt: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.connectedWith
   */
  export type User$connectedWithArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }


  /**
   * User.connectedBy
   */
  export type User$connectedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    cursor?: ConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }


  /**
   * User.ratings
   */
  export type User$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * User.recipes
   */
  export type User$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * User.recipeEditors
   */
  export type User$recipeEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    where?: RecipeEditorsWhereInput
    orderBy?: RecipeEditorsOrderByWithRelationInput | RecipeEditorsOrderByWithRelationInput[]
    cursor?: RecipeEditorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeEditorsScalarFieldEnum | RecipeEditorsScalarFieldEnum[]
  }


  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeMinAggregateOutputType = {
    id: string | null
    createdOn: Date | null
    updatedAt: Date | null
    title: string | null
    authorId: string | null
    image: string | null
    description: string | null
    public: boolean | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: string | null
    createdOn: Date | null
    updatedAt: Date | null
    title: string | null
    authorId: string | null
    image: string | null
    description: string | null
    public: boolean | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    createdOn: number
    updatedAt: number
    title: number
    authorId: number
    image: number
    description: number
    public: number
    _all: number
  }


  export type RecipeMinAggregateInputType = {
    id?: true
    createdOn?: true
    updatedAt?: true
    title?: true
    authorId?: true
    image?: true
    description?: true
    public?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    createdOn?: true
    updatedAt?: true
    title?: true
    authorId?: true
    image?: true
    description?: true
    public?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    createdOn?: true
    updatedAt?: true
    title?: true
    authorId?: true
    image?: true
    description?: true
    public?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: string
    createdOn: Date | null
    updatedAt: Date | null
    title: string
    authorId: string
    image: string | null
    description: string | null
    public: boolean | null
    _count: RecipeCountAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdOn?: boolean
    updatedAt?: boolean
    title?: boolean
    authorId?: boolean
    image?: boolean
    description?: boolean
    public?: boolean
    parentRecipes?: boolean | Recipe$parentRecipesArgs<ExtArgs>
    components?: boolean | Recipe$componentsArgs<ExtArgs>
    instructions?: boolean | Recipe$instructionsArgs<ExtArgs>
    iterations?: boolean | Recipe$iterationsArgs<ExtArgs>
    ratings?: boolean | Recipe$ratingsArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    editors?: boolean | Recipe$editorsArgs<ExtArgs>
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    reviews?: boolean | Recipe$reviewsArgs<ExtArgs>
    tags?: boolean | Recipe$tagsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>

  export type RecipeSelectScalar = {
    id?: boolean
    createdOn?: boolean
    updatedAt?: boolean
    title?: boolean
    authorId?: boolean
    image?: boolean
    description?: boolean
    public?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentRecipes?: boolean | Recipe$parentRecipesArgs<ExtArgs>
    components?: boolean | Recipe$componentsArgs<ExtArgs>
    instructions?: boolean | Recipe$instructionsArgs<ExtArgs>
    iterations?: boolean | Recipe$iterationsArgs<ExtArgs>
    ratings?: boolean | Recipe$ratingsArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    editors?: boolean | Recipe$editorsArgs<ExtArgs>
    ingredients?: boolean | Recipe$ingredientsArgs<ExtArgs>
    reviews?: boolean | Recipe$reviewsArgs<ExtArgs>
    tags?: boolean | Recipe$tagsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      parentRecipes: Prisma.$ComponentPayload<ExtArgs>[]
      components: Prisma.$ComponentPayload<ExtArgs>[]
      instructions: Prisma.$InstructionPayload<ExtArgs>[]
      iterations: Prisma.$IterationPayload<ExtArgs>[]
      ratings: Prisma.$RatingPayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs>
      editors: Prisma.$RecipeEditorsPayload<ExtArgs>[]
      ingredients: Prisma.$RecipeIngredientPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      tags: Prisma.$TagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdOn: Date | null
      updatedAt: Date | null
      title: string
      authorId: string
      image: string | null
      description: string | null
      public: boolean | null
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }


  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RecipeFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
    **/
    create<T extends RecipeCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Recipes.
     *     @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     *     @example
     *     // Create many Recipes
     *     const recipe = await prisma.recipe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
    **/
    delete<T extends RecipeDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>
    ): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    parentRecipes<T extends Recipe$parentRecipesArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$parentRecipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'findMany'> | Null>;

    components<T extends Recipe$componentsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'findMany'> | Null>;

    instructions<T extends Recipe$instructionsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$instructionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'findMany'> | Null>;

    iterations<T extends Recipe$iterationsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$iterationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findMany'> | Null>;

    ratings<T extends Recipe$ratingsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$ratingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findMany'> | Null>;

    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    editors<T extends Recipe$editorsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$editorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'findMany'> | Null>;

    ingredients<T extends Recipe$ingredientsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$ingredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    reviews<T extends Recipe$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'> | Null>;

    tags<T extends Recipe$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'String'>
    readonly createdOn: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
    readonly title: FieldRef<"Recipe", 'String'>
    readonly authorId: FieldRef<"Recipe", 'String'>
    readonly image: FieldRef<"Recipe", 'String'>
    readonly description: FieldRef<"Recipe", 'String'>
    readonly public: FieldRef<"Recipe", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }


  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }


  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }


  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }


  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }


  /**
   * Recipe.parentRecipes
   */
  export type Recipe$parentRecipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    cursor?: ComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }


  /**
   * Recipe.components
   */
  export type Recipe$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    cursor?: ComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }


  /**
   * Recipe.instructions
   */
  export type Recipe$instructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    where?: InstructionWhereInput
    orderBy?: InstructionOrderByWithRelationInput | InstructionOrderByWithRelationInput[]
    cursor?: InstructionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructionScalarFieldEnum | InstructionScalarFieldEnum[]
  }


  /**
   * Recipe.iterations
   */
  export type Recipe$iterationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    where?: IterationWhereInput
    orderBy?: IterationOrderByWithRelationInput | IterationOrderByWithRelationInput[]
    cursor?: IterationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IterationScalarFieldEnum | IterationScalarFieldEnum[]
  }


  /**
   * Recipe.ratings
   */
  export type Recipe$ratingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Recipe.editors
   */
  export type Recipe$editorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    where?: RecipeEditorsWhereInput
    orderBy?: RecipeEditorsOrderByWithRelationInput | RecipeEditorsOrderByWithRelationInput[]
    cursor?: RecipeEditorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeEditorsScalarFieldEnum | RecipeEditorsScalarFieldEnum[]
  }


  /**
   * Recipe.ingredients
   */
  export type Recipe$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }


  /**
   * Recipe.reviews
   */
  export type Recipe$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Recipe.tags
   */
  export type Recipe$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeInclude<ExtArgs> | null
  }



  /**
   * Model Ingredient
   */

  export type AggregateIngredient = {
    _count: IngredientCountAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  export type IngredientMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type IngredientMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type IngredientCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type IngredientMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type IngredientMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type IngredientCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type IngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredient to aggregate.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingredients
    **/
    _count?: true | IngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientMaxAggregateInputType
  }

  export type GetIngredientAggregateType<T extends IngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredient[P]>
      : GetScalarType<T[P], AggregateIngredient[P]>
  }




  export type IngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientWhereInput
    orderBy?: IngredientOrderByWithAggregationInput | IngredientOrderByWithAggregationInput[]
    by: IngredientScalarFieldEnum[] | IngredientScalarFieldEnum
    having?: IngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientCountAggregateInputType | true
    _min?: IngredientMinAggregateInputType
    _max?: IngredientMaxAggregateInputType
  }

  export type IngredientGroupByOutputType = {
    id: string
    name: string
    _count: IngredientCountAggregateOutputType | null
    _min: IngredientMinAggregateOutputType | null
    _max: IngredientMaxAggregateOutputType | null
  }

  type GetIngredientGroupByPayload<T extends IngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientGroupByOutputType[P]>
        }
      >
    >


  export type IngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    iterations?: boolean | Ingredient$iterationsArgs<ExtArgs>
    recipes?: boolean | Ingredient$recipesArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredient"]>

  export type IngredientSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type IngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    iterations?: boolean | Ingredient$iterationsArgs<ExtArgs>
    recipes?: boolean | Ingredient$recipesArgs<ExtArgs>
    _count?: boolean | IngredientCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $IngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ingredient"
    objects: {
      iterations: Prisma.$IngredientIterationPayload<ExtArgs>[]
      recipes: Prisma.$RecipeIngredientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["ingredient"]>
    composites: {}
  }


  type IngredientGetPayload<S extends boolean | null | undefined | IngredientDefaultArgs> = $Result.GetResult<Prisma.$IngredientPayload, S>

  type IngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IngredientCountAggregateInputType | true
    }

  export interface IngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ingredient'], meta: { name: 'Ingredient' } }
    /**
     * Find zero or one Ingredient that matches the filter.
     * @param {IngredientFindUniqueArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Ingredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientFindUniqueOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Ingredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindFirstOrThrowArgs} args - Arguments to find a Ingredient
     * @example
     * // Get one Ingredient
     * const ingredient = await prisma.ingredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ingredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingredients
     * const ingredients = await prisma.ingredient.findMany()
     * 
     * // Get first 10 Ingredients
     * const ingredients = await prisma.ingredient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingredientWithIdOnly = await prisma.ingredient.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IngredientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Ingredient.
     * @param {IngredientCreateArgs} args - Arguments to create a Ingredient.
     * @example
     * // Create one Ingredient
     * const Ingredient = await prisma.ingredient.create({
     *   data: {
     *     // ... data to create a Ingredient
     *   }
     * })
     * 
    **/
    create<T extends IngredientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientCreateArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ingredients.
     *     @param {IngredientCreateManyArgs} args - Arguments to create many Ingredients.
     *     @example
     *     // Create many Ingredients
     *     const ingredient = await prisma.ingredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ingredient.
     * @param {IngredientDeleteArgs} args - Arguments to delete one Ingredient.
     * @example
     * // Delete one Ingredient
     * const Ingredient = await prisma.ingredient.delete({
     *   where: {
     *     // ... filter to delete one Ingredient
     *   }
     * })
     * 
    **/
    delete<T extends IngredientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientDeleteArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Ingredient.
     * @param {IngredientUpdateArgs} args - Arguments to update one Ingredient.
     * @example
     * // Update one Ingredient
     * const ingredient = await prisma.ingredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpdateArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ingredients.
     * @param {IngredientDeleteManyArgs} args - Arguments to filter Ingredients to delete.
     * @example
     * // Delete a few Ingredients
     * const { count } = await prisma.ingredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingredients
     * const ingredient = await prisma.ingredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ingredient.
     * @param {IngredientUpsertArgs} args - Arguments to update or create a Ingredient.
     * @example
     * // Update or create a Ingredient
     * const ingredient = await prisma.ingredient.upsert({
     *   create: {
     *     // ... data to create a Ingredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingredient we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientUpsertArgs<ExtArgs>>
    ): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ingredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientCountArgs} args - Arguments to filter Ingredients to count.
     * @example
     * // Count the number of Ingredients
     * const count = await prisma.ingredient.count({
     *   where: {
     *     // ... the filter for the Ingredients we want to count
     *   }
     * })
    **/
    count<T extends IngredientCountArgs>(
      args?: Subset<T, IngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientAggregateArgs>(args: Subset<T, IngredientAggregateArgs>): Prisma.PrismaPromise<GetIngredientAggregateType<T>>

    /**
     * Group by Ingredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientGroupByArgs['orderBy'] }
        : { orderBy?: IngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ingredient model
   */
  readonly fields: IngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    iterations<T extends Ingredient$iterationsArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$iterationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipes<T extends Ingredient$recipesArgs<ExtArgs> = {}>(args?: Subset<T, Ingredient$recipesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Ingredient model
   */ 
  interface IngredientFieldRefs {
    readonly id: FieldRef<"Ingredient", 'String'>
    readonly name: FieldRef<"Ingredient", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Ingredient findUnique
   */
  export type IngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient findUniqueOrThrow
   */
  export type IngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient findFirst
   */
  export type IngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient findFirstOrThrow
   */
  export type IngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredient to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingredients.
     */
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient findMany
   */
  export type IngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter, which Ingredients to fetch.
     */
    where?: IngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingredients to fetch.
     */
    orderBy?: IngredientOrderByWithRelationInput | IngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingredients.
     */
    cursor?: IngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingredients.
     */
    skip?: number
    distinct?: IngredientScalarFieldEnum | IngredientScalarFieldEnum[]
  }


  /**
   * Ingredient create
   */
  export type IngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a Ingredient.
     */
    data: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
  }


  /**
   * Ingredient createMany
   */
  export type IngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ingredients.
     */
    data: IngredientCreateManyInput | IngredientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Ingredient update
   */
  export type IngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a Ingredient.
     */
    data: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
    /**
     * Choose, which Ingredient to update.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient updateMany
   */
  export type IngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ingredients.
     */
    data: XOR<IngredientUpdateManyMutationInput, IngredientUncheckedUpdateManyInput>
    /**
     * Filter which Ingredients to update
     */
    where?: IngredientWhereInput
  }


  /**
   * Ingredient upsert
   */
  export type IngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the Ingredient to update in case it exists.
     */
    where: IngredientWhereUniqueInput
    /**
     * In case the Ingredient found by the `where` argument doesn't exist, create a new Ingredient with this data.
     */
    create: XOR<IngredientCreateInput, IngredientUncheckedCreateInput>
    /**
     * In case the Ingredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientUpdateInput, IngredientUncheckedUpdateInput>
  }


  /**
   * Ingredient delete
   */
  export type IngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
    /**
     * Filter which Ingredient to delete.
     */
    where: IngredientWhereUniqueInput
  }


  /**
   * Ingredient deleteMany
   */
  export type IngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingredients to delete
     */
    where?: IngredientWhereInput
  }


  /**
   * Ingredient.iterations
   */
  export type Ingredient$iterationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    where?: IngredientIterationWhereInput
    orderBy?: IngredientIterationOrderByWithRelationInput | IngredientIterationOrderByWithRelationInput[]
    cursor?: IngredientIterationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientIterationScalarFieldEnum | IngredientIterationScalarFieldEnum[]
  }


  /**
   * Ingredient.recipes
   */
  export type Ingredient$recipesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    cursor?: RecipeIngredientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }


  /**
   * Ingredient without action
   */
  export type IngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingredient
     */
    select?: IngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientInclude<ExtArgs> | null
  }



  /**
   * Model Connection
   */

  export type AggregateConnection = {
    _count: ConnectionCountAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  export type ConnectionMinAggregateOutputType = {
    connectedWithId: string | null
    connectedById: string | null
    accepted: boolean | null
  }

  export type ConnectionMaxAggregateOutputType = {
    connectedWithId: string | null
    connectedById: string | null
    accepted: boolean | null
  }

  export type ConnectionCountAggregateOutputType = {
    connectedWithId: number
    connectedById: number
    accepted: number
    _all: number
  }


  export type ConnectionMinAggregateInputType = {
    connectedWithId?: true
    connectedById?: true
    accepted?: true
  }

  export type ConnectionMaxAggregateInputType = {
    connectedWithId?: true
    connectedById?: true
    accepted?: true
  }

  export type ConnectionCountAggregateInputType = {
    connectedWithId?: true
    connectedById?: true
    accepted?: true
    _all?: true
  }

  export type ConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connection to aggregate.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Connections
    **/
    _count?: true | ConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConnectionMaxAggregateInputType
  }

  export type GetConnectionAggregateType<T extends ConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConnection[P]>
      : GetScalarType<T[P], AggregateConnection[P]>
  }




  export type ConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConnectionWhereInput
    orderBy?: ConnectionOrderByWithAggregationInput | ConnectionOrderByWithAggregationInput[]
    by: ConnectionScalarFieldEnum[] | ConnectionScalarFieldEnum
    having?: ConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConnectionCountAggregateInputType | true
    _min?: ConnectionMinAggregateInputType
    _max?: ConnectionMaxAggregateInputType
  }

  export type ConnectionGroupByOutputType = {
    connectedWithId: string
    connectedById: string
    accepted: boolean
    _count: ConnectionCountAggregateOutputType | null
    _min: ConnectionMinAggregateOutputType | null
    _max: ConnectionMaxAggregateOutputType | null
  }

  type GetConnectionGroupByPayload<T extends ConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], ConnectionGroupByOutputType[P]>
        }
      >
    >


  export type ConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    connectedWithId?: boolean
    connectedById?: boolean
    accepted?: boolean
    connectedBy?: boolean | UserDefaultArgs<ExtArgs>
    connectedWith?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["connection"]>

  export type ConnectionSelectScalar = {
    connectedWithId?: boolean
    connectedById?: boolean
    accepted?: boolean
  }

  export type ConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connectedBy?: boolean | UserDefaultArgs<ExtArgs>
    connectedWith?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Connection"
    objects: {
      connectedBy: Prisma.$UserPayload<ExtArgs>
      connectedWith: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      connectedWithId: string
      connectedById: string
      accepted: boolean
    }, ExtArgs["result"]["connection"]>
    composites: {}
  }


  type ConnectionGetPayload<S extends boolean | null | undefined | ConnectionDefaultArgs> = $Result.GetResult<Prisma.$ConnectionPayload, S>

  type ConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConnectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConnectionCountAggregateInputType | true
    }

  export interface ConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Connection'], meta: { name: 'Connection' } }
    /**
     * Find zero or one Connection that matches the filter.
     * @param {ConnectionFindUniqueArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConnectionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionFindUniqueArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Connection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConnectionFindUniqueOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConnectionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Connection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConnectionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindFirstArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Connection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindFirstOrThrowArgs} args - Arguments to find a Connection
     * @example
     * // Get one Connection
     * const connection = await prisma.connection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConnectionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Connections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Connections
     * const connections = await prisma.connection.findMany()
     * 
     * // Get first 10 Connections
     * const connections = await prisma.connection.findMany({ take: 10 })
     * 
     * // Only select the `connectedWithId`
     * const connectionWithConnectedWithIdOnly = await prisma.connection.findMany({ select: { connectedWithId: true } })
     * 
    **/
    findMany<T extends ConnectionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Connection.
     * @param {ConnectionCreateArgs} args - Arguments to create a Connection.
     * @example
     * // Create one Connection
     * const Connection = await prisma.connection.create({
     *   data: {
     *     // ... data to create a Connection
     *   }
     * })
     * 
    **/
    create<T extends ConnectionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionCreateArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Connections.
     *     @param {ConnectionCreateManyArgs} args - Arguments to create many Connections.
     *     @example
     *     // Create many Connections
     *     const connection = await prisma.connection.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConnectionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Connection.
     * @param {ConnectionDeleteArgs} args - Arguments to delete one Connection.
     * @example
     * // Delete one Connection
     * const Connection = await prisma.connection.delete({
     *   where: {
     *     // ... filter to delete one Connection
     *   }
     * })
     * 
    **/
    delete<T extends ConnectionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionDeleteArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Connection.
     * @param {ConnectionUpdateArgs} args - Arguments to update one Connection.
     * @example
     * // Update one Connection
     * const connection = await prisma.connection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConnectionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionUpdateArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Connections.
     * @param {ConnectionDeleteManyArgs} args - Arguments to filter Connections to delete.
     * @example
     * // Delete a few Connections
     * const { count } = await prisma.connection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConnectionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConnectionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Connections
     * const connection = await prisma.connection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConnectionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Connection.
     * @param {ConnectionUpsertArgs} args - Arguments to update or create a Connection.
     * @example
     * // Update or create a Connection
     * const connection = await prisma.connection.upsert({
     *   create: {
     *     // ... data to create a Connection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Connection we want to update
     *   }
     * })
    **/
    upsert<T extends ConnectionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConnectionUpsertArgs<ExtArgs>>
    ): Prisma__ConnectionClient<$Result.GetResult<Prisma.$ConnectionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Connections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionCountArgs} args - Arguments to filter Connections to count.
     * @example
     * // Count the number of Connections
     * const count = await prisma.connection.count({
     *   where: {
     *     // ... the filter for the Connections we want to count
     *   }
     * })
    **/
    count<T extends ConnectionCountArgs>(
      args?: Subset<T, ConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConnectionAggregateArgs>(args: Subset<T, ConnectionAggregateArgs>): Prisma.PrismaPromise<GetConnectionAggregateType<T>>

    /**
     * Group by Connection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConnectionGroupByArgs['orderBy'] }
        : { orderBy?: ConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Connection model
   */
  readonly fields: ConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Connection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    connectedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    connectedWith<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Connection model
   */ 
  interface ConnectionFieldRefs {
    readonly connectedWithId: FieldRef<"Connection", 'String'>
    readonly connectedById: FieldRef<"Connection", 'String'>
    readonly accepted: FieldRef<"Connection", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Connection findUnique
   */
  export type ConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }


  /**
   * Connection findUniqueOrThrow
   */
  export type ConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where: ConnectionWhereUniqueInput
  }


  /**
   * Connection findFirst
   */
  export type ConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }


  /**
   * Connection findFirstOrThrow
   */
  export type ConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connection to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Connections.
     */
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }


  /**
   * Connection findMany
   */
  export type ConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter, which Connections to fetch.
     */
    where?: ConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Connections to fetch.
     */
    orderBy?: ConnectionOrderByWithRelationInput | ConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Connections.
     */
    cursor?: ConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Connections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Connections.
     */
    skip?: number
    distinct?: ConnectionScalarFieldEnum | ConnectionScalarFieldEnum[]
  }


  /**
   * Connection create
   */
  export type ConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Connection.
     */
    data: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
  }


  /**
   * Connection createMany
   */
  export type ConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Connections.
     */
    data: ConnectionCreateManyInput | ConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Connection update
   */
  export type ConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Connection.
     */
    data: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
    /**
     * Choose, which Connection to update.
     */
    where: ConnectionWhereUniqueInput
  }


  /**
   * Connection updateMany
   */
  export type ConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Connections.
     */
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyInput>
    /**
     * Filter which Connections to update
     */
    where?: ConnectionWhereInput
  }


  /**
   * Connection upsert
   */
  export type ConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Connection to update in case it exists.
     */
    where: ConnectionWhereUniqueInput
    /**
     * In case the Connection found by the `where` argument doesn't exist, create a new Connection with this data.
     */
    create: XOR<ConnectionCreateInput, ConnectionUncheckedCreateInput>
    /**
     * In case the Connection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConnectionUpdateInput, ConnectionUncheckedUpdateInput>
  }


  /**
   * Connection delete
   */
  export type ConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
    /**
     * Filter which Connection to delete.
     */
    where: ConnectionWhereUniqueInput
  }


  /**
   * Connection deleteMany
   */
  export type ConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Connections to delete
     */
    where?: ConnectionWhereInput
  }


  /**
   * Connection without action
   */
  export type ConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Connection
     */
    select?: ConnectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConnectionInclude<ExtArgs> | null
  }



  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    recipeId: string | null
    name: string | null
  }

  export type TagMaxAggregateOutputType = {
    recipeId: string | null
    name: string | null
  }

  export type TagCountAggregateOutputType = {
    recipeId: number
    name: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    recipeId?: true
    name?: true
  }

  export type TagMaxAggregateInputType = {
    recipeId?: true
    name?: true
  }

  export type TagCountAggregateInputType = {
    recipeId?: true
    name?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    recipeId: string
    name: string
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeId?: boolean
    name?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    recipeId?: boolean
    name?: boolean
  }

  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }


  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeId: string
      name: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }


  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TagFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tag that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TagFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `recipeId`
     * const tagWithRecipeIdOnly = await prisma.tag.findMany({ select: { recipeId: true } })
     * 
    **/
    findMany<T extends TagFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
    **/
    create<T extends TagCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TagCreateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tags.
     *     @param {TagCreateManyArgs} args - Arguments to create many Tags.
     *     @example
     *     // Create many Tags
     *     const tag = await prisma.tag.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TagCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
    **/
    delete<T extends TagDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TagDeleteArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TagUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TagDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TagUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
    **/
    upsert<T extends TagUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TagUpsertArgs<ExtArgs>>
    ): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tag model
   */ 
  interface TagFieldRefs {
    readonly recipeId: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }


  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }


  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
  }


  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }


  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }


  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
  }


  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TagInclude<ExtArgs> | null
  }



  /**
   * Model RecipeEditors
   */

  export type AggregateRecipeEditors = {
    _count: RecipeEditorsCountAggregateOutputType | null
    _min: RecipeEditorsMinAggregateOutputType | null
    _max: RecipeEditorsMaxAggregateOutputType | null
  }

  export type RecipeEditorsMinAggregateOutputType = {
    recipeId: string | null
    userId: string | null
  }

  export type RecipeEditorsMaxAggregateOutputType = {
    recipeId: string | null
    userId: string | null
  }

  export type RecipeEditorsCountAggregateOutputType = {
    recipeId: number
    userId: number
    _all: number
  }


  export type RecipeEditorsMinAggregateInputType = {
    recipeId?: true
    userId?: true
  }

  export type RecipeEditorsMaxAggregateInputType = {
    recipeId?: true
    userId?: true
  }

  export type RecipeEditorsCountAggregateInputType = {
    recipeId?: true
    userId?: true
    _all?: true
  }

  export type RecipeEditorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeEditors to aggregate.
     */
    where?: RecipeEditorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeEditors to fetch.
     */
    orderBy?: RecipeEditorsOrderByWithRelationInput | RecipeEditorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeEditorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeEditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeEditors
    **/
    _count?: true | RecipeEditorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeEditorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeEditorsMaxAggregateInputType
  }

  export type GetRecipeEditorsAggregateType<T extends RecipeEditorsAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeEditors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeEditors[P]>
      : GetScalarType<T[P], AggregateRecipeEditors[P]>
  }




  export type RecipeEditorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeEditorsWhereInput
    orderBy?: RecipeEditorsOrderByWithAggregationInput | RecipeEditorsOrderByWithAggregationInput[]
    by: RecipeEditorsScalarFieldEnum[] | RecipeEditorsScalarFieldEnum
    having?: RecipeEditorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeEditorsCountAggregateInputType | true
    _min?: RecipeEditorsMinAggregateInputType
    _max?: RecipeEditorsMaxAggregateInputType
  }

  export type RecipeEditorsGroupByOutputType = {
    recipeId: string
    userId: string
    _count: RecipeEditorsCountAggregateOutputType | null
    _min: RecipeEditorsMinAggregateOutputType | null
    _max: RecipeEditorsMaxAggregateOutputType | null
  }

  type GetRecipeEditorsGroupByPayload<T extends RecipeEditorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeEditorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeEditorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeEditorsGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeEditorsGroupByOutputType[P]>
        }
      >
    >


  export type RecipeEditorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeId?: boolean
    userId?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeEditors"]>

  export type RecipeEditorsSelectScalar = {
    recipeId?: boolean
    userId?: boolean
  }

  export type RecipeEditorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $RecipeEditorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeEditors"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeId: string
      userId: string
    }, ExtArgs["result"]["recipeEditors"]>
    composites: {}
  }


  type RecipeEditorsGetPayload<S extends boolean | null | undefined | RecipeEditorsDefaultArgs> = $Result.GetResult<Prisma.$RecipeEditorsPayload, S>

  type RecipeEditorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeEditorsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeEditorsCountAggregateInputType | true
    }

  export interface RecipeEditorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeEditors'], meta: { name: 'RecipeEditors' } }
    /**
     * Find zero or one RecipeEditors that matches the filter.
     * @param {RecipeEditorsFindUniqueArgs} args - Arguments to find a RecipeEditors
     * @example
     * // Get one RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeEditorsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeEditorsFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeEditors that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeEditorsFindUniqueOrThrowArgs} args - Arguments to find a RecipeEditors
     * @example
     * // Get one RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeEditorsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeEditorsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeEditors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeEditorsFindFirstArgs} args - Arguments to find a RecipeEditors
     * @example
     * // Get one RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeEditorsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeEditorsFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeEditors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeEditorsFindFirstOrThrowArgs} args - Arguments to find a RecipeEditors
     * @example
     * // Get one RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeEditorsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeEditorsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeEditors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeEditorsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.findMany()
     * 
     * // Get first 10 RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.findMany({ take: 10 })
     * 
     * // Only select the `recipeId`
     * const recipeEditorsWithRecipeIdOnly = await prisma.recipeEditors.findMany({ select: { recipeId: true } })
     * 
    **/
    findMany<T extends RecipeEditorsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeEditorsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeEditors.
     * @param {RecipeEditorsCreateArgs} args - Arguments to create a RecipeEditors.
     * @example
     * // Create one RecipeEditors
     * const RecipeEditors = await prisma.recipeEditors.create({
     *   data: {
     *     // ... data to create a RecipeEditors
     *   }
     * })
     * 
    **/
    create<T extends RecipeEditorsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeEditorsCreateArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeEditors.
     *     @param {RecipeEditorsCreateManyArgs} args - Arguments to create many RecipeEditors.
     *     @example
     *     // Create many RecipeEditors
     *     const recipeEditors = await prisma.recipeEditors.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeEditorsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeEditorsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeEditors.
     * @param {RecipeEditorsDeleteArgs} args - Arguments to delete one RecipeEditors.
     * @example
     * // Delete one RecipeEditors
     * const RecipeEditors = await prisma.recipeEditors.delete({
     *   where: {
     *     // ... filter to delete one RecipeEditors
     *   }
     * })
     * 
    **/
    delete<T extends RecipeEditorsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeEditorsDeleteArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeEditors.
     * @param {RecipeEditorsUpdateArgs} args - Arguments to update one RecipeEditors.
     * @example
     * // Update one RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeEditorsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeEditorsUpdateArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeEditors.
     * @param {RecipeEditorsDeleteManyArgs} args - Arguments to filter RecipeEditors to delete.
     * @example
     * // Delete a few RecipeEditors
     * const { count } = await prisma.recipeEditors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeEditorsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeEditorsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeEditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeEditorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeEditorsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeEditorsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeEditors.
     * @param {RecipeEditorsUpsertArgs} args - Arguments to update or create a RecipeEditors.
     * @example
     * // Update or create a RecipeEditors
     * const recipeEditors = await prisma.recipeEditors.upsert({
     *   create: {
     *     // ... data to create a RecipeEditors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeEditors we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeEditorsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeEditorsUpsertArgs<ExtArgs>>
    ): Prisma__RecipeEditorsClient<$Result.GetResult<Prisma.$RecipeEditorsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeEditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeEditorsCountArgs} args - Arguments to filter RecipeEditors to count.
     * @example
     * // Count the number of RecipeEditors
     * const count = await prisma.recipeEditors.count({
     *   where: {
     *     // ... the filter for the RecipeEditors we want to count
     *   }
     * })
    **/
    count<T extends RecipeEditorsCountArgs>(
      args?: Subset<T, RecipeEditorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeEditorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeEditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeEditorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeEditorsAggregateArgs>(args: Subset<T, RecipeEditorsAggregateArgs>): Prisma.PrismaPromise<GetRecipeEditorsAggregateType<T>>

    /**
     * Group by RecipeEditors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeEditorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeEditorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeEditorsGroupByArgs['orderBy'] }
        : { orderBy?: RecipeEditorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeEditorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeEditorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeEditors model
   */
  readonly fields: RecipeEditorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeEditors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeEditorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeEditors model
   */ 
  interface RecipeEditorsFieldRefs {
    readonly recipeId: FieldRef<"RecipeEditors", 'String'>
    readonly userId: FieldRef<"RecipeEditors", 'String'>
  }
    

  // Custom InputTypes

  /**
   * RecipeEditors findUnique
   */
  export type RecipeEditorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * Filter, which RecipeEditors to fetch.
     */
    where: RecipeEditorsWhereUniqueInput
  }


  /**
   * RecipeEditors findUniqueOrThrow
   */
  export type RecipeEditorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * Filter, which RecipeEditors to fetch.
     */
    where: RecipeEditorsWhereUniqueInput
  }


  /**
   * RecipeEditors findFirst
   */
  export type RecipeEditorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * Filter, which RecipeEditors to fetch.
     */
    where?: RecipeEditorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeEditors to fetch.
     */
    orderBy?: RecipeEditorsOrderByWithRelationInput | RecipeEditorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeEditors.
     */
    cursor?: RecipeEditorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeEditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeEditors.
     */
    distinct?: RecipeEditorsScalarFieldEnum | RecipeEditorsScalarFieldEnum[]
  }


  /**
   * RecipeEditors findFirstOrThrow
   */
  export type RecipeEditorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * Filter, which RecipeEditors to fetch.
     */
    where?: RecipeEditorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeEditors to fetch.
     */
    orderBy?: RecipeEditorsOrderByWithRelationInput | RecipeEditorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeEditors.
     */
    cursor?: RecipeEditorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeEditors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeEditors.
     */
    distinct?: RecipeEditorsScalarFieldEnum | RecipeEditorsScalarFieldEnum[]
  }


  /**
   * RecipeEditors findMany
   */
  export type RecipeEditorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * Filter, which RecipeEditors to fetch.
     */
    where?: RecipeEditorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeEditors to fetch.
     */
    orderBy?: RecipeEditorsOrderByWithRelationInput | RecipeEditorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeEditors.
     */
    cursor?: RecipeEditorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeEditors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeEditors.
     */
    skip?: number
    distinct?: RecipeEditorsScalarFieldEnum | RecipeEditorsScalarFieldEnum[]
  }


  /**
   * RecipeEditors create
   */
  export type RecipeEditorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeEditors.
     */
    data: XOR<RecipeEditorsCreateInput, RecipeEditorsUncheckedCreateInput>
  }


  /**
   * RecipeEditors createMany
   */
  export type RecipeEditorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeEditors.
     */
    data: RecipeEditorsCreateManyInput | RecipeEditorsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeEditors update
   */
  export type RecipeEditorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeEditors.
     */
    data: XOR<RecipeEditorsUpdateInput, RecipeEditorsUncheckedUpdateInput>
    /**
     * Choose, which RecipeEditors to update.
     */
    where: RecipeEditorsWhereUniqueInput
  }


  /**
   * RecipeEditors updateMany
   */
  export type RecipeEditorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeEditors.
     */
    data: XOR<RecipeEditorsUpdateManyMutationInput, RecipeEditorsUncheckedUpdateManyInput>
    /**
     * Filter which RecipeEditors to update
     */
    where?: RecipeEditorsWhereInput
  }


  /**
   * RecipeEditors upsert
   */
  export type RecipeEditorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeEditors to update in case it exists.
     */
    where: RecipeEditorsWhereUniqueInput
    /**
     * In case the RecipeEditors found by the `where` argument doesn't exist, create a new RecipeEditors with this data.
     */
    create: XOR<RecipeEditorsCreateInput, RecipeEditorsUncheckedCreateInput>
    /**
     * In case the RecipeEditors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeEditorsUpdateInput, RecipeEditorsUncheckedUpdateInput>
  }


  /**
   * RecipeEditors delete
   */
  export type RecipeEditorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
    /**
     * Filter which RecipeEditors to delete.
     */
    where: RecipeEditorsWhereUniqueInput
  }


  /**
   * RecipeEditors deleteMany
   */
  export type RecipeEditorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeEditors to delete
     */
    where?: RecipeEditorsWhereInput
  }


  /**
   * RecipeEditors without action
   */
  export type RecipeEditorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeEditors
     */
    select?: RecipeEditorsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeEditorsInclude<ExtArgs> | null
  }



  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    value: number | null
  }

  export type RatingSumAggregateOutputType = {
    value: number | null
  }

  export type RatingMinAggregateOutputType = {
    recipeId: string | null
    userId: string | null
    value: number | null
  }

  export type RatingMaxAggregateOutputType = {
    recipeId: string | null
    userId: string | null
    value: number | null
  }

  export type RatingCountAggregateOutputType = {
    recipeId: number
    userId: number
    value: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    value?: true
  }

  export type RatingSumAggregateInputType = {
    value?: true
  }

  export type RatingMinAggregateInputType = {
    recipeId?: true
    userId?: true
    value?: true
  }

  export type RatingMaxAggregateInputType = {
    recipeId?: true
    userId?: true
    value?: true
  }

  export type RatingCountAggregateInputType = {
    recipeId?: true
    userId?: true
    value?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    recipeId: string
    userId: string
    value: number
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeId?: boolean
    userId?: boolean
    value?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    recipeId?: boolean
    userId?: boolean
    value?: boolean
  }

  export type RatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $RatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeId: string
      userId: string
      value: number
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }


  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RatingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RatingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rating that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RatingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `recipeId`
     * const ratingWithRecipeIdOnly = await prisma.rating.findMany({ select: { recipeId: true } })
     * 
    **/
    findMany<T extends RatingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
    **/
    create<T extends RatingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RatingCreateArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ratings.
     *     @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     *     @example
     *     // Create many Ratings
     *     const rating = await prisma.rating.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RatingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
    **/
    delete<T extends RatingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RatingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RatingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RatingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
    **/
    upsert<T extends RatingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Rating model
   */ 
  interface RatingFieldRefs {
    readonly recipeId: FieldRef<"Rating", 'String'>
    readonly userId: FieldRef<"Rating", 'String'>
    readonly value: FieldRef<"Rating", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }


  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
  }


  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }


  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
  }


  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
  }



  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewMinAggregateOutputType = {
    recipeId: string | null
    userId: string | null
    text: string | null
    createdOn: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    recipeId: string | null
    userId: string | null
    text: string | null
    createdOn: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    recipeId: number
    userId: number
    text: number
    createdOn: number
    _all: number
  }


  export type ReviewMinAggregateInputType = {
    recipeId?: true
    userId?: true
    text?: true
    createdOn?: true
  }

  export type ReviewMaxAggregateInputType = {
    recipeId?: true
    userId?: true
    text?: true
    createdOn?: true
  }

  export type ReviewCountAggregateInputType = {
    recipeId?: true
    userId?: true
    text?: true
    createdOn?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    recipeId: string
    userId: string
    text: string
    createdOn: Date | null
    _count: ReviewCountAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeId?: boolean
    userId?: boolean
    text?: boolean
    createdOn?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    recipeId?: boolean
    userId?: boolean
    text?: boolean
    createdOn?: boolean
  }

  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeId: string
      userId: string
      text: string
      createdOn: Date | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }


  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReviewFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Review that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReviewFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `recipeId`
     * const reviewWithRecipeIdOnly = await prisma.review.findMany({ select: { recipeId: true } })
     * 
    **/
    findMany<T extends ReviewFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
    **/
    create<T extends ReviewCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reviews.
     *     @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     *     @example
     *     // Create many Reviews
     *     const review = await prisma.review.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReviewCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
    **/
    delete<T extends ReviewDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReviewUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReviewDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReviewUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
    **/
    upsert<T extends ReviewUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>
    ): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Review model
   */ 
  interface ReviewFieldRefs {
    readonly recipeId: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly text: FieldRef<"Review", 'String'>
    readonly createdOn: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }


  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }


  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
  }


  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }


  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }


  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
  }


  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReviewInclude<ExtArgs> | null
  }



  /**
   * Model Instruction
   */

  export type AggregateInstruction = {
    _count: InstructionCountAggregateOutputType | null
    _avg: InstructionAvgAggregateOutputType | null
    _sum: InstructionSumAggregateOutputType | null
    _min: InstructionMinAggregateOutputType | null
    _max: InstructionMaxAggregateOutputType | null
  }

  export type InstructionAvgAggregateOutputType = {
    step: number | null
  }

  export type InstructionSumAggregateOutputType = {
    step: number | null
  }

  export type InstructionMinAggregateOutputType = {
    description: string | null
    recipeId: string | null
    step: number | null
  }

  export type InstructionMaxAggregateOutputType = {
    description: string | null
    recipeId: string | null
    step: number | null
  }

  export type InstructionCountAggregateOutputType = {
    description: number
    recipeId: number
    step: number
    _all: number
  }


  export type InstructionAvgAggregateInputType = {
    step?: true
  }

  export type InstructionSumAggregateInputType = {
    step?: true
  }

  export type InstructionMinAggregateInputType = {
    description?: true
    recipeId?: true
    step?: true
  }

  export type InstructionMaxAggregateInputType = {
    description?: true
    recipeId?: true
    step?: true
  }

  export type InstructionCountAggregateInputType = {
    description?: true
    recipeId?: true
    step?: true
    _all?: true
  }

  export type InstructionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instruction to aggregate.
     */
    where?: InstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructions to fetch.
     */
    orderBy?: InstructionOrderByWithRelationInput | InstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instructions
    **/
    _count?: true | InstructionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructionMaxAggregateInputType
  }

  export type GetInstructionAggregateType<T extends InstructionAggregateArgs> = {
        [P in keyof T & keyof AggregateInstruction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstruction[P]>
      : GetScalarType<T[P], AggregateInstruction[P]>
  }




  export type InstructionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructionWhereInput
    orderBy?: InstructionOrderByWithAggregationInput | InstructionOrderByWithAggregationInput[]
    by: InstructionScalarFieldEnum[] | InstructionScalarFieldEnum
    having?: InstructionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructionCountAggregateInputType | true
    _avg?: InstructionAvgAggregateInputType
    _sum?: InstructionSumAggregateInputType
    _min?: InstructionMinAggregateInputType
    _max?: InstructionMaxAggregateInputType
  }

  export type InstructionGroupByOutputType = {
    description: string
    recipeId: string
    step: number
    _count: InstructionCountAggregateOutputType | null
    _avg: InstructionAvgAggregateOutputType | null
    _sum: InstructionSumAggregateOutputType | null
    _min: InstructionMinAggregateOutputType | null
    _max: InstructionMaxAggregateOutputType | null
  }

  type GetInstructionGroupByPayload<T extends InstructionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructionGroupByOutputType[P]>
            : GetScalarType<T[P], InstructionGroupByOutputType[P]>
        }
      >
    >


  export type InstructionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    description?: boolean
    recipeId?: boolean
    step?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    timeAndTemperature?: boolean | Instruction$timeAndTemperatureArgs<ExtArgs>
  }, ExtArgs["result"]["instruction"]>

  export type InstructionSelectScalar = {
    description?: boolean
    recipeId?: boolean
    step?: boolean
  }

  export type InstructionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    timeAndTemperature?: boolean | Instruction$timeAndTemperatureArgs<ExtArgs>
  }


  export type $InstructionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instruction"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      timeAndTemperature: Prisma.$TimeAndTemperaturePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      description: string
      recipeId: string
      step: number
    }, ExtArgs["result"]["instruction"]>
    composites: {}
  }


  type InstructionGetPayload<S extends boolean | null | undefined | InstructionDefaultArgs> = $Result.GetResult<Prisma.$InstructionPayload, S>

  type InstructionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstructionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstructionCountAggregateInputType | true
    }

  export interface InstructionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instruction'], meta: { name: 'Instruction' } }
    /**
     * Find zero or one Instruction that matches the filter.
     * @param {InstructionFindUniqueArgs} args - Arguments to find a Instruction
     * @example
     * // Get one Instruction
     * const instruction = await prisma.instruction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstructionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionFindUniqueArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Instruction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstructionFindUniqueOrThrowArgs} args - Arguments to find a Instruction
     * @example
     * // Get one Instruction
     * const instruction = await prisma.instruction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstructionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Instruction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionFindFirstArgs} args - Arguments to find a Instruction
     * @example
     * // Get one Instruction
     * const instruction = await prisma.instruction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstructionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionFindFirstArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Instruction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionFindFirstOrThrowArgs} args - Arguments to find a Instruction
     * @example
     * // Get one Instruction
     * const instruction = await prisma.instruction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstructionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Instructions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instructions
     * const instructions = await prisma.instruction.findMany()
     * 
     * // Get first 10 Instructions
     * const instructions = await prisma.instruction.findMany({ take: 10 })
     * 
     * // Only select the `description`
     * const instructionWithDescriptionOnly = await prisma.instruction.findMany({ select: { description: true } })
     * 
    **/
    findMany<T extends InstructionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Instruction.
     * @param {InstructionCreateArgs} args - Arguments to create a Instruction.
     * @example
     * // Create one Instruction
     * const Instruction = await prisma.instruction.create({
     *   data: {
     *     // ... data to create a Instruction
     *   }
     * })
     * 
    **/
    create<T extends InstructionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionCreateArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Instructions.
     *     @param {InstructionCreateManyArgs} args - Arguments to create many Instructions.
     *     @example
     *     // Create many Instructions
     *     const instruction = await prisma.instruction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstructionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Instruction.
     * @param {InstructionDeleteArgs} args - Arguments to delete one Instruction.
     * @example
     * // Delete one Instruction
     * const Instruction = await prisma.instruction.delete({
     *   where: {
     *     // ... filter to delete one Instruction
     *   }
     * })
     * 
    **/
    delete<T extends InstructionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionDeleteArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Instruction.
     * @param {InstructionUpdateArgs} args - Arguments to update one Instruction.
     * @example
     * // Update one Instruction
     * const instruction = await prisma.instruction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstructionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionUpdateArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Instructions.
     * @param {InstructionDeleteManyArgs} args - Arguments to filter Instructions to delete.
     * @example
     * // Delete a few Instructions
     * const { count } = await prisma.instruction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstructionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instructions
     * const instruction = await prisma.instruction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstructionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Instruction.
     * @param {InstructionUpsertArgs} args - Arguments to update or create a Instruction.
     * @example
     * // Update or create a Instruction
     * const instruction = await prisma.instruction.upsert({
     *   create: {
     *     // ... data to create a Instruction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instruction we want to update
     *   }
     * })
    **/
    upsert<T extends InstructionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionUpsertArgs<ExtArgs>>
    ): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Instructions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionCountArgs} args - Arguments to filter Instructions to count.
     * @example
     * // Count the number of Instructions
     * const count = await prisma.instruction.count({
     *   where: {
     *     // ... the filter for the Instructions we want to count
     *   }
     * })
    **/
    count<T extends InstructionCountArgs>(
      args?: Subset<T, InstructionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructionAggregateArgs>(args: Subset<T, InstructionAggregateArgs>): Prisma.PrismaPromise<GetInstructionAggregateType<T>>

    /**
     * Group by Instruction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructionGroupByArgs['orderBy'] }
        : { orderBy?: InstructionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instruction model
   */
  readonly fields: InstructionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instruction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    timeAndTemperature<T extends Instruction$timeAndTemperatureArgs<ExtArgs> = {}>(args?: Subset<T, Instruction$timeAndTemperatureArgs<ExtArgs>>): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Instruction model
   */ 
  interface InstructionFieldRefs {
    readonly description: FieldRef<"Instruction", 'String'>
    readonly recipeId: FieldRef<"Instruction", 'String'>
    readonly step: FieldRef<"Instruction", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Instruction findUnique
   */
  export type InstructionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * Filter, which Instruction to fetch.
     */
    where: InstructionWhereUniqueInput
  }


  /**
   * Instruction findUniqueOrThrow
   */
  export type InstructionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * Filter, which Instruction to fetch.
     */
    where: InstructionWhereUniqueInput
  }


  /**
   * Instruction findFirst
   */
  export type InstructionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * Filter, which Instruction to fetch.
     */
    where?: InstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructions to fetch.
     */
    orderBy?: InstructionOrderByWithRelationInput | InstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructions.
     */
    cursor?: InstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructions.
     */
    distinct?: InstructionScalarFieldEnum | InstructionScalarFieldEnum[]
  }


  /**
   * Instruction findFirstOrThrow
   */
  export type InstructionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * Filter, which Instruction to fetch.
     */
    where?: InstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructions to fetch.
     */
    orderBy?: InstructionOrderByWithRelationInput | InstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instructions.
     */
    cursor?: InstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instructions.
     */
    distinct?: InstructionScalarFieldEnum | InstructionScalarFieldEnum[]
  }


  /**
   * Instruction findMany
   */
  export type InstructionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * Filter, which Instructions to fetch.
     */
    where?: InstructionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instructions to fetch.
     */
    orderBy?: InstructionOrderByWithRelationInput | InstructionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instructions.
     */
    cursor?: InstructionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instructions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instructions.
     */
    skip?: number
    distinct?: InstructionScalarFieldEnum | InstructionScalarFieldEnum[]
  }


  /**
   * Instruction create
   */
  export type InstructionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * The data needed to create a Instruction.
     */
    data: XOR<InstructionCreateInput, InstructionUncheckedCreateInput>
  }


  /**
   * Instruction createMany
   */
  export type InstructionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instructions.
     */
    data: InstructionCreateManyInput | InstructionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Instruction update
   */
  export type InstructionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * The data needed to update a Instruction.
     */
    data: XOR<InstructionUpdateInput, InstructionUncheckedUpdateInput>
    /**
     * Choose, which Instruction to update.
     */
    where: InstructionWhereUniqueInput
  }


  /**
   * Instruction updateMany
   */
  export type InstructionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instructions.
     */
    data: XOR<InstructionUpdateManyMutationInput, InstructionUncheckedUpdateManyInput>
    /**
     * Filter which Instructions to update
     */
    where?: InstructionWhereInput
  }


  /**
   * Instruction upsert
   */
  export type InstructionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * The filter to search for the Instruction to update in case it exists.
     */
    where: InstructionWhereUniqueInput
    /**
     * In case the Instruction found by the `where` argument doesn't exist, create a new Instruction with this data.
     */
    create: XOR<InstructionCreateInput, InstructionUncheckedCreateInput>
    /**
     * In case the Instruction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructionUpdateInput, InstructionUncheckedUpdateInput>
  }


  /**
   * Instruction delete
   */
  export type InstructionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
    /**
     * Filter which Instruction to delete.
     */
    where: InstructionWhereUniqueInput
  }


  /**
   * Instruction deleteMany
   */
  export type InstructionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instructions to delete
     */
    where?: InstructionWhereInput
  }


  /**
   * Instruction.timeAndTemperature
   */
  export type Instruction$timeAndTemperatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    where?: TimeAndTemperatureWhereInput
  }


  /**
   * Instruction without action
   */
  export type InstructionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instruction
     */
    select?: InstructionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionInclude<ExtArgs> | null
  }



  /**
   * Model TimeAndTemperature
   */

  export type AggregateTimeAndTemperature = {
    _count: TimeAndTemperatureCountAggregateOutputType | null
    _avg: TimeAndTemperatureAvgAggregateOutputType | null
    _sum: TimeAndTemperatureSumAggregateOutputType | null
    _min: TimeAndTemperatureMinAggregateOutputType | null
    _max: TimeAndTemperatureMaxAggregateOutputType | null
  }

  export type TimeAndTemperatureAvgAggregateOutputType = {
    step: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
  }

  export type TimeAndTemperatureSumAggregateOutputType = {
    step: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
  }

  export type TimeAndTemperatureMinAggregateOutputType = {
    recipeId: string | null
    step: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
    unit: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureMaxAggregateOutputType = {
    recipeId: string | null
    step: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
    unit: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureCountAggregateOutputType = {
    recipeId: number
    step: number
    hours: number
    minutes: number
    temperature: number
    unit: number
    _all: number
  }


  export type TimeAndTemperatureAvgAggregateInputType = {
    step?: true
    hours?: true
    minutes?: true
    temperature?: true
  }

  export type TimeAndTemperatureSumAggregateInputType = {
    step?: true
    hours?: true
    minutes?: true
    temperature?: true
  }

  export type TimeAndTemperatureMinAggregateInputType = {
    recipeId?: true
    step?: true
    hours?: true
    minutes?: true
    temperature?: true
    unit?: true
  }

  export type TimeAndTemperatureMaxAggregateInputType = {
    recipeId?: true
    step?: true
    hours?: true
    minutes?: true
    temperature?: true
    unit?: true
  }

  export type TimeAndTemperatureCountAggregateInputType = {
    recipeId?: true
    step?: true
    hours?: true
    minutes?: true
    temperature?: true
    unit?: true
    _all?: true
  }

  export type TimeAndTemperatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeAndTemperature to aggregate.
     */
    where?: TimeAndTemperatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatures to fetch.
     */
    orderBy?: TimeAndTemperatureOrderByWithRelationInput | TimeAndTemperatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeAndTemperatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeAndTemperatures
    **/
    _count?: true | TimeAndTemperatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeAndTemperatureAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeAndTemperatureSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeAndTemperatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeAndTemperatureMaxAggregateInputType
  }

  export type GetTimeAndTemperatureAggregateType<T extends TimeAndTemperatureAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeAndTemperature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeAndTemperature[P]>
      : GetScalarType<T[P], AggregateTimeAndTemperature[P]>
  }




  export type TimeAndTemperatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeAndTemperatureWhereInput
    orderBy?: TimeAndTemperatureOrderByWithAggregationInput | TimeAndTemperatureOrderByWithAggregationInput[]
    by: TimeAndTemperatureScalarFieldEnum[] | TimeAndTemperatureScalarFieldEnum
    having?: TimeAndTemperatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeAndTemperatureCountAggregateInputType | true
    _avg?: TimeAndTemperatureAvgAggregateInputType
    _sum?: TimeAndTemperatureSumAggregateInputType
    _min?: TimeAndTemperatureMinAggregateInputType
    _max?: TimeAndTemperatureMaxAggregateInputType
  }

  export type TimeAndTemperatureGroupByOutputType = {
    recipeId: string
    step: number
    hours: number | null
    minutes: number | null
    temperature: number
    unit: $Enums.TemperatureUnit | null
    _count: TimeAndTemperatureCountAggregateOutputType | null
    _avg: TimeAndTemperatureAvgAggregateOutputType | null
    _sum: TimeAndTemperatureSumAggregateOutputType | null
    _min: TimeAndTemperatureMinAggregateOutputType | null
    _max: TimeAndTemperatureMaxAggregateOutputType | null
  }

  type GetTimeAndTemperatureGroupByPayload<T extends TimeAndTemperatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeAndTemperatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeAndTemperatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeAndTemperatureGroupByOutputType[P]>
            : GetScalarType<T[P], TimeAndTemperatureGroupByOutputType[P]>
        }
      >
    >


  export type TimeAndTemperatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeId?: boolean
    step?: boolean
    hours?: boolean
    minutes?: boolean
    temperature?: boolean
    unit?: boolean
    instruction?: boolean | InstructionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeAndTemperature"]>

  export type TimeAndTemperatureSelectScalar = {
    recipeId?: boolean
    step?: boolean
    hours?: boolean
    minutes?: boolean
    temperature?: boolean
    unit?: boolean
  }

  export type TimeAndTemperatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instruction?: boolean | InstructionDefaultArgs<ExtArgs>
  }


  export type $TimeAndTemperaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeAndTemperature"
    objects: {
      instruction: Prisma.$InstructionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeId: string
      step: number
      hours: number | null
      minutes: number | null
      temperature: number
      unit: $Enums.TemperatureUnit | null
    }, ExtArgs["result"]["timeAndTemperature"]>
    composites: {}
  }


  type TimeAndTemperatureGetPayload<S extends boolean | null | undefined | TimeAndTemperatureDefaultArgs> = $Result.GetResult<Prisma.$TimeAndTemperaturePayload, S>

  type TimeAndTemperatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeAndTemperatureFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeAndTemperatureCountAggregateInputType | true
    }

  export interface TimeAndTemperatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeAndTemperature'], meta: { name: 'TimeAndTemperature' } }
    /**
     * Find zero or one TimeAndTemperature that matches the filter.
     * @param {TimeAndTemperatureFindUniqueArgs} args - Arguments to find a TimeAndTemperature
     * @example
     * // Get one TimeAndTemperature
     * const timeAndTemperature = await prisma.timeAndTemperature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TimeAndTemperatureFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureFindUniqueArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TimeAndTemperature that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TimeAndTemperatureFindUniqueOrThrowArgs} args - Arguments to find a TimeAndTemperature
     * @example
     * // Get one TimeAndTemperature
     * const timeAndTemperature = await prisma.timeAndTemperature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TimeAndTemperatureFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TimeAndTemperature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureFindFirstArgs} args - Arguments to find a TimeAndTemperature
     * @example
     * // Get one TimeAndTemperature
     * const timeAndTemperature = await prisma.timeAndTemperature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TimeAndTemperatureFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureFindFirstArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TimeAndTemperature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureFindFirstOrThrowArgs} args - Arguments to find a TimeAndTemperature
     * @example
     * // Get one TimeAndTemperature
     * const timeAndTemperature = await prisma.timeAndTemperature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TimeAndTemperatureFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TimeAndTemperatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeAndTemperatures
     * const timeAndTemperatures = await prisma.timeAndTemperature.findMany()
     * 
     * // Get first 10 TimeAndTemperatures
     * const timeAndTemperatures = await prisma.timeAndTemperature.findMany({ take: 10 })
     * 
     * // Only select the `recipeId`
     * const timeAndTemperatureWithRecipeIdOnly = await prisma.timeAndTemperature.findMany({ select: { recipeId: true } })
     * 
    **/
    findMany<T extends TimeAndTemperatureFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TimeAndTemperature.
     * @param {TimeAndTemperatureCreateArgs} args - Arguments to create a TimeAndTemperature.
     * @example
     * // Create one TimeAndTemperature
     * const TimeAndTemperature = await prisma.timeAndTemperature.create({
     *   data: {
     *     // ... data to create a TimeAndTemperature
     *   }
     * })
     * 
    **/
    create<T extends TimeAndTemperatureCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureCreateArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TimeAndTemperatures.
     *     @param {TimeAndTemperatureCreateManyArgs} args - Arguments to create many TimeAndTemperatures.
     *     @example
     *     // Create many TimeAndTemperatures
     *     const timeAndTemperature = await prisma.timeAndTemperature.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TimeAndTemperatureCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TimeAndTemperature.
     * @param {TimeAndTemperatureDeleteArgs} args - Arguments to delete one TimeAndTemperature.
     * @example
     * // Delete one TimeAndTemperature
     * const TimeAndTemperature = await prisma.timeAndTemperature.delete({
     *   where: {
     *     // ... filter to delete one TimeAndTemperature
     *   }
     * })
     * 
    **/
    delete<T extends TimeAndTemperatureDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureDeleteArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TimeAndTemperature.
     * @param {TimeAndTemperatureUpdateArgs} args - Arguments to update one TimeAndTemperature.
     * @example
     * // Update one TimeAndTemperature
     * const timeAndTemperature = await prisma.timeAndTemperature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TimeAndTemperatureUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureUpdateArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TimeAndTemperatures.
     * @param {TimeAndTemperatureDeleteManyArgs} args - Arguments to filter TimeAndTemperatures to delete.
     * @example
     * // Delete a few TimeAndTemperatures
     * const { count } = await prisma.timeAndTemperature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TimeAndTemperatureDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeAndTemperatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeAndTemperatures
     * const timeAndTemperature = await prisma.timeAndTemperature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TimeAndTemperatureUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeAndTemperature.
     * @param {TimeAndTemperatureUpsertArgs} args - Arguments to update or create a TimeAndTemperature.
     * @example
     * // Update or create a TimeAndTemperature
     * const timeAndTemperature = await prisma.timeAndTemperature.upsert({
     *   create: {
     *     // ... data to create a TimeAndTemperature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeAndTemperature we want to update
     *   }
     * })
    **/
    upsert<T extends TimeAndTemperatureUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureUpsertArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureClient<$Result.GetResult<Prisma.$TimeAndTemperaturePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TimeAndTemperatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureCountArgs} args - Arguments to filter TimeAndTemperatures to count.
     * @example
     * // Count the number of TimeAndTemperatures
     * const count = await prisma.timeAndTemperature.count({
     *   where: {
     *     // ... the filter for the TimeAndTemperatures we want to count
     *   }
     * })
    **/
    count<T extends TimeAndTemperatureCountArgs>(
      args?: Subset<T, TimeAndTemperatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeAndTemperatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeAndTemperature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeAndTemperatureAggregateArgs>(args: Subset<T, TimeAndTemperatureAggregateArgs>): Prisma.PrismaPromise<GetTimeAndTemperatureAggregateType<T>>

    /**
     * Group by TimeAndTemperature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeAndTemperatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeAndTemperatureGroupByArgs['orderBy'] }
        : { orderBy?: TimeAndTemperatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeAndTemperatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeAndTemperatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeAndTemperature model
   */
  readonly fields: TimeAndTemperatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeAndTemperature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeAndTemperatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    instruction<T extends InstructionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstructionDefaultArgs<ExtArgs>>): Prisma__InstructionClient<$Result.GetResult<Prisma.$InstructionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TimeAndTemperature model
   */ 
  interface TimeAndTemperatureFieldRefs {
    readonly recipeId: FieldRef<"TimeAndTemperature", 'String'>
    readonly step: FieldRef<"TimeAndTemperature", 'Int'>
    readonly hours: FieldRef<"TimeAndTemperature", 'Int'>
    readonly minutes: FieldRef<"TimeAndTemperature", 'Int'>
    readonly temperature: FieldRef<"TimeAndTemperature", 'Int'>
    readonly unit: FieldRef<"TimeAndTemperature", 'TemperatureUnit'>
  }
    

  // Custom InputTypes

  /**
   * TimeAndTemperature findUnique
   */
  export type TimeAndTemperatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperature to fetch.
     */
    where: TimeAndTemperatureWhereUniqueInput
  }


  /**
   * TimeAndTemperature findUniqueOrThrow
   */
  export type TimeAndTemperatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperature to fetch.
     */
    where: TimeAndTemperatureWhereUniqueInput
  }


  /**
   * TimeAndTemperature findFirst
   */
  export type TimeAndTemperatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperature to fetch.
     */
    where?: TimeAndTemperatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatures to fetch.
     */
    orderBy?: TimeAndTemperatureOrderByWithRelationInput | TimeAndTemperatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeAndTemperatures.
     */
    cursor?: TimeAndTemperatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeAndTemperatures.
     */
    distinct?: TimeAndTemperatureScalarFieldEnum | TimeAndTemperatureScalarFieldEnum[]
  }


  /**
   * TimeAndTemperature findFirstOrThrow
   */
  export type TimeAndTemperatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperature to fetch.
     */
    where?: TimeAndTemperatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatures to fetch.
     */
    orderBy?: TimeAndTemperatureOrderByWithRelationInput | TimeAndTemperatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeAndTemperatures.
     */
    cursor?: TimeAndTemperatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeAndTemperatures.
     */
    distinct?: TimeAndTemperatureScalarFieldEnum | TimeAndTemperatureScalarFieldEnum[]
  }


  /**
   * TimeAndTemperature findMany
   */
  export type TimeAndTemperatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperatures to fetch.
     */
    where?: TimeAndTemperatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatures to fetch.
     */
    orderBy?: TimeAndTemperatureOrderByWithRelationInput | TimeAndTemperatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeAndTemperatures.
     */
    cursor?: TimeAndTemperatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatures.
     */
    skip?: number
    distinct?: TimeAndTemperatureScalarFieldEnum | TimeAndTemperatureScalarFieldEnum[]
  }


  /**
   * TimeAndTemperature create
   */
  export type TimeAndTemperatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeAndTemperature.
     */
    data: XOR<TimeAndTemperatureCreateInput, TimeAndTemperatureUncheckedCreateInput>
  }


  /**
   * TimeAndTemperature createMany
   */
  export type TimeAndTemperatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeAndTemperatures.
     */
    data: TimeAndTemperatureCreateManyInput | TimeAndTemperatureCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TimeAndTemperature update
   */
  export type TimeAndTemperatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeAndTemperature.
     */
    data: XOR<TimeAndTemperatureUpdateInput, TimeAndTemperatureUncheckedUpdateInput>
    /**
     * Choose, which TimeAndTemperature to update.
     */
    where: TimeAndTemperatureWhereUniqueInput
  }


  /**
   * TimeAndTemperature updateMany
   */
  export type TimeAndTemperatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeAndTemperatures.
     */
    data: XOR<TimeAndTemperatureUpdateManyMutationInput, TimeAndTemperatureUncheckedUpdateManyInput>
    /**
     * Filter which TimeAndTemperatures to update
     */
    where?: TimeAndTemperatureWhereInput
  }


  /**
   * TimeAndTemperature upsert
   */
  export type TimeAndTemperatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeAndTemperature to update in case it exists.
     */
    where: TimeAndTemperatureWhereUniqueInput
    /**
     * In case the TimeAndTemperature found by the `where` argument doesn't exist, create a new TimeAndTemperature with this data.
     */
    create: XOR<TimeAndTemperatureCreateInput, TimeAndTemperatureUncheckedCreateInput>
    /**
     * In case the TimeAndTemperature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeAndTemperatureUpdateInput, TimeAndTemperatureUncheckedUpdateInput>
  }


  /**
   * TimeAndTemperature delete
   */
  export type TimeAndTemperatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
    /**
     * Filter which TimeAndTemperature to delete.
     */
    where: TimeAndTemperatureWhereUniqueInput
  }


  /**
   * TimeAndTemperature deleteMany
   */
  export type TimeAndTemperatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeAndTemperatures to delete
     */
    where?: TimeAndTemperatureWhereInput
  }


  /**
   * TimeAndTemperature without action
   */
  export type TimeAndTemperatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperature
     */
    select?: TimeAndTemperatureSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureInclude<ExtArgs> | null
  }



  /**
   * Model RecipeIngredient
   */

  export type AggregateRecipeIngredient = {
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  export type RecipeIngredientAvgAggregateOutputType = {
    quantity: number | null
  }

  export type RecipeIngredientSumAggregateOutputType = {
    quantity: number | null
  }

  export type RecipeIngredientMinAggregateOutputType = {
    recipeId: string | null
    ingredientId: string | null
    quantity: number | null
    unit: $Enums.IngredientUnit | null
  }

  export type RecipeIngredientMaxAggregateOutputType = {
    recipeId: string | null
    ingredientId: string | null
    quantity: number | null
    unit: $Enums.IngredientUnit | null
  }

  export type RecipeIngredientCountAggregateOutputType = {
    recipeId: number
    ingredientId: number
    quantity: number
    unit: number
    _all: number
  }


  export type RecipeIngredientAvgAggregateInputType = {
    quantity?: true
  }

  export type RecipeIngredientSumAggregateInputType = {
    quantity?: true
  }

  export type RecipeIngredientMinAggregateInputType = {
    recipeId?: true
    ingredientId?: true
    quantity?: true
    unit?: true
  }

  export type RecipeIngredientMaxAggregateInputType = {
    recipeId?: true
    ingredientId?: true
    quantity?: true
    unit?: true
  }

  export type RecipeIngredientCountAggregateInputType = {
    recipeId?: true
    ingredientId?: true
    quantity?: true
    unit?: true
    _all?: true
  }

  export type RecipeIngredientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredient to aggregate.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RecipeIngredients
    **/
    _count?: true | RecipeIngredientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeIngredientAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeIngredientSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeIngredientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type GetRecipeIngredientAggregateType<T extends RecipeIngredientAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipeIngredient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipeIngredient[P]>
      : GetScalarType<T[P], AggregateRecipeIngredient[P]>
  }




  export type RecipeIngredientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeIngredientWhereInput
    orderBy?: RecipeIngredientOrderByWithAggregationInput | RecipeIngredientOrderByWithAggregationInput[]
    by: RecipeIngredientScalarFieldEnum[] | RecipeIngredientScalarFieldEnum
    having?: RecipeIngredientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeIngredientCountAggregateInputType | true
    _avg?: RecipeIngredientAvgAggregateInputType
    _sum?: RecipeIngredientSumAggregateInputType
    _min?: RecipeIngredientMinAggregateInputType
    _max?: RecipeIngredientMaxAggregateInputType
  }

  export type RecipeIngredientGroupByOutputType = {
    recipeId: string
    ingredientId: string
    quantity: number
    unit: $Enums.IngredientUnit | null
    _count: RecipeIngredientCountAggregateOutputType | null
    _avg: RecipeIngredientAvgAggregateOutputType | null
    _sum: RecipeIngredientSumAggregateOutputType | null
    _min: RecipeIngredientMinAggregateOutputType | null
    _max: RecipeIngredientMaxAggregateOutputType | null
  }

  type GetRecipeIngredientGroupByPayload<T extends RecipeIngredientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeIngredientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeIngredientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeIngredientGroupByOutputType[P]>
        }
      >
    >


  export type RecipeIngredientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeId?: boolean
    ingredientId?: boolean
    quantity?: boolean
    unit?: boolean
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipeIngredient"]>

  export type RecipeIngredientSelectScalar = {
    recipeId?: boolean
    ingredientId?: boolean
    quantity?: boolean
    unit?: boolean
  }

  export type RecipeIngredientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }


  export type $RecipeIngredientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RecipeIngredient"
    objects: {
      ingredient: Prisma.$IngredientPayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeId: string
      ingredientId: string
      quantity: number
      unit: $Enums.IngredientUnit | null
    }, ExtArgs["result"]["recipeIngredient"]>
    composites: {}
  }


  type RecipeIngredientGetPayload<S extends boolean | null | undefined | RecipeIngredientDefaultArgs> = $Result.GetResult<Prisma.$RecipeIngredientPayload, S>

  type RecipeIngredientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeIngredientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeIngredientCountAggregateInputType | true
    }

  export interface RecipeIngredientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RecipeIngredient'], meta: { name: 'RecipeIngredient' } }
    /**
     * Find zero or one RecipeIngredient that matches the filter.
     * @param {RecipeIngredientFindUniqueArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RecipeIngredientFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeIngredientFindUniqueArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecipeIngredient that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RecipeIngredientFindUniqueOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeIngredientFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecipeIngredient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RecipeIngredientFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeIngredientFindFirstArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecipeIngredient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindFirstOrThrowArgs} args - Arguments to find a RecipeIngredient
     * @example
     * // Get one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RecipeIngredientFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeIngredientFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecipeIngredients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany()
     * 
     * // Get first 10 RecipeIngredients
     * const recipeIngredients = await prisma.recipeIngredient.findMany({ take: 10 })
     * 
     * // Only select the `recipeId`
     * const recipeIngredientWithRecipeIdOnly = await prisma.recipeIngredient.findMany({ select: { recipeId: true } })
     * 
    **/
    findMany<T extends RecipeIngredientFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeIngredientFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecipeIngredient.
     * @param {RecipeIngredientCreateArgs} args - Arguments to create a RecipeIngredient.
     * @example
     * // Create one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.create({
     *   data: {
     *     // ... data to create a RecipeIngredient
     *   }
     * })
     * 
    **/
    create<T extends RecipeIngredientCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeIngredientCreateArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecipeIngredients.
     *     @param {RecipeIngredientCreateManyArgs} args - Arguments to create many RecipeIngredients.
     *     @example
     *     // Create many RecipeIngredients
     *     const recipeIngredient = await prisma.recipeIngredient.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RecipeIngredientCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeIngredientCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecipeIngredient.
     * @param {RecipeIngredientDeleteArgs} args - Arguments to delete one RecipeIngredient.
     * @example
     * // Delete one RecipeIngredient
     * const RecipeIngredient = await prisma.recipeIngredient.delete({
     *   where: {
     *     // ... filter to delete one RecipeIngredient
     *   }
     * })
     * 
    **/
    delete<T extends RecipeIngredientDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeIngredientDeleteArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecipeIngredient.
     * @param {RecipeIngredientUpdateArgs} args - Arguments to update one RecipeIngredient.
     * @example
     * // Update one RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RecipeIngredientUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeIngredientUpdateArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecipeIngredients.
     * @param {RecipeIngredientDeleteManyArgs} args - Arguments to filter RecipeIngredients to delete.
     * @example
     * // Delete a few RecipeIngredients
     * const { count } = await prisma.recipeIngredient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RecipeIngredientDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RecipeIngredientDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecipeIngredients
     * const recipeIngredient = await prisma.recipeIngredient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RecipeIngredientUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeIngredientUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecipeIngredient.
     * @param {RecipeIngredientUpsertArgs} args - Arguments to update or create a RecipeIngredient.
     * @example
     * // Update or create a RecipeIngredient
     * const recipeIngredient = await prisma.recipeIngredient.upsert({
     *   create: {
     *     // ... data to create a RecipeIngredient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecipeIngredient we want to update
     *   }
     * })
    **/
    upsert<T extends RecipeIngredientUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RecipeIngredientUpsertArgs<ExtArgs>>
    ): Prisma__RecipeIngredientClient<$Result.GetResult<Prisma.$RecipeIngredientPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecipeIngredients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientCountArgs} args - Arguments to filter RecipeIngredients to count.
     * @example
     * // Count the number of RecipeIngredients
     * const count = await prisma.recipeIngredient.count({
     *   where: {
     *     // ... the filter for the RecipeIngredients we want to count
     *   }
     * })
    **/
    count<T extends RecipeIngredientCountArgs>(
      args?: Subset<T, RecipeIngredientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeIngredientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeIngredientAggregateArgs>(args: Subset<T, RecipeIngredientAggregateArgs>): Prisma.PrismaPromise<GetRecipeIngredientAggregateType<T>>

    /**
     * Group by RecipeIngredient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeIngredientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeIngredientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeIngredientGroupByArgs['orderBy'] }
        : { orderBy?: RecipeIngredientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeIngredientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeIngredientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RecipeIngredient model
   */
  readonly fields: RecipeIngredientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RecipeIngredient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeIngredientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the RecipeIngredient model
   */ 
  interface RecipeIngredientFieldRefs {
    readonly recipeId: FieldRef<"RecipeIngredient", 'String'>
    readonly ingredientId: FieldRef<"RecipeIngredient", 'String'>
    readonly quantity: FieldRef<"RecipeIngredient", 'Int'>
    readonly unit: FieldRef<"RecipeIngredient", 'IngredientUnit'>
  }
    

  // Custom InputTypes

  /**
   * RecipeIngredient findUnique
   */
  export type RecipeIngredientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }


  /**
   * RecipeIngredient findUniqueOrThrow
   */
  export type RecipeIngredientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where: RecipeIngredientWhereUniqueInput
  }


  /**
   * RecipeIngredient findFirst
   */
  export type RecipeIngredientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }


  /**
   * RecipeIngredient findFirstOrThrow
   */
  export type RecipeIngredientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredient to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RecipeIngredients.
     */
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }


  /**
   * RecipeIngredient findMany
   */
  export type RecipeIngredientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter, which RecipeIngredients to fetch.
     */
    where?: RecipeIngredientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RecipeIngredients to fetch.
     */
    orderBy?: RecipeIngredientOrderByWithRelationInput | RecipeIngredientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RecipeIngredients.
     */
    cursor?: RecipeIngredientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RecipeIngredients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RecipeIngredients.
     */
    skip?: number
    distinct?: RecipeIngredientScalarFieldEnum | RecipeIngredientScalarFieldEnum[]
  }


  /**
   * RecipeIngredient create
   */
  export type RecipeIngredientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to create a RecipeIngredient.
     */
    data: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
  }


  /**
   * RecipeIngredient createMany
   */
  export type RecipeIngredientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RecipeIngredients.
     */
    data: RecipeIngredientCreateManyInput | RecipeIngredientCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * RecipeIngredient update
   */
  export type RecipeIngredientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The data needed to update a RecipeIngredient.
     */
    data: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
    /**
     * Choose, which RecipeIngredient to update.
     */
    where: RecipeIngredientWhereUniqueInput
  }


  /**
   * RecipeIngredient updateMany
   */
  export type RecipeIngredientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RecipeIngredients.
     */
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyInput>
    /**
     * Filter which RecipeIngredients to update
     */
    where?: RecipeIngredientWhereInput
  }


  /**
   * RecipeIngredient upsert
   */
  export type RecipeIngredientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * The filter to search for the RecipeIngredient to update in case it exists.
     */
    where: RecipeIngredientWhereUniqueInput
    /**
     * In case the RecipeIngredient found by the `where` argument doesn't exist, create a new RecipeIngredient with this data.
     */
    create: XOR<RecipeIngredientCreateInput, RecipeIngredientUncheckedCreateInput>
    /**
     * In case the RecipeIngredient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeIngredientUpdateInput, RecipeIngredientUncheckedUpdateInput>
  }


  /**
   * RecipeIngredient delete
   */
  export type RecipeIngredientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
    /**
     * Filter which RecipeIngredient to delete.
     */
    where: RecipeIngredientWhereUniqueInput
  }


  /**
   * RecipeIngredient deleteMany
   */
  export type RecipeIngredientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RecipeIngredients to delete
     */
    where?: RecipeIngredientWhereInput
  }


  /**
   * RecipeIngredient without action
   */
  export type RecipeIngredientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeIngredient
     */
    select?: RecipeIngredientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RecipeIngredientInclude<ExtArgs> | null
  }



  /**
   * Model Component
   */

  export type AggregateComponent = {
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  export type ComponentAvgAggregateOutputType = {
    amount: number | null
  }

  export type ComponentSumAggregateOutputType = {
    amount: number | null
  }

  export type ComponentMinAggregateOutputType = {
    recipeId: string | null
    componentId: string | null
    amount: number | null
  }

  export type ComponentMaxAggregateOutputType = {
    recipeId: string | null
    componentId: string | null
    amount: number | null
  }

  export type ComponentCountAggregateOutputType = {
    recipeId: number
    componentId: number
    amount: number
    _all: number
  }


  export type ComponentAvgAggregateInputType = {
    amount?: true
  }

  export type ComponentSumAggregateInputType = {
    amount?: true
  }

  export type ComponentMinAggregateInputType = {
    recipeId?: true
    componentId?: true
    amount?: true
  }

  export type ComponentMaxAggregateInputType = {
    recipeId?: true
    componentId?: true
    amount?: true
  }

  export type ComponentCountAggregateInputType = {
    recipeId?: true
    componentId?: true
    amount?: true
    _all?: true
  }

  export type ComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Component to aggregate.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Components
    **/
    _count?: true | ComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentMaxAggregateInputType
  }

  export type GetComponentAggregateType<T extends ComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent[P]>
      : GetScalarType<T[P], AggregateComponent[P]>
  }




  export type ComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithAggregationInput | ComponentOrderByWithAggregationInput[]
    by: ComponentScalarFieldEnum[] | ComponentScalarFieldEnum
    having?: ComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentCountAggregateInputType | true
    _avg?: ComponentAvgAggregateInputType
    _sum?: ComponentSumAggregateInputType
    _min?: ComponentMinAggregateInputType
    _max?: ComponentMaxAggregateInputType
  }

  export type ComponentGroupByOutputType = {
    recipeId: string
    componentId: string
    amount: number
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  type GetComponentGroupByPayload<T extends ComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupByOutputType[P]>
        }
      >
    >


  export type ComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    recipeId?: boolean
    componentId?: boolean
    amount?: boolean
    component?: boolean | RecipeDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectScalar = {
    recipeId?: boolean
    componentId?: boolean
    amount?: boolean
  }

  export type ComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    component?: boolean | RecipeDefaultArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
  }


  export type $ComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Component"
    objects: {
      component: Prisma.$RecipePayload<ExtArgs>
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      recipeId: string
      componentId: string
      amount: number
    }, ExtArgs["result"]["component"]>
    composites: {}
  }


  type ComponentGetPayload<S extends boolean | null | undefined | ComponentDefaultArgs> = $Result.GetResult<Prisma.$ComponentPayload, S>

  type ComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComponentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComponentCountAggregateInputType | true
    }

  export interface ComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Component'], meta: { name: 'Component' } }
    /**
     * Find zero or one Component that matches the filter.
     * @param {ComponentFindUniqueArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComponentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ComponentFindUniqueArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Component that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ComponentFindUniqueOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ComponentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComponentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Component that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComponentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ComponentFindFirstArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Component that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ComponentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComponentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Components
     * const components = await prisma.component.findMany()
     * 
     * // Get first 10 Components
     * const components = await prisma.component.findMany({ take: 10 })
     * 
     * // Only select the `recipeId`
     * const componentWithRecipeIdOnly = await prisma.component.findMany({ select: { recipeId: true } })
     * 
    **/
    findMany<T extends ComponentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComponentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Component.
     * @param {ComponentCreateArgs} args - Arguments to create a Component.
     * @example
     * // Create one Component
     * const Component = await prisma.component.create({
     *   data: {
     *     // ... data to create a Component
     *   }
     * })
     * 
    **/
    create<T extends ComponentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ComponentCreateArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Components.
     *     @param {ComponentCreateManyArgs} args - Arguments to create many Components.
     *     @example
     *     // Create many Components
     *     const component = await prisma.component.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComponentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComponentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Component.
     * @param {ComponentDeleteArgs} args - Arguments to delete one Component.
     * @example
     * // Delete one Component
     * const Component = await prisma.component.delete({
     *   where: {
     *     // ... filter to delete one Component
     *   }
     * })
     * 
    **/
    delete<T extends ComponentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ComponentDeleteArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Component.
     * @param {ComponentUpdateArgs} args - Arguments to update one Component.
     * @example
     * // Update one Component
     * const component = await prisma.component.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComponentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ComponentUpdateArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Components.
     * @param {ComponentDeleteManyArgs} args - Arguments to filter Components to delete.
     * @example
     * // Delete a few Components
     * const { count } = await prisma.component.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComponentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComponentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComponentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ComponentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Component.
     * @param {ComponentUpsertArgs} args - Arguments to update or create a Component.
     * @example
     * // Update or create a Component
     * const component = await prisma.component.upsert({
     *   create: {
     *     // ... data to create a Component
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component we want to update
     *   }
     * })
    **/
    upsert<T extends ComponentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ComponentUpsertArgs<ExtArgs>>
    ): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentCountArgs} args - Arguments to filter Components to count.
     * @example
     * // Count the number of Components
     * const count = await prisma.component.count({
     *   where: {
     *     // ... the filter for the Components we want to count
     *   }
     * })
    **/
    count<T extends ComponentCountArgs>(
      args?: Subset<T, ComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentAggregateArgs>(args: Subset<T, ComponentAggregateArgs>): Prisma.PrismaPromise<GetComponentAggregateType<T>>

    /**
     * Group by Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentGroupByArgs['orderBy'] }
        : { orderBy?: ComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Component model
   */
  readonly fields: ComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Component.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    component<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Component model
   */ 
  interface ComponentFieldRefs {
    readonly recipeId: FieldRef<"Component", 'String'>
    readonly componentId: FieldRef<"Component", 'String'>
    readonly amount: FieldRef<"Component", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * Component findUnique
   */
  export type ComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }


  /**
   * Component findUniqueOrThrow
   */
  export type ComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }


  /**
   * Component findFirst
   */
  export type ComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }


  /**
   * Component findFirstOrThrow
   */
  export type ComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }


  /**
   * Component findMany
   */
  export type ComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Components to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }


  /**
   * Component create
   */
  export type ComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a Component.
     */
    data: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
  }


  /**
   * Component createMany
   */
  export type ComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Component update
   */
  export type ComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a Component.
     */
    data: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
    /**
     * Choose, which Component to update.
     */
    where: ComponentWhereUniqueInput
  }


  /**
   * Component updateMany
   */
  export type ComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
  }


  /**
   * Component upsert
   */
  export type ComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the Component to update in case it exists.
     */
    where: ComponentWhereUniqueInput
    /**
     * In case the Component found by the `where` argument doesn't exist, create a new Component with this data.
     */
    create: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
    /**
     * In case the Component was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
  }


  /**
   * Component delete
   */
  export type ComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter which Component to delete.
     */
    where: ComponentWhereUniqueInput
  }


  /**
   * Component deleteMany
   */
  export type ComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Components to delete
     */
    where?: ComponentWhereInput
  }


  /**
   * Component without action
   */
  export type ComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComponentInclude<ExtArgs> | null
  }



  /**
   * Model Iteration
   */

  export type AggregateIteration = {
    _count: IterationCountAggregateOutputType | null
    _min: IterationMinAggregateOutputType | null
    _max: IterationMaxAggregateOutputType | null
  }

  export type IterationMinAggregateOutputType = {
    id: string | null
    recipeId: string | null
    createdOn: Date | null
    updatedAt: Date | null
    parentId: string | null
    tag: string | null
  }

  export type IterationMaxAggregateOutputType = {
    id: string | null
    recipeId: string | null
    createdOn: Date | null
    updatedAt: Date | null
    parentId: string | null
    tag: string | null
  }

  export type IterationCountAggregateOutputType = {
    id: number
    recipeId: number
    createdOn: number
    updatedAt: number
    parentId: number
    tag: number
    _all: number
  }


  export type IterationMinAggregateInputType = {
    id?: true
    recipeId?: true
    createdOn?: true
    updatedAt?: true
    parentId?: true
    tag?: true
  }

  export type IterationMaxAggregateInputType = {
    id?: true
    recipeId?: true
    createdOn?: true
    updatedAt?: true
    parentId?: true
    tag?: true
  }

  export type IterationCountAggregateInputType = {
    id?: true
    recipeId?: true
    createdOn?: true
    updatedAt?: true
    parentId?: true
    tag?: true
    _all?: true
  }

  export type IterationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Iteration to aggregate.
     */
    where?: IterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Iterations to fetch.
     */
    orderBy?: IterationOrderByWithRelationInput | IterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Iterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Iterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Iterations
    **/
    _count?: true | IterationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IterationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IterationMaxAggregateInputType
  }

  export type GetIterationAggregateType<T extends IterationAggregateArgs> = {
        [P in keyof T & keyof AggregateIteration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIteration[P]>
      : GetScalarType<T[P], AggregateIteration[P]>
  }




  export type IterationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IterationWhereInput
    orderBy?: IterationOrderByWithAggregationInput | IterationOrderByWithAggregationInput[]
    by: IterationScalarFieldEnum[] | IterationScalarFieldEnum
    having?: IterationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IterationCountAggregateInputType | true
    _min?: IterationMinAggregateInputType
    _max?: IterationMaxAggregateInputType
  }

  export type IterationGroupByOutputType = {
    id: string
    recipeId: string
    createdOn: Date | null
    updatedAt: Date | null
    parentId: string | null
    tag: string | null
    _count: IterationCountAggregateOutputType | null
    _min: IterationMinAggregateOutputType | null
    _max: IterationMaxAggregateOutputType | null
  }

  type GetIterationGroupByPayload<T extends IterationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IterationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IterationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IterationGroupByOutputType[P]>
            : GetScalarType<T[P], IterationGroupByOutputType[P]>
        }
      >
    >


  export type IterationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    createdOn?: boolean
    updatedAt?: boolean
    parentId?: boolean
    tag?: boolean
    ingredients?: boolean | Iteration$ingredientsArgs<ExtArgs>
    instructions?: boolean | Iteration$instructionsArgs<ExtArgs>
    parent?: boolean | Iteration$parentArgs<ExtArgs>
    children?: boolean | Iteration$childrenArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    _count?: boolean | IterationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["iteration"]>

  export type IterationSelectScalar = {
    id?: boolean
    recipeId?: boolean
    createdOn?: boolean
    updatedAt?: boolean
    parentId?: boolean
    tag?: boolean
  }

  export type IterationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredients?: boolean | Iteration$ingredientsArgs<ExtArgs>
    instructions?: boolean | Iteration$instructionsArgs<ExtArgs>
    parent?: boolean | Iteration$parentArgs<ExtArgs>
    children?: boolean | Iteration$childrenArgs<ExtArgs>
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    _count?: boolean | IterationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $IterationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Iteration"
    objects: {
      ingredients: Prisma.$IngredientIterationPayload<ExtArgs>[]
      instructions: Prisma.$InstructionIterationPayload<ExtArgs>[]
      parent: Prisma.$IterationPayload<ExtArgs> | null
      children: Prisma.$IterationPayload<ExtArgs>[]
      recipe: Prisma.$RecipePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipeId: string
      createdOn: Date | null
      updatedAt: Date | null
      parentId: string | null
      tag: string | null
    }, ExtArgs["result"]["iteration"]>
    composites: {}
  }


  type IterationGetPayload<S extends boolean | null | undefined | IterationDefaultArgs> = $Result.GetResult<Prisma.$IterationPayload, S>

  type IterationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IterationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IterationCountAggregateInputType | true
    }

  export interface IterationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Iteration'], meta: { name: 'Iteration' } }
    /**
     * Find zero or one Iteration that matches the filter.
     * @param {IterationFindUniqueArgs} args - Arguments to find a Iteration
     * @example
     * // Get one Iteration
     * const iteration = await prisma.iteration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IterationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IterationFindUniqueArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Iteration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IterationFindUniqueOrThrowArgs} args - Arguments to find a Iteration
     * @example
     * // Get one Iteration
     * const iteration = await prisma.iteration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IterationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IterationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Iteration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IterationFindFirstArgs} args - Arguments to find a Iteration
     * @example
     * // Get one Iteration
     * const iteration = await prisma.iteration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IterationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IterationFindFirstArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Iteration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IterationFindFirstOrThrowArgs} args - Arguments to find a Iteration
     * @example
     * // Get one Iteration
     * const iteration = await prisma.iteration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IterationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IterationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Iterations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IterationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Iterations
     * const iterations = await prisma.iteration.findMany()
     * 
     * // Get first 10 Iterations
     * const iterations = await prisma.iteration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iterationWithIdOnly = await prisma.iteration.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IterationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IterationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Iteration.
     * @param {IterationCreateArgs} args - Arguments to create a Iteration.
     * @example
     * // Create one Iteration
     * const Iteration = await prisma.iteration.create({
     *   data: {
     *     // ... data to create a Iteration
     *   }
     * })
     * 
    **/
    create<T extends IterationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IterationCreateArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Iterations.
     *     @param {IterationCreateManyArgs} args - Arguments to create many Iterations.
     *     @example
     *     // Create many Iterations
     *     const iteration = await prisma.iteration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IterationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IterationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Iteration.
     * @param {IterationDeleteArgs} args - Arguments to delete one Iteration.
     * @example
     * // Delete one Iteration
     * const Iteration = await prisma.iteration.delete({
     *   where: {
     *     // ... filter to delete one Iteration
     *   }
     * })
     * 
    **/
    delete<T extends IterationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IterationDeleteArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Iteration.
     * @param {IterationUpdateArgs} args - Arguments to update one Iteration.
     * @example
     * // Update one Iteration
     * const iteration = await prisma.iteration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IterationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IterationUpdateArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Iterations.
     * @param {IterationDeleteManyArgs} args - Arguments to filter Iterations to delete.
     * @example
     * // Delete a few Iterations
     * const { count } = await prisma.iteration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IterationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IterationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Iterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IterationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Iterations
     * const iteration = await prisma.iteration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IterationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IterationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Iteration.
     * @param {IterationUpsertArgs} args - Arguments to update or create a Iteration.
     * @example
     * // Update or create a Iteration
     * const iteration = await prisma.iteration.upsert({
     *   create: {
     *     // ... data to create a Iteration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Iteration we want to update
     *   }
     * })
    **/
    upsert<T extends IterationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IterationUpsertArgs<ExtArgs>>
    ): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Iterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IterationCountArgs} args - Arguments to filter Iterations to count.
     * @example
     * // Count the number of Iterations
     * const count = await prisma.iteration.count({
     *   where: {
     *     // ... the filter for the Iterations we want to count
     *   }
     * })
    **/
    count<T extends IterationCountArgs>(
      args?: Subset<T, IterationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IterationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Iteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IterationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IterationAggregateArgs>(args: Subset<T, IterationAggregateArgs>): Prisma.PrismaPromise<GetIterationAggregateType<T>>

    /**
     * Group by Iteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IterationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IterationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IterationGroupByArgs['orderBy'] }
        : { orderBy?: IterationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IterationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIterationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Iteration model
   */
  readonly fields: IterationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Iteration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IterationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredients<T extends Iteration$ingredientsArgs<ExtArgs> = {}>(args?: Subset<T, Iteration$ingredientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'findMany'> | Null>;

    instructions<T extends Iteration$instructionsArgs<ExtArgs> = {}>(args?: Subset<T, Iteration$instructionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'findMany'> | Null>;

    parent<T extends Iteration$parentArgs<ExtArgs> = {}>(args?: Subset<T, Iteration$parentArgs<ExtArgs>>): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    children<T extends Iteration$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Iteration$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findMany'> | Null>;

    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Iteration model
   */ 
  interface IterationFieldRefs {
    readonly id: FieldRef<"Iteration", 'String'>
    readonly recipeId: FieldRef<"Iteration", 'String'>
    readonly createdOn: FieldRef<"Iteration", 'DateTime'>
    readonly updatedAt: FieldRef<"Iteration", 'DateTime'>
    readonly parentId: FieldRef<"Iteration", 'String'>
    readonly tag: FieldRef<"Iteration", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Iteration findUnique
   */
  export type IterationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * Filter, which Iteration to fetch.
     */
    where: IterationWhereUniqueInput
  }


  /**
   * Iteration findUniqueOrThrow
   */
  export type IterationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * Filter, which Iteration to fetch.
     */
    where: IterationWhereUniqueInput
  }


  /**
   * Iteration findFirst
   */
  export type IterationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * Filter, which Iteration to fetch.
     */
    where?: IterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Iterations to fetch.
     */
    orderBy?: IterationOrderByWithRelationInput | IterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Iterations.
     */
    cursor?: IterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Iterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Iterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Iterations.
     */
    distinct?: IterationScalarFieldEnum | IterationScalarFieldEnum[]
  }


  /**
   * Iteration findFirstOrThrow
   */
  export type IterationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * Filter, which Iteration to fetch.
     */
    where?: IterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Iterations to fetch.
     */
    orderBy?: IterationOrderByWithRelationInput | IterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Iterations.
     */
    cursor?: IterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Iterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Iterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Iterations.
     */
    distinct?: IterationScalarFieldEnum | IterationScalarFieldEnum[]
  }


  /**
   * Iteration findMany
   */
  export type IterationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * Filter, which Iterations to fetch.
     */
    where?: IterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Iterations to fetch.
     */
    orderBy?: IterationOrderByWithRelationInput | IterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Iterations.
     */
    cursor?: IterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Iterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Iterations.
     */
    skip?: number
    distinct?: IterationScalarFieldEnum | IterationScalarFieldEnum[]
  }


  /**
   * Iteration create
   */
  export type IterationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * The data needed to create a Iteration.
     */
    data: XOR<IterationCreateInput, IterationUncheckedCreateInput>
  }


  /**
   * Iteration createMany
   */
  export type IterationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Iterations.
     */
    data: IterationCreateManyInput | IterationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Iteration update
   */
  export type IterationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * The data needed to update a Iteration.
     */
    data: XOR<IterationUpdateInput, IterationUncheckedUpdateInput>
    /**
     * Choose, which Iteration to update.
     */
    where: IterationWhereUniqueInput
  }


  /**
   * Iteration updateMany
   */
  export type IterationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Iterations.
     */
    data: XOR<IterationUpdateManyMutationInput, IterationUncheckedUpdateManyInput>
    /**
     * Filter which Iterations to update
     */
    where?: IterationWhereInput
  }


  /**
   * Iteration upsert
   */
  export type IterationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * The filter to search for the Iteration to update in case it exists.
     */
    where: IterationWhereUniqueInput
    /**
     * In case the Iteration found by the `where` argument doesn't exist, create a new Iteration with this data.
     */
    create: XOR<IterationCreateInput, IterationUncheckedCreateInput>
    /**
     * In case the Iteration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IterationUpdateInput, IterationUncheckedUpdateInput>
  }


  /**
   * Iteration delete
   */
  export type IterationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    /**
     * Filter which Iteration to delete.
     */
    where: IterationWhereUniqueInput
  }


  /**
   * Iteration deleteMany
   */
  export type IterationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Iterations to delete
     */
    where?: IterationWhereInput
  }


  /**
   * Iteration.ingredients
   */
  export type Iteration$ingredientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    where?: IngredientIterationWhereInput
    orderBy?: IngredientIterationOrderByWithRelationInput | IngredientIterationOrderByWithRelationInput[]
    cursor?: IngredientIterationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IngredientIterationScalarFieldEnum | IngredientIterationScalarFieldEnum[]
  }


  /**
   * Iteration.instructions
   */
  export type Iteration$instructionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    where?: InstructionIterationWhereInput
    orderBy?: InstructionIterationOrderByWithRelationInput | InstructionIterationOrderByWithRelationInput[]
    cursor?: InstructionIterationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstructionIterationScalarFieldEnum | InstructionIterationScalarFieldEnum[]
  }


  /**
   * Iteration.parent
   */
  export type Iteration$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    where?: IterationWhereInput
  }


  /**
   * Iteration.children
   */
  export type Iteration$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
    where?: IterationWhereInput
    orderBy?: IterationOrderByWithRelationInput | IterationOrderByWithRelationInput[]
    cursor?: IterationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IterationScalarFieldEnum | IterationScalarFieldEnum[]
  }


  /**
   * Iteration without action
   */
  export type IterationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Iteration
     */
    select?: IterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IterationInclude<ExtArgs> | null
  }



  /**
   * Model IngredientIteration
   */

  export type AggregateIngredientIteration = {
    _count: IngredientIterationCountAggregateOutputType | null
    _avg: IngredientIterationAvgAggregateOutputType | null
    _sum: IngredientIterationSumAggregateOutputType | null
    _min: IngredientIterationMinAggregateOutputType | null
    _max: IngredientIterationMaxAggregateOutputType | null
  }

  export type IngredientIterationAvgAggregateOutputType = {
    quantity: number | null
  }

  export type IngredientIterationSumAggregateOutputType = {
    quantity: number | null
  }

  export type IngredientIterationMinAggregateOutputType = {
    ingredientId: string | null
    quantity: number | null
    iterationId: string | null
    unit: $Enums.IngredientUnit | null
  }

  export type IngredientIterationMaxAggregateOutputType = {
    ingredientId: string | null
    quantity: number | null
    iterationId: string | null
    unit: $Enums.IngredientUnit | null
  }

  export type IngredientIterationCountAggregateOutputType = {
    ingredientId: number
    quantity: number
    iterationId: number
    unit: number
    _all: number
  }


  export type IngredientIterationAvgAggregateInputType = {
    quantity?: true
  }

  export type IngredientIterationSumAggregateInputType = {
    quantity?: true
  }

  export type IngredientIterationMinAggregateInputType = {
    ingredientId?: true
    quantity?: true
    iterationId?: true
    unit?: true
  }

  export type IngredientIterationMaxAggregateInputType = {
    ingredientId?: true
    quantity?: true
    iterationId?: true
    unit?: true
  }

  export type IngredientIterationCountAggregateInputType = {
    ingredientId?: true
    quantity?: true
    iterationId?: true
    unit?: true
    _all?: true
  }

  export type IngredientIterationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientIteration to aggregate.
     */
    where?: IngredientIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientIterations to fetch.
     */
    orderBy?: IngredientIterationOrderByWithRelationInput | IngredientIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngredientIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned IngredientIterations
    **/
    _count?: true | IngredientIterationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngredientIterationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngredientIterationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngredientIterationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngredientIterationMaxAggregateInputType
  }

  export type GetIngredientIterationAggregateType<T extends IngredientIterationAggregateArgs> = {
        [P in keyof T & keyof AggregateIngredientIteration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngredientIteration[P]>
      : GetScalarType<T[P], AggregateIngredientIteration[P]>
  }




  export type IngredientIterationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngredientIterationWhereInput
    orderBy?: IngredientIterationOrderByWithAggregationInput | IngredientIterationOrderByWithAggregationInput[]
    by: IngredientIterationScalarFieldEnum[] | IngredientIterationScalarFieldEnum
    having?: IngredientIterationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngredientIterationCountAggregateInputType | true
    _avg?: IngredientIterationAvgAggregateInputType
    _sum?: IngredientIterationSumAggregateInputType
    _min?: IngredientIterationMinAggregateInputType
    _max?: IngredientIterationMaxAggregateInputType
  }

  export type IngredientIterationGroupByOutputType = {
    ingredientId: string
    quantity: number
    iterationId: string
    unit: $Enums.IngredientUnit | null
    _count: IngredientIterationCountAggregateOutputType | null
    _avg: IngredientIterationAvgAggregateOutputType | null
    _sum: IngredientIterationSumAggregateOutputType | null
    _min: IngredientIterationMinAggregateOutputType | null
    _max: IngredientIterationMaxAggregateOutputType | null
  }

  type GetIngredientIterationGroupByPayload<T extends IngredientIterationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngredientIterationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngredientIterationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngredientIterationGroupByOutputType[P]>
            : GetScalarType<T[P], IngredientIterationGroupByOutputType[P]>
        }
      >
    >


  export type IngredientIterationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ingredientId?: boolean
    quantity?: boolean
    iterationId?: boolean
    unit?: boolean
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    recipe?: boolean | IterationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingredientIteration"]>

  export type IngredientIterationSelectScalar = {
    ingredientId?: boolean
    quantity?: boolean
    iterationId?: boolean
    unit?: boolean
  }

  export type IngredientIterationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingredient?: boolean | IngredientDefaultArgs<ExtArgs>
    recipe?: boolean | IterationDefaultArgs<ExtArgs>
  }


  export type $IngredientIterationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "IngredientIteration"
    objects: {
      ingredient: Prisma.$IngredientPayload<ExtArgs>
      recipe: Prisma.$IterationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ingredientId: string
      quantity: number
      iterationId: string
      unit: $Enums.IngredientUnit | null
    }, ExtArgs["result"]["ingredientIteration"]>
    composites: {}
  }


  type IngredientIterationGetPayload<S extends boolean | null | undefined | IngredientIterationDefaultArgs> = $Result.GetResult<Prisma.$IngredientIterationPayload, S>

  type IngredientIterationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IngredientIterationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IngredientIterationCountAggregateInputType | true
    }

  export interface IngredientIterationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['IngredientIteration'], meta: { name: 'IngredientIteration' } }
    /**
     * Find zero or one IngredientIteration that matches the filter.
     * @param {IngredientIterationFindUniqueArgs} args - Arguments to find a IngredientIteration
     * @example
     * // Get one IngredientIteration
     * const ingredientIteration = await prisma.ingredientIteration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IngredientIterationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientIterationFindUniqueArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IngredientIteration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {IngredientIterationFindUniqueOrThrowArgs} args - Arguments to find a IngredientIteration
     * @example
     * // Get one IngredientIteration
     * const ingredientIteration = await prisma.ingredientIteration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends IngredientIterationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientIterationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IngredientIteration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientIterationFindFirstArgs} args - Arguments to find a IngredientIteration
     * @example
     * // Get one IngredientIteration
     * const ingredientIteration = await prisma.ingredientIteration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IngredientIterationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientIterationFindFirstArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IngredientIteration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientIterationFindFirstOrThrowArgs} args - Arguments to find a IngredientIteration
     * @example
     * // Get one IngredientIteration
     * const ingredientIteration = await prisma.ingredientIteration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends IngredientIterationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientIterationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IngredientIterations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientIterationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IngredientIterations
     * const ingredientIterations = await prisma.ingredientIteration.findMany()
     * 
     * // Get first 10 IngredientIterations
     * const ingredientIterations = await prisma.ingredientIteration.findMany({ take: 10 })
     * 
     * // Only select the `ingredientId`
     * const ingredientIterationWithIngredientIdOnly = await prisma.ingredientIteration.findMany({ select: { ingredientId: true } })
     * 
    **/
    findMany<T extends IngredientIterationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientIterationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IngredientIteration.
     * @param {IngredientIterationCreateArgs} args - Arguments to create a IngredientIteration.
     * @example
     * // Create one IngredientIteration
     * const IngredientIteration = await prisma.ingredientIteration.create({
     *   data: {
     *     // ... data to create a IngredientIteration
     *   }
     * })
     * 
    **/
    create<T extends IngredientIterationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientIterationCreateArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IngredientIterations.
     *     @param {IngredientIterationCreateManyArgs} args - Arguments to create many IngredientIterations.
     *     @example
     *     // Create many IngredientIterations
     *     const ingredientIteration = await prisma.ingredientIteration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IngredientIterationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientIterationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IngredientIteration.
     * @param {IngredientIterationDeleteArgs} args - Arguments to delete one IngredientIteration.
     * @example
     * // Delete one IngredientIteration
     * const IngredientIteration = await prisma.ingredientIteration.delete({
     *   where: {
     *     // ... filter to delete one IngredientIteration
     *   }
     * })
     * 
    **/
    delete<T extends IngredientIterationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientIterationDeleteArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IngredientIteration.
     * @param {IngredientIterationUpdateArgs} args - Arguments to update one IngredientIteration.
     * @example
     * // Update one IngredientIteration
     * const ingredientIteration = await prisma.ingredientIteration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IngredientIterationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientIterationUpdateArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IngredientIterations.
     * @param {IngredientIterationDeleteManyArgs} args - Arguments to filter IngredientIterations to delete.
     * @example
     * // Delete a few IngredientIterations
     * const { count } = await prisma.ingredientIteration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IngredientIterationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, IngredientIterationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IngredientIterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientIterationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IngredientIterations
     * const ingredientIteration = await prisma.ingredientIteration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IngredientIterationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientIterationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IngredientIteration.
     * @param {IngredientIterationUpsertArgs} args - Arguments to update or create a IngredientIteration.
     * @example
     * // Update or create a IngredientIteration
     * const ingredientIteration = await prisma.ingredientIteration.upsert({
     *   create: {
     *     // ... data to create a IngredientIteration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IngredientIteration we want to update
     *   }
     * })
    **/
    upsert<T extends IngredientIterationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, IngredientIterationUpsertArgs<ExtArgs>>
    ): Prisma__IngredientIterationClient<$Result.GetResult<Prisma.$IngredientIterationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IngredientIterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientIterationCountArgs} args - Arguments to filter IngredientIterations to count.
     * @example
     * // Count the number of IngredientIterations
     * const count = await prisma.ingredientIteration.count({
     *   where: {
     *     // ... the filter for the IngredientIterations we want to count
     *   }
     * })
    **/
    count<T extends IngredientIterationCountArgs>(
      args?: Subset<T, IngredientIterationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngredientIterationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IngredientIteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientIterationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngredientIterationAggregateArgs>(args: Subset<T, IngredientIterationAggregateArgs>): Prisma.PrismaPromise<GetIngredientIterationAggregateType<T>>

    /**
     * Group by IngredientIteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngredientIterationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngredientIterationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngredientIterationGroupByArgs['orderBy'] }
        : { orderBy?: IngredientIterationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngredientIterationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngredientIterationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the IngredientIteration model
   */
  readonly fields: IngredientIterationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for IngredientIteration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngredientIterationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ingredient<T extends IngredientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngredientDefaultArgs<ExtArgs>>): Prisma__IngredientClient<$Result.GetResult<Prisma.$IngredientPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    recipe<T extends IterationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IterationDefaultArgs<ExtArgs>>): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the IngredientIteration model
   */ 
  interface IngredientIterationFieldRefs {
    readonly ingredientId: FieldRef<"IngredientIteration", 'String'>
    readonly quantity: FieldRef<"IngredientIteration", 'Int'>
    readonly iterationId: FieldRef<"IngredientIteration", 'String'>
    readonly unit: FieldRef<"IngredientIteration", 'IngredientUnit'>
  }
    

  // Custom InputTypes

  /**
   * IngredientIteration findUnique
   */
  export type IngredientIterationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * Filter, which IngredientIteration to fetch.
     */
    where: IngredientIterationWhereUniqueInput
  }


  /**
   * IngredientIteration findUniqueOrThrow
   */
  export type IngredientIterationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * Filter, which IngredientIteration to fetch.
     */
    where: IngredientIterationWhereUniqueInput
  }


  /**
   * IngredientIteration findFirst
   */
  export type IngredientIterationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * Filter, which IngredientIteration to fetch.
     */
    where?: IngredientIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientIterations to fetch.
     */
    orderBy?: IngredientIterationOrderByWithRelationInput | IngredientIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientIterations.
     */
    cursor?: IngredientIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientIterations.
     */
    distinct?: IngredientIterationScalarFieldEnum | IngredientIterationScalarFieldEnum[]
  }


  /**
   * IngredientIteration findFirstOrThrow
   */
  export type IngredientIterationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * Filter, which IngredientIteration to fetch.
     */
    where?: IngredientIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientIterations to fetch.
     */
    orderBy?: IngredientIterationOrderByWithRelationInput | IngredientIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for IngredientIterations.
     */
    cursor?: IngredientIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of IngredientIterations.
     */
    distinct?: IngredientIterationScalarFieldEnum | IngredientIterationScalarFieldEnum[]
  }


  /**
   * IngredientIteration findMany
   */
  export type IngredientIterationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * Filter, which IngredientIterations to fetch.
     */
    where?: IngredientIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of IngredientIterations to fetch.
     */
    orderBy?: IngredientIterationOrderByWithRelationInput | IngredientIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing IngredientIterations.
     */
    cursor?: IngredientIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` IngredientIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` IngredientIterations.
     */
    skip?: number
    distinct?: IngredientIterationScalarFieldEnum | IngredientIterationScalarFieldEnum[]
  }


  /**
   * IngredientIteration create
   */
  export type IngredientIterationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * The data needed to create a IngredientIteration.
     */
    data: XOR<IngredientIterationCreateInput, IngredientIterationUncheckedCreateInput>
  }


  /**
   * IngredientIteration createMany
   */
  export type IngredientIterationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many IngredientIterations.
     */
    data: IngredientIterationCreateManyInput | IngredientIterationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * IngredientIteration update
   */
  export type IngredientIterationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * The data needed to update a IngredientIteration.
     */
    data: XOR<IngredientIterationUpdateInput, IngredientIterationUncheckedUpdateInput>
    /**
     * Choose, which IngredientIteration to update.
     */
    where: IngredientIterationWhereUniqueInput
  }


  /**
   * IngredientIteration updateMany
   */
  export type IngredientIterationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update IngredientIterations.
     */
    data: XOR<IngredientIterationUpdateManyMutationInput, IngredientIterationUncheckedUpdateManyInput>
    /**
     * Filter which IngredientIterations to update
     */
    where?: IngredientIterationWhereInput
  }


  /**
   * IngredientIteration upsert
   */
  export type IngredientIterationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * The filter to search for the IngredientIteration to update in case it exists.
     */
    where: IngredientIterationWhereUniqueInput
    /**
     * In case the IngredientIteration found by the `where` argument doesn't exist, create a new IngredientIteration with this data.
     */
    create: XOR<IngredientIterationCreateInput, IngredientIterationUncheckedCreateInput>
    /**
     * In case the IngredientIteration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngredientIterationUpdateInput, IngredientIterationUncheckedUpdateInput>
  }


  /**
   * IngredientIteration delete
   */
  export type IngredientIterationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
    /**
     * Filter which IngredientIteration to delete.
     */
    where: IngredientIterationWhereUniqueInput
  }


  /**
   * IngredientIteration deleteMany
   */
  export type IngredientIterationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which IngredientIterations to delete
     */
    where?: IngredientIterationWhereInput
  }


  /**
   * IngredientIteration without action
   */
  export type IngredientIterationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngredientIteration
     */
    select?: IngredientIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: IngredientIterationInclude<ExtArgs> | null
  }



  /**
   * Model InstructionIteration
   */

  export type AggregateInstructionIteration = {
    _count: InstructionIterationCountAggregateOutputType | null
    _avg: InstructionIterationAvgAggregateOutputType | null
    _sum: InstructionIterationSumAggregateOutputType | null
    _min: InstructionIterationMinAggregateOutputType | null
    _max: InstructionIterationMaxAggregateOutputType | null
  }

  export type InstructionIterationAvgAggregateOutputType = {
    step: number | null
  }

  export type InstructionIterationSumAggregateOutputType = {
    step: number | null
  }

  export type InstructionIterationMinAggregateOutputType = {
    description: string | null
    step: number | null
    iterationId: string | null
  }

  export type InstructionIterationMaxAggregateOutputType = {
    description: string | null
    step: number | null
    iterationId: string | null
  }

  export type InstructionIterationCountAggregateOutputType = {
    description: number
    step: number
    iterationId: number
    _all: number
  }


  export type InstructionIterationAvgAggregateInputType = {
    step?: true
  }

  export type InstructionIterationSumAggregateInputType = {
    step?: true
  }

  export type InstructionIterationMinAggregateInputType = {
    description?: true
    step?: true
    iterationId?: true
  }

  export type InstructionIterationMaxAggregateInputType = {
    description?: true
    step?: true
    iterationId?: true
  }

  export type InstructionIterationCountAggregateInputType = {
    description?: true
    step?: true
    iterationId?: true
    _all?: true
  }

  export type InstructionIterationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructionIteration to aggregate.
     */
    where?: InstructionIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructionIterations to fetch.
     */
    orderBy?: InstructionIterationOrderByWithRelationInput | InstructionIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstructionIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructionIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructionIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstructionIterations
    **/
    _count?: true | InstructionIterationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstructionIterationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstructionIterationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstructionIterationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstructionIterationMaxAggregateInputType
  }

  export type GetInstructionIterationAggregateType<T extends InstructionIterationAggregateArgs> = {
        [P in keyof T & keyof AggregateInstructionIteration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstructionIteration[P]>
      : GetScalarType<T[P], AggregateInstructionIteration[P]>
  }




  export type InstructionIterationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstructionIterationWhereInput
    orderBy?: InstructionIterationOrderByWithAggregationInput | InstructionIterationOrderByWithAggregationInput[]
    by: InstructionIterationScalarFieldEnum[] | InstructionIterationScalarFieldEnum
    having?: InstructionIterationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstructionIterationCountAggregateInputType | true
    _avg?: InstructionIterationAvgAggregateInputType
    _sum?: InstructionIterationSumAggregateInputType
    _min?: InstructionIterationMinAggregateInputType
    _max?: InstructionIterationMaxAggregateInputType
  }

  export type InstructionIterationGroupByOutputType = {
    description: string
    step: number
    iterationId: string
    _count: InstructionIterationCountAggregateOutputType | null
    _avg: InstructionIterationAvgAggregateOutputType | null
    _sum: InstructionIterationSumAggregateOutputType | null
    _min: InstructionIterationMinAggregateOutputType | null
    _max: InstructionIterationMaxAggregateOutputType | null
  }

  type GetInstructionIterationGroupByPayload<T extends InstructionIterationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstructionIterationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstructionIterationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstructionIterationGroupByOutputType[P]>
            : GetScalarType<T[P], InstructionIterationGroupByOutputType[P]>
        }
      >
    >


  export type InstructionIterationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    description?: boolean
    step?: boolean
    iterationId?: boolean
    recipe?: boolean | IterationDefaultArgs<ExtArgs>
    timeAndTemperature?: boolean | InstructionIteration$timeAndTemperatureArgs<ExtArgs>
  }, ExtArgs["result"]["instructionIteration"]>

  export type InstructionIterationSelectScalar = {
    description?: boolean
    step?: boolean
    iterationId?: boolean
  }

  export type InstructionIterationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | IterationDefaultArgs<ExtArgs>
    timeAndTemperature?: boolean | InstructionIteration$timeAndTemperatureArgs<ExtArgs>
  }


  export type $InstructionIterationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstructionIteration"
    objects: {
      recipe: Prisma.$IterationPayload<ExtArgs>
      timeAndTemperature: Prisma.$TimeAndTemperatureIterationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      description: string
      step: number
      iterationId: string
    }, ExtArgs["result"]["instructionIteration"]>
    composites: {}
  }


  type InstructionIterationGetPayload<S extends boolean | null | undefined | InstructionIterationDefaultArgs> = $Result.GetResult<Prisma.$InstructionIterationPayload, S>

  type InstructionIterationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstructionIterationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstructionIterationCountAggregateInputType | true
    }

  export interface InstructionIterationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstructionIteration'], meta: { name: 'InstructionIteration' } }
    /**
     * Find zero or one InstructionIteration that matches the filter.
     * @param {InstructionIterationFindUniqueArgs} args - Arguments to find a InstructionIteration
     * @example
     * // Get one InstructionIteration
     * const instructionIteration = await prisma.instructionIteration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InstructionIterationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionIterationFindUniqueArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one InstructionIteration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InstructionIterationFindUniqueOrThrowArgs} args - Arguments to find a InstructionIteration
     * @example
     * // Get one InstructionIteration
     * const instructionIteration = await prisma.instructionIteration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InstructionIterationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionIterationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first InstructionIteration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionIterationFindFirstArgs} args - Arguments to find a InstructionIteration
     * @example
     * // Get one InstructionIteration
     * const instructionIteration = await prisma.instructionIteration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InstructionIterationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionIterationFindFirstArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first InstructionIteration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionIterationFindFirstOrThrowArgs} args - Arguments to find a InstructionIteration
     * @example
     * // Get one InstructionIteration
     * const instructionIteration = await prisma.instructionIteration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InstructionIterationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionIterationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more InstructionIterations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionIterationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstructionIterations
     * const instructionIterations = await prisma.instructionIteration.findMany()
     * 
     * // Get first 10 InstructionIterations
     * const instructionIterations = await prisma.instructionIteration.findMany({ take: 10 })
     * 
     * // Only select the `description`
     * const instructionIterationWithDescriptionOnly = await prisma.instructionIteration.findMany({ select: { description: true } })
     * 
    **/
    findMany<T extends InstructionIterationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionIterationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a InstructionIteration.
     * @param {InstructionIterationCreateArgs} args - Arguments to create a InstructionIteration.
     * @example
     * // Create one InstructionIteration
     * const InstructionIteration = await prisma.instructionIteration.create({
     *   data: {
     *     // ... data to create a InstructionIteration
     *   }
     * })
     * 
    **/
    create<T extends InstructionIterationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionIterationCreateArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many InstructionIterations.
     *     @param {InstructionIterationCreateManyArgs} args - Arguments to create many InstructionIterations.
     *     @example
     *     // Create many InstructionIterations
     *     const instructionIteration = await prisma.instructionIteration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InstructionIterationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionIterationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InstructionIteration.
     * @param {InstructionIterationDeleteArgs} args - Arguments to delete one InstructionIteration.
     * @example
     * // Delete one InstructionIteration
     * const InstructionIteration = await prisma.instructionIteration.delete({
     *   where: {
     *     // ... filter to delete one InstructionIteration
     *   }
     * })
     * 
    **/
    delete<T extends InstructionIterationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionIterationDeleteArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one InstructionIteration.
     * @param {InstructionIterationUpdateArgs} args - Arguments to update one InstructionIteration.
     * @example
     * // Update one InstructionIteration
     * const instructionIteration = await prisma.instructionIteration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InstructionIterationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionIterationUpdateArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more InstructionIterations.
     * @param {InstructionIterationDeleteManyArgs} args - Arguments to filter InstructionIterations to delete.
     * @example
     * // Delete a few InstructionIterations
     * const { count } = await prisma.instructionIteration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InstructionIterationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InstructionIterationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstructionIterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionIterationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstructionIterations
     * const instructionIteration = await prisma.instructionIteration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InstructionIterationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionIterationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InstructionIteration.
     * @param {InstructionIterationUpsertArgs} args - Arguments to update or create a InstructionIteration.
     * @example
     * // Update or create a InstructionIteration
     * const instructionIteration = await prisma.instructionIteration.upsert({
     *   create: {
     *     // ... data to create a InstructionIteration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstructionIteration we want to update
     *   }
     * })
    **/
    upsert<T extends InstructionIterationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InstructionIterationUpsertArgs<ExtArgs>>
    ): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of InstructionIterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionIterationCountArgs} args - Arguments to filter InstructionIterations to count.
     * @example
     * // Count the number of InstructionIterations
     * const count = await prisma.instructionIteration.count({
     *   where: {
     *     // ... the filter for the InstructionIterations we want to count
     *   }
     * })
    **/
    count<T extends InstructionIterationCountArgs>(
      args?: Subset<T, InstructionIterationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstructionIterationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstructionIteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionIterationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstructionIterationAggregateArgs>(args: Subset<T, InstructionIterationAggregateArgs>): Prisma.PrismaPromise<GetInstructionIterationAggregateType<T>>

    /**
     * Group by InstructionIteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstructionIterationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstructionIterationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstructionIterationGroupByArgs['orderBy'] }
        : { orderBy?: InstructionIterationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstructionIterationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstructionIterationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstructionIteration model
   */
  readonly fields: InstructionIterationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstructionIteration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstructionIterationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    recipe<T extends IterationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IterationDefaultArgs<ExtArgs>>): Prisma__IterationClient<$Result.GetResult<Prisma.$IterationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    timeAndTemperature<T extends InstructionIteration$timeAndTemperatureArgs<ExtArgs> = {}>(args?: Subset<T, InstructionIteration$timeAndTemperatureArgs<ExtArgs>>): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the InstructionIteration model
   */ 
  interface InstructionIterationFieldRefs {
    readonly description: FieldRef<"InstructionIteration", 'String'>
    readonly step: FieldRef<"InstructionIteration", 'Int'>
    readonly iterationId: FieldRef<"InstructionIteration", 'String'>
  }
    

  // Custom InputTypes

  /**
   * InstructionIteration findUnique
   */
  export type InstructionIterationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * Filter, which InstructionIteration to fetch.
     */
    where: InstructionIterationWhereUniqueInput
  }


  /**
   * InstructionIteration findUniqueOrThrow
   */
  export type InstructionIterationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * Filter, which InstructionIteration to fetch.
     */
    where: InstructionIterationWhereUniqueInput
  }


  /**
   * InstructionIteration findFirst
   */
  export type InstructionIterationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * Filter, which InstructionIteration to fetch.
     */
    where?: InstructionIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructionIterations to fetch.
     */
    orderBy?: InstructionIterationOrderByWithRelationInput | InstructionIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructionIterations.
     */
    cursor?: InstructionIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructionIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructionIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructionIterations.
     */
    distinct?: InstructionIterationScalarFieldEnum | InstructionIterationScalarFieldEnum[]
  }


  /**
   * InstructionIteration findFirstOrThrow
   */
  export type InstructionIterationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * Filter, which InstructionIteration to fetch.
     */
    where?: InstructionIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructionIterations to fetch.
     */
    orderBy?: InstructionIterationOrderByWithRelationInput | InstructionIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstructionIterations.
     */
    cursor?: InstructionIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructionIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructionIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstructionIterations.
     */
    distinct?: InstructionIterationScalarFieldEnum | InstructionIterationScalarFieldEnum[]
  }


  /**
   * InstructionIteration findMany
   */
  export type InstructionIterationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * Filter, which InstructionIterations to fetch.
     */
    where?: InstructionIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstructionIterations to fetch.
     */
    orderBy?: InstructionIterationOrderByWithRelationInput | InstructionIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstructionIterations.
     */
    cursor?: InstructionIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstructionIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstructionIterations.
     */
    skip?: number
    distinct?: InstructionIterationScalarFieldEnum | InstructionIterationScalarFieldEnum[]
  }


  /**
   * InstructionIteration create
   */
  export type InstructionIterationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * The data needed to create a InstructionIteration.
     */
    data: XOR<InstructionIterationCreateInput, InstructionIterationUncheckedCreateInput>
  }


  /**
   * InstructionIteration createMany
   */
  export type InstructionIterationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstructionIterations.
     */
    data: InstructionIterationCreateManyInput | InstructionIterationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * InstructionIteration update
   */
  export type InstructionIterationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * The data needed to update a InstructionIteration.
     */
    data: XOR<InstructionIterationUpdateInput, InstructionIterationUncheckedUpdateInput>
    /**
     * Choose, which InstructionIteration to update.
     */
    where: InstructionIterationWhereUniqueInput
  }


  /**
   * InstructionIteration updateMany
   */
  export type InstructionIterationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstructionIterations.
     */
    data: XOR<InstructionIterationUpdateManyMutationInput, InstructionIterationUncheckedUpdateManyInput>
    /**
     * Filter which InstructionIterations to update
     */
    where?: InstructionIterationWhereInput
  }


  /**
   * InstructionIteration upsert
   */
  export type InstructionIterationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * The filter to search for the InstructionIteration to update in case it exists.
     */
    where: InstructionIterationWhereUniqueInput
    /**
     * In case the InstructionIteration found by the `where` argument doesn't exist, create a new InstructionIteration with this data.
     */
    create: XOR<InstructionIterationCreateInput, InstructionIterationUncheckedCreateInput>
    /**
     * In case the InstructionIteration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstructionIterationUpdateInput, InstructionIterationUncheckedUpdateInput>
  }


  /**
   * InstructionIteration delete
   */
  export type InstructionIterationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
    /**
     * Filter which InstructionIteration to delete.
     */
    where: InstructionIterationWhereUniqueInput
  }


  /**
   * InstructionIteration deleteMany
   */
  export type InstructionIterationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstructionIterations to delete
     */
    where?: InstructionIterationWhereInput
  }


  /**
   * InstructionIteration.timeAndTemperature
   */
  export type InstructionIteration$timeAndTemperatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    where?: TimeAndTemperatureIterationWhereInput
  }


  /**
   * InstructionIteration without action
   */
  export type InstructionIterationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstructionIteration
     */
    select?: InstructionIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InstructionIterationInclude<ExtArgs> | null
  }



  /**
   * Model TimeAndTemperatureIteration
   */

  export type AggregateTimeAndTemperatureIteration = {
    _count: TimeAndTemperatureIterationCountAggregateOutputType | null
    _avg: TimeAndTemperatureIterationAvgAggregateOutputType | null
    _sum: TimeAndTemperatureIterationSumAggregateOutputType | null
    _min: TimeAndTemperatureIterationMinAggregateOutputType | null
    _max: TimeAndTemperatureIterationMaxAggregateOutputType | null
  }

  export type TimeAndTemperatureIterationAvgAggregateOutputType = {
    instructionStep: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
  }

  export type TimeAndTemperatureIterationSumAggregateOutputType = {
    instructionStep: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
  }

  export type TimeAndTemperatureIterationMinAggregateOutputType = {
    iterationId: string | null
    instructionStep: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
    unit: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationMaxAggregateOutputType = {
    iterationId: string | null
    instructionStep: number | null
    hours: number | null
    minutes: number | null
    temperature: number | null
    unit: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationCountAggregateOutputType = {
    iterationId: number
    instructionStep: number
    hours: number
    minutes: number
    temperature: number
    unit: number
    _all: number
  }


  export type TimeAndTemperatureIterationAvgAggregateInputType = {
    instructionStep?: true
    hours?: true
    minutes?: true
    temperature?: true
  }

  export type TimeAndTemperatureIterationSumAggregateInputType = {
    instructionStep?: true
    hours?: true
    minutes?: true
    temperature?: true
  }

  export type TimeAndTemperatureIterationMinAggregateInputType = {
    iterationId?: true
    instructionStep?: true
    hours?: true
    minutes?: true
    temperature?: true
    unit?: true
  }

  export type TimeAndTemperatureIterationMaxAggregateInputType = {
    iterationId?: true
    instructionStep?: true
    hours?: true
    minutes?: true
    temperature?: true
    unit?: true
  }

  export type TimeAndTemperatureIterationCountAggregateInputType = {
    iterationId?: true
    instructionStep?: true
    hours?: true
    minutes?: true
    temperature?: true
    unit?: true
    _all?: true
  }

  export type TimeAndTemperatureIterationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeAndTemperatureIteration to aggregate.
     */
    where?: TimeAndTemperatureIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatureIterations to fetch.
     */
    orderBy?: TimeAndTemperatureIterationOrderByWithRelationInput | TimeAndTemperatureIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeAndTemperatureIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatureIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatureIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeAndTemperatureIterations
    **/
    _count?: true | TimeAndTemperatureIterationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeAndTemperatureIterationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeAndTemperatureIterationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeAndTemperatureIterationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeAndTemperatureIterationMaxAggregateInputType
  }

  export type GetTimeAndTemperatureIterationAggregateType<T extends TimeAndTemperatureIterationAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeAndTemperatureIteration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeAndTemperatureIteration[P]>
      : GetScalarType<T[P], AggregateTimeAndTemperatureIteration[P]>
  }




  export type TimeAndTemperatureIterationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeAndTemperatureIterationWhereInput
    orderBy?: TimeAndTemperatureIterationOrderByWithAggregationInput | TimeAndTemperatureIterationOrderByWithAggregationInput[]
    by: TimeAndTemperatureIterationScalarFieldEnum[] | TimeAndTemperatureIterationScalarFieldEnum
    having?: TimeAndTemperatureIterationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeAndTemperatureIterationCountAggregateInputType | true
    _avg?: TimeAndTemperatureIterationAvgAggregateInputType
    _sum?: TimeAndTemperatureIterationSumAggregateInputType
    _min?: TimeAndTemperatureIterationMinAggregateInputType
    _max?: TimeAndTemperatureIterationMaxAggregateInputType
  }

  export type TimeAndTemperatureIterationGroupByOutputType = {
    iterationId: string
    instructionStep: number
    hours: number | null
    minutes: number | null
    temperature: number
    unit: $Enums.TemperatureUnit | null
    _count: TimeAndTemperatureIterationCountAggregateOutputType | null
    _avg: TimeAndTemperatureIterationAvgAggregateOutputType | null
    _sum: TimeAndTemperatureIterationSumAggregateOutputType | null
    _min: TimeAndTemperatureIterationMinAggregateOutputType | null
    _max: TimeAndTemperatureIterationMaxAggregateOutputType | null
  }

  type GetTimeAndTemperatureIterationGroupByPayload<T extends TimeAndTemperatureIterationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeAndTemperatureIterationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeAndTemperatureIterationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeAndTemperatureIterationGroupByOutputType[P]>
            : GetScalarType<T[P], TimeAndTemperatureIterationGroupByOutputType[P]>
        }
      >
    >


  export type TimeAndTemperatureIterationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    iterationId?: boolean
    instructionStep?: boolean
    hours?: boolean
    minutes?: boolean
    temperature?: boolean
    unit?: boolean
    instruction?: boolean | InstructionIterationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["timeAndTemperatureIteration"]>

  export type TimeAndTemperatureIterationSelectScalar = {
    iterationId?: boolean
    instructionStep?: boolean
    hours?: boolean
    minutes?: boolean
    temperature?: boolean
    unit?: boolean
  }

  export type TimeAndTemperatureIterationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instruction?: boolean | InstructionIterationDefaultArgs<ExtArgs>
  }


  export type $TimeAndTemperatureIterationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeAndTemperatureIteration"
    objects: {
      instruction: Prisma.$InstructionIterationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      iterationId: string
      instructionStep: number
      hours: number | null
      minutes: number | null
      temperature: number
      unit: $Enums.TemperatureUnit | null
    }, ExtArgs["result"]["timeAndTemperatureIteration"]>
    composites: {}
  }


  type TimeAndTemperatureIterationGetPayload<S extends boolean | null | undefined | TimeAndTemperatureIterationDefaultArgs> = $Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload, S>

  type TimeAndTemperatureIterationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeAndTemperatureIterationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeAndTemperatureIterationCountAggregateInputType | true
    }

  export interface TimeAndTemperatureIterationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeAndTemperatureIteration'], meta: { name: 'TimeAndTemperatureIteration' } }
    /**
     * Find zero or one TimeAndTemperatureIteration that matches the filter.
     * @param {TimeAndTemperatureIterationFindUniqueArgs} args - Arguments to find a TimeAndTemperatureIteration
     * @example
     * // Get one TimeAndTemperatureIteration
     * const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TimeAndTemperatureIterationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureIterationFindUniqueArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TimeAndTemperatureIteration that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {TimeAndTemperatureIterationFindUniqueOrThrowArgs} args - Arguments to find a TimeAndTemperatureIteration
     * @example
     * // Get one TimeAndTemperatureIteration
     * const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TimeAndTemperatureIterationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureIterationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TimeAndTemperatureIteration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureIterationFindFirstArgs} args - Arguments to find a TimeAndTemperatureIteration
     * @example
     * // Get one TimeAndTemperatureIteration
     * const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TimeAndTemperatureIterationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureIterationFindFirstArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TimeAndTemperatureIteration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureIterationFindFirstOrThrowArgs} args - Arguments to find a TimeAndTemperatureIteration
     * @example
     * // Get one TimeAndTemperatureIteration
     * const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TimeAndTemperatureIterationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureIterationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TimeAndTemperatureIterations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureIterationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeAndTemperatureIterations
     * const timeAndTemperatureIterations = await prisma.timeAndTemperatureIteration.findMany()
     * 
     * // Get first 10 TimeAndTemperatureIterations
     * const timeAndTemperatureIterations = await prisma.timeAndTemperatureIteration.findMany({ take: 10 })
     * 
     * // Only select the `iterationId`
     * const timeAndTemperatureIterationWithIterationIdOnly = await prisma.timeAndTemperatureIteration.findMany({ select: { iterationId: true } })
     * 
    **/
    findMany<T extends TimeAndTemperatureIterationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureIterationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TimeAndTemperatureIteration.
     * @param {TimeAndTemperatureIterationCreateArgs} args - Arguments to create a TimeAndTemperatureIteration.
     * @example
     * // Create one TimeAndTemperatureIteration
     * const TimeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.create({
     *   data: {
     *     // ... data to create a TimeAndTemperatureIteration
     *   }
     * })
     * 
    **/
    create<T extends TimeAndTemperatureIterationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureIterationCreateArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TimeAndTemperatureIterations.
     *     @param {TimeAndTemperatureIterationCreateManyArgs} args - Arguments to create many TimeAndTemperatureIterations.
     *     @example
     *     // Create many TimeAndTemperatureIterations
     *     const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TimeAndTemperatureIterationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureIterationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TimeAndTemperatureIteration.
     * @param {TimeAndTemperatureIterationDeleteArgs} args - Arguments to delete one TimeAndTemperatureIteration.
     * @example
     * // Delete one TimeAndTemperatureIteration
     * const TimeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.delete({
     *   where: {
     *     // ... filter to delete one TimeAndTemperatureIteration
     *   }
     * })
     * 
    **/
    delete<T extends TimeAndTemperatureIterationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureIterationDeleteArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TimeAndTemperatureIteration.
     * @param {TimeAndTemperatureIterationUpdateArgs} args - Arguments to update one TimeAndTemperatureIteration.
     * @example
     * // Update one TimeAndTemperatureIteration
     * const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TimeAndTemperatureIterationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureIterationUpdateArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TimeAndTemperatureIterations.
     * @param {TimeAndTemperatureIterationDeleteManyArgs} args - Arguments to filter TimeAndTemperatureIterations to delete.
     * @example
     * // Delete a few TimeAndTemperatureIterations
     * const { count } = await prisma.timeAndTemperatureIteration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TimeAndTemperatureIterationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TimeAndTemperatureIterationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeAndTemperatureIterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureIterationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeAndTemperatureIterations
     * const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TimeAndTemperatureIterationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureIterationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeAndTemperatureIteration.
     * @param {TimeAndTemperatureIterationUpsertArgs} args - Arguments to update or create a TimeAndTemperatureIteration.
     * @example
     * // Update or create a TimeAndTemperatureIteration
     * const timeAndTemperatureIteration = await prisma.timeAndTemperatureIteration.upsert({
     *   create: {
     *     // ... data to create a TimeAndTemperatureIteration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeAndTemperatureIteration we want to update
     *   }
     * })
    **/
    upsert<T extends TimeAndTemperatureIterationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TimeAndTemperatureIterationUpsertArgs<ExtArgs>>
    ): Prisma__TimeAndTemperatureIterationClient<$Result.GetResult<Prisma.$TimeAndTemperatureIterationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TimeAndTemperatureIterations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureIterationCountArgs} args - Arguments to filter TimeAndTemperatureIterations to count.
     * @example
     * // Count the number of TimeAndTemperatureIterations
     * const count = await prisma.timeAndTemperatureIteration.count({
     *   where: {
     *     // ... the filter for the TimeAndTemperatureIterations we want to count
     *   }
     * })
    **/
    count<T extends TimeAndTemperatureIterationCountArgs>(
      args?: Subset<T, TimeAndTemperatureIterationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeAndTemperatureIterationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeAndTemperatureIteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureIterationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeAndTemperatureIterationAggregateArgs>(args: Subset<T, TimeAndTemperatureIterationAggregateArgs>): Prisma.PrismaPromise<GetTimeAndTemperatureIterationAggregateType<T>>

    /**
     * Group by TimeAndTemperatureIteration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeAndTemperatureIterationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeAndTemperatureIterationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeAndTemperatureIterationGroupByArgs['orderBy'] }
        : { orderBy?: TimeAndTemperatureIterationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeAndTemperatureIterationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeAndTemperatureIterationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeAndTemperatureIteration model
   */
  readonly fields: TimeAndTemperatureIterationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeAndTemperatureIteration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeAndTemperatureIterationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    instruction<T extends InstructionIterationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstructionIterationDefaultArgs<ExtArgs>>): Prisma__InstructionIterationClient<$Result.GetResult<Prisma.$InstructionIterationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TimeAndTemperatureIteration model
   */ 
  interface TimeAndTemperatureIterationFieldRefs {
    readonly iterationId: FieldRef<"TimeAndTemperatureIteration", 'String'>
    readonly instructionStep: FieldRef<"TimeAndTemperatureIteration", 'Int'>
    readonly hours: FieldRef<"TimeAndTemperatureIteration", 'Int'>
    readonly minutes: FieldRef<"TimeAndTemperatureIteration", 'Int'>
    readonly temperature: FieldRef<"TimeAndTemperatureIteration", 'Int'>
    readonly unit: FieldRef<"TimeAndTemperatureIteration", 'TemperatureUnit'>
  }
    

  // Custom InputTypes

  /**
   * TimeAndTemperatureIteration findUnique
   */
  export type TimeAndTemperatureIterationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperatureIteration to fetch.
     */
    where: TimeAndTemperatureIterationWhereUniqueInput
  }


  /**
   * TimeAndTemperatureIteration findUniqueOrThrow
   */
  export type TimeAndTemperatureIterationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperatureIteration to fetch.
     */
    where: TimeAndTemperatureIterationWhereUniqueInput
  }


  /**
   * TimeAndTemperatureIteration findFirst
   */
  export type TimeAndTemperatureIterationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperatureIteration to fetch.
     */
    where?: TimeAndTemperatureIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatureIterations to fetch.
     */
    orderBy?: TimeAndTemperatureIterationOrderByWithRelationInput | TimeAndTemperatureIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeAndTemperatureIterations.
     */
    cursor?: TimeAndTemperatureIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatureIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatureIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeAndTemperatureIterations.
     */
    distinct?: TimeAndTemperatureIterationScalarFieldEnum | TimeAndTemperatureIterationScalarFieldEnum[]
  }


  /**
   * TimeAndTemperatureIteration findFirstOrThrow
   */
  export type TimeAndTemperatureIterationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperatureIteration to fetch.
     */
    where?: TimeAndTemperatureIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatureIterations to fetch.
     */
    orderBy?: TimeAndTemperatureIterationOrderByWithRelationInput | TimeAndTemperatureIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeAndTemperatureIterations.
     */
    cursor?: TimeAndTemperatureIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatureIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatureIterations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeAndTemperatureIterations.
     */
    distinct?: TimeAndTemperatureIterationScalarFieldEnum | TimeAndTemperatureIterationScalarFieldEnum[]
  }


  /**
   * TimeAndTemperatureIteration findMany
   */
  export type TimeAndTemperatureIterationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * Filter, which TimeAndTemperatureIterations to fetch.
     */
    where?: TimeAndTemperatureIterationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeAndTemperatureIterations to fetch.
     */
    orderBy?: TimeAndTemperatureIterationOrderByWithRelationInput | TimeAndTemperatureIterationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeAndTemperatureIterations.
     */
    cursor?: TimeAndTemperatureIterationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeAndTemperatureIterations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeAndTemperatureIterations.
     */
    skip?: number
    distinct?: TimeAndTemperatureIterationScalarFieldEnum | TimeAndTemperatureIterationScalarFieldEnum[]
  }


  /**
   * TimeAndTemperatureIteration create
   */
  export type TimeAndTemperatureIterationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeAndTemperatureIteration.
     */
    data: XOR<TimeAndTemperatureIterationCreateInput, TimeAndTemperatureIterationUncheckedCreateInput>
  }


  /**
   * TimeAndTemperatureIteration createMany
   */
  export type TimeAndTemperatureIterationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeAndTemperatureIterations.
     */
    data: TimeAndTemperatureIterationCreateManyInput | TimeAndTemperatureIterationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * TimeAndTemperatureIteration update
   */
  export type TimeAndTemperatureIterationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeAndTemperatureIteration.
     */
    data: XOR<TimeAndTemperatureIterationUpdateInput, TimeAndTemperatureIterationUncheckedUpdateInput>
    /**
     * Choose, which TimeAndTemperatureIteration to update.
     */
    where: TimeAndTemperatureIterationWhereUniqueInput
  }


  /**
   * TimeAndTemperatureIteration updateMany
   */
  export type TimeAndTemperatureIterationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeAndTemperatureIterations.
     */
    data: XOR<TimeAndTemperatureIterationUpdateManyMutationInput, TimeAndTemperatureIterationUncheckedUpdateManyInput>
    /**
     * Filter which TimeAndTemperatureIterations to update
     */
    where?: TimeAndTemperatureIterationWhereInput
  }


  /**
   * TimeAndTemperatureIteration upsert
   */
  export type TimeAndTemperatureIterationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeAndTemperatureIteration to update in case it exists.
     */
    where: TimeAndTemperatureIterationWhereUniqueInput
    /**
     * In case the TimeAndTemperatureIteration found by the `where` argument doesn't exist, create a new TimeAndTemperatureIteration with this data.
     */
    create: XOR<TimeAndTemperatureIterationCreateInput, TimeAndTemperatureIterationUncheckedCreateInput>
    /**
     * In case the TimeAndTemperatureIteration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeAndTemperatureIterationUpdateInput, TimeAndTemperatureIterationUncheckedUpdateInput>
  }


  /**
   * TimeAndTemperatureIteration delete
   */
  export type TimeAndTemperatureIterationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
    /**
     * Filter which TimeAndTemperatureIteration to delete.
     */
    where: TimeAndTemperatureIterationWhereUniqueInput
  }


  /**
   * TimeAndTemperatureIteration deleteMany
   */
  export type TimeAndTemperatureIterationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeAndTemperatureIterations to delete
     */
    where?: TimeAndTemperatureIterationWhereInput
  }


  /**
   * TimeAndTemperatureIteration without action
   */
  export type TimeAndTemperatureIterationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeAndTemperatureIteration
     */
    select?: TimeAndTemperatureIterationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: TimeAndTemperatureIterationInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    password: 'password',
    salt: 'salt',
    image: 'image'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    createdOn: 'createdOn',
    updatedAt: 'updatedAt',
    title: 'title',
    authorId: 'authorId',
    image: 'image',
    description: 'description',
    public: 'public'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const IngredientScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type IngredientScalarFieldEnum = (typeof IngredientScalarFieldEnum)[keyof typeof IngredientScalarFieldEnum]


  export const ConnectionScalarFieldEnum: {
    connectedWithId: 'connectedWithId',
    connectedById: 'connectedById',
    accepted: 'accepted'
  };

  export type ConnectionScalarFieldEnum = (typeof ConnectionScalarFieldEnum)[keyof typeof ConnectionScalarFieldEnum]


  export const TagScalarFieldEnum: {
    recipeId: 'recipeId',
    name: 'name'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const RecipeEditorsScalarFieldEnum: {
    recipeId: 'recipeId',
    userId: 'userId'
  };

  export type RecipeEditorsScalarFieldEnum = (typeof RecipeEditorsScalarFieldEnum)[keyof typeof RecipeEditorsScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    recipeId: 'recipeId',
    userId: 'userId',
    value: 'value'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    recipeId: 'recipeId',
    userId: 'userId',
    text: 'text',
    createdOn: 'createdOn'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const InstructionScalarFieldEnum: {
    description: 'description',
    recipeId: 'recipeId',
    step: 'step'
  };

  export type InstructionScalarFieldEnum = (typeof InstructionScalarFieldEnum)[keyof typeof InstructionScalarFieldEnum]


  export const TimeAndTemperatureScalarFieldEnum: {
    recipeId: 'recipeId',
    step: 'step',
    hours: 'hours',
    minutes: 'minutes',
    temperature: 'temperature',
    unit: 'unit'
  };

  export type TimeAndTemperatureScalarFieldEnum = (typeof TimeAndTemperatureScalarFieldEnum)[keyof typeof TimeAndTemperatureScalarFieldEnum]


  export const RecipeIngredientScalarFieldEnum: {
    recipeId: 'recipeId',
    ingredientId: 'ingredientId',
    quantity: 'quantity',
    unit: 'unit'
  };

  export type RecipeIngredientScalarFieldEnum = (typeof RecipeIngredientScalarFieldEnum)[keyof typeof RecipeIngredientScalarFieldEnum]


  export const ComponentScalarFieldEnum: {
    recipeId: 'recipeId',
    componentId: 'componentId',
    amount: 'amount'
  };

  export type ComponentScalarFieldEnum = (typeof ComponentScalarFieldEnum)[keyof typeof ComponentScalarFieldEnum]


  export const IterationScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    createdOn: 'createdOn',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    tag: 'tag'
  };

  export type IterationScalarFieldEnum = (typeof IterationScalarFieldEnum)[keyof typeof IterationScalarFieldEnum]


  export const IngredientIterationScalarFieldEnum: {
    ingredientId: 'ingredientId',
    quantity: 'quantity',
    iterationId: 'iterationId',
    unit: 'unit'
  };

  export type IngredientIterationScalarFieldEnum = (typeof IngredientIterationScalarFieldEnum)[keyof typeof IngredientIterationScalarFieldEnum]


  export const InstructionIterationScalarFieldEnum: {
    description: 'description',
    step: 'step',
    iterationId: 'iterationId'
  };

  export type InstructionIterationScalarFieldEnum = (typeof InstructionIterationScalarFieldEnum)[keyof typeof InstructionIterationScalarFieldEnum]


  export const TimeAndTemperatureIterationScalarFieldEnum: {
    iterationId: 'iterationId',
    instructionStep: 'instructionStep',
    hours: 'hours',
    minutes: 'minutes',
    temperature: 'temperature',
    unit: 'unit'
  };

  export type TimeAndTemperatureIterationScalarFieldEnum = (typeof TimeAndTemperatureIterationScalarFieldEnum)[keyof typeof TimeAndTemperatureIterationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TemperatureUnit'
   */
  export type EnumTemperatureUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemperatureUnit'>
    


  /**
   * Reference to a field of type 'TemperatureUnit[]'
   */
  export type ListEnumTemperatureUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TemperatureUnit[]'>
    


  /**
   * Reference to a field of type 'IngredientUnit'
   */
  export type EnumIngredientUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IngredientUnit'>
    


  /**
   * Reference to a field of type 'IngredientUnit[]'
   */
  export type ListEnumIngredientUnitFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IngredientUnit[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    salt?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    connectedWith?: ConnectionListRelationFilter
    connectedBy?: ConnectionListRelationFilter
    ratings?: RatingListRelationFilter
    recipes?: RecipeListRelationFilter
    recipeEditors?: RecipeEditorsListRelationFilter
    reviews?: ReviewListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    image?: SortOrderInput | SortOrder
    connectedWith?: ConnectionOrderByRelationAggregateInput
    connectedBy?: ConnectionOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    recipes?: RecipeOrderByRelationAggregateInput
    recipeEditors?: RecipeEditorsOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    salt?: StringFilter<"User"> | string
    image?: StringNullableFilter<"User"> | string | null
    connectedWith?: ConnectionListRelationFilter
    connectedBy?: ConnectionListRelationFilter
    ratings?: RatingListRelationFilter
    recipes?: RecipeListRelationFilter
    recipeEditors?: RecipeEditorsListRelationFilter
    reviews?: ReviewListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    image?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    salt?: StringWithAggregatesFilter<"User"> | string
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: StringFilter<"Recipe"> | string
    createdOn?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    title?: StringFilter<"Recipe"> | string
    authorId?: StringFilter<"Recipe"> | string
    image?: StringNullableFilter<"Recipe"> | string | null
    description?: StringNullableFilter<"Recipe"> | string | null
    public?: BoolNullableFilter<"Recipe"> | boolean | null
    parentRecipes?: ComponentListRelationFilter
    components?: ComponentListRelationFilter
    instructions?: InstructionListRelationFilter
    iterations?: IterationListRelationFilter
    ratings?: RatingListRelationFilter
    author?: XOR<UserRelationFilter, UserWhereInput>
    editors?: RecipeEditorsListRelationFilter
    ingredients?: RecipeIngredientListRelationFilter
    reviews?: ReviewListRelationFilter
    tags?: TagListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    createdOn?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    title?: SortOrder
    authorId?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    public?: SortOrderInput | SortOrder
    parentRecipes?: ComponentOrderByRelationAggregateInput
    components?: ComponentOrderByRelationAggregateInput
    instructions?: InstructionOrderByRelationAggregateInput
    iterations?: IterationOrderByRelationAggregateInput
    ratings?: RatingOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
    editors?: RecipeEditorsOrderByRelationAggregateInput
    ingredients?: RecipeIngredientOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    tags?: TagOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    createdOn?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    title?: StringFilter<"Recipe"> | string
    authorId?: StringFilter<"Recipe"> | string
    image?: StringNullableFilter<"Recipe"> | string | null
    description?: StringNullableFilter<"Recipe"> | string | null
    public?: BoolNullableFilter<"Recipe"> | boolean | null
    parentRecipes?: ComponentListRelationFilter
    components?: ComponentListRelationFilter
    instructions?: InstructionListRelationFilter
    iterations?: IterationListRelationFilter
    ratings?: RatingListRelationFilter
    author?: XOR<UserRelationFilter, UserWhereInput>
    editors?: RecipeEditorsListRelationFilter
    ingredients?: RecipeIngredientListRelationFilter
    reviews?: ReviewListRelationFilter
    tags?: TagListRelationFilter
  }, "id">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    createdOn?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    title?: SortOrder
    authorId?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    public?: SortOrderInput | SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Recipe"> | string
    createdOn?: DateTimeNullableWithAggregatesFilter<"Recipe"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Recipe"> | Date | string | null
    title?: StringWithAggregatesFilter<"Recipe"> | string
    authorId?: StringWithAggregatesFilter<"Recipe"> | string
    image?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    description?: StringNullableWithAggregatesFilter<"Recipe"> | string | null
    public?: BoolNullableWithAggregatesFilter<"Recipe"> | boolean | null
  }

  export type IngredientWhereInput = {
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    id?: StringFilter<"Ingredient"> | string
    name?: StringFilter<"Ingredient"> | string
    iterations?: IngredientIterationListRelationFilter
    recipes?: RecipeIngredientListRelationFilter
  }

  export type IngredientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    iterations?: IngredientIterationOrderByRelationAggregateInput
    recipes?: RecipeIngredientOrderByRelationAggregateInput
  }

  export type IngredientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: IngredientWhereInput | IngredientWhereInput[]
    OR?: IngredientWhereInput[]
    NOT?: IngredientWhereInput | IngredientWhereInput[]
    iterations?: IngredientIterationListRelationFilter
    recipes?: RecipeIngredientListRelationFilter
  }, "id" | "name">

  export type IngredientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: IngredientCountOrderByAggregateInput
    _max?: IngredientMaxOrderByAggregateInput
    _min?: IngredientMinOrderByAggregateInput
  }

  export type IngredientScalarWhereWithAggregatesInput = {
    AND?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    OR?: IngredientScalarWhereWithAggregatesInput[]
    NOT?: IngredientScalarWhereWithAggregatesInput | IngredientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ingredient"> | string
    name?: StringWithAggregatesFilter<"Ingredient"> | string
  }

  export type ConnectionWhereInput = {
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    connectedWithId?: StringFilter<"Connection"> | string
    connectedById?: StringFilter<"Connection"> | string
    accepted?: BoolFilter<"Connection"> | boolean
    connectedBy?: XOR<UserRelationFilter, UserWhereInput>
    connectedWith?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ConnectionOrderByWithRelationInput = {
    connectedWithId?: SortOrder
    connectedById?: SortOrder
    accepted?: SortOrder
    connectedBy?: UserOrderByWithRelationInput
    connectedWith?: UserOrderByWithRelationInput
  }

  export type ConnectionWhereUniqueInput = Prisma.AtLeast<{
    ConnectionId?: ConnectionConnectionIdCompoundUniqueInput
    AND?: ConnectionWhereInput | ConnectionWhereInput[]
    OR?: ConnectionWhereInput[]
    NOT?: ConnectionWhereInput | ConnectionWhereInput[]
    connectedWithId?: StringFilter<"Connection"> | string
    connectedById?: StringFilter<"Connection"> | string
    accepted?: BoolFilter<"Connection"> | boolean
    connectedBy?: XOR<UserRelationFilter, UserWhereInput>
    connectedWith?: XOR<UserRelationFilter, UserWhereInput>
  }, "ConnectionId">

  export type ConnectionOrderByWithAggregationInput = {
    connectedWithId?: SortOrder
    connectedById?: SortOrder
    accepted?: SortOrder
    _count?: ConnectionCountOrderByAggregateInput
    _max?: ConnectionMaxOrderByAggregateInput
    _min?: ConnectionMinOrderByAggregateInput
  }

  export type ConnectionScalarWhereWithAggregatesInput = {
    AND?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    OR?: ConnectionScalarWhereWithAggregatesInput[]
    NOT?: ConnectionScalarWhereWithAggregatesInput | ConnectionScalarWhereWithAggregatesInput[]
    connectedWithId?: StringWithAggregatesFilter<"Connection"> | string
    connectedById?: StringWithAggregatesFilter<"Connection"> | string
    accepted?: BoolWithAggregatesFilter<"Connection"> | boolean
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    recipeId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }

  export type TagOrderByWithRelationInput = {
    recipeId?: SortOrder
    name?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    recipeId_name?: TagRecipeIdNameCompoundUniqueInput
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    recipeId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }, "recipeId_name">

  export type TagOrderByWithAggregationInput = {
    recipeId?: SortOrder
    name?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    recipeId?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type RecipeEditorsWhereInput = {
    AND?: RecipeEditorsWhereInput | RecipeEditorsWhereInput[]
    OR?: RecipeEditorsWhereInput[]
    NOT?: RecipeEditorsWhereInput | RecipeEditorsWhereInput[]
    recipeId?: StringFilter<"RecipeEditors"> | string
    userId?: StringFilter<"RecipeEditors"> | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RecipeEditorsOrderByWithRelationInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RecipeEditorsWhereUniqueInput = Prisma.AtLeast<{
    EditorId?: RecipeEditorsEditorIdCompoundUniqueInput
    AND?: RecipeEditorsWhereInput | RecipeEditorsWhereInput[]
    OR?: RecipeEditorsWhereInput[]
    NOT?: RecipeEditorsWhereInput | RecipeEditorsWhereInput[]
    recipeId?: StringFilter<"RecipeEditors"> | string
    userId?: StringFilter<"RecipeEditors"> | string
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "EditorId">

  export type RecipeEditorsOrderByWithAggregationInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    _count?: RecipeEditorsCountOrderByAggregateInput
    _max?: RecipeEditorsMaxOrderByAggregateInput
    _min?: RecipeEditorsMinOrderByAggregateInput
  }

  export type RecipeEditorsScalarWhereWithAggregatesInput = {
    AND?: RecipeEditorsScalarWhereWithAggregatesInput | RecipeEditorsScalarWhereWithAggregatesInput[]
    OR?: RecipeEditorsScalarWhereWithAggregatesInput[]
    NOT?: RecipeEditorsScalarWhereWithAggregatesInput | RecipeEditorsScalarWhereWithAggregatesInput[]
    recipeId?: StringWithAggregatesFilter<"RecipeEditors"> | string
    userId?: StringWithAggregatesFilter<"RecipeEditors"> | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    recipeId?: StringFilter<"Rating"> | string
    userId?: StringFilter<"Rating"> | string
    value?: IntFilter<"Rating"> | number
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = Prisma.AtLeast<{
    RatingId?: RatingRatingIdCompoundUniqueInput
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    recipeId?: StringFilter<"Rating"> | string
    userId?: StringFilter<"Rating"> | string
    value?: IntFilter<"Rating"> | number
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "RatingId">

  export type RatingOrderByWithAggregationInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    recipeId?: StringWithAggregatesFilter<"Rating"> | string
    userId?: StringWithAggregatesFilter<"Rating"> | string
    value?: IntWithAggregatesFilter<"Rating"> | number
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    recipeId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    text?: StringFilter<"Review"> | string
    createdOn?: DateTimeNullableFilter<"Review"> | Date | string | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdOn?: SortOrderInput | SortOrder
    recipe?: RecipeOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    ReviewId?: ReviewReviewIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    recipeId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    text?: StringFilter<"Review"> | string
    createdOn?: DateTimeNullableFilter<"Review"> | Date | string | null
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "ReviewId">

  export type ReviewOrderByWithAggregationInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdOn?: SortOrderInput | SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    recipeId?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    text?: StringWithAggregatesFilter<"Review"> | string
    createdOn?: DateTimeNullableWithAggregatesFilter<"Review"> | Date | string | null
  }

  export type InstructionWhereInput = {
    AND?: InstructionWhereInput | InstructionWhereInput[]
    OR?: InstructionWhereInput[]
    NOT?: InstructionWhereInput | InstructionWhereInput[]
    description?: StringFilter<"Instruction"> | string
    recipeId?: StringFilter<"Instruction"> | string
    step?: IntFilter<"Instruction"> | number
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    timeAndTemperature?: XOR<TimeAndTemperatureNullableRelationFilter, TimeAndTemperatureWhereInput> | null
  }

  export type InstructionOrderByWithRelationInput = {
    description?: SortOrder
    recipeId?: SortOrder
    step?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    timeAndTemperature?: TimeAndTemperatureOrderByWithRelationInput
  }

  export type InstructionWhereUniqueInput = Prisma.AtLeast<{
    InstructionId?: InstructionInstructionIdCompoundUniqueInput
    AND?: InstructionWhereInput | InstructionWhereInput[]
    OR?: InstructionWhereInput[]
    NOT?: InstructionWhereInput | InstructionWhereInput[]
    description?: StringFilter<"Instruction"> | string
    recipeId?: StringFilter<"Instruction"> | string
    step?: IntFilter<"Instruction"> | number
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    timeAndTemperature?: XOR<TimeAndTemperatureNullableRelationFilter, TimeAndTemperatureWhereInput> | null
  }, "InstructionId">

  export type InstructionOrderByWithAggregationInput = {
    description?: SortOrder
    recipeId?: SortOrder
    step?: SortOrder
    _count?: InstructionCountOrderByAggregateInput
    _avg?: InstructionAvgOrderByAggregateInput
    _max?: InstructionMaxOrderByAggregateInput
    _min?: InstructionMinOrderByAggregateInput
    _sum?: InstructionSumOrderByAggregateInput
  }

  export type InstructionScalarWhereWithAggregatesInput = {
    AND?: InstructionScalarWhereWithAggregatesInput | InstructionScalarWhereWithAggregatesInput[]
    OR?: InstructionScalarWhereWithAggregatesInput[]
    NOT?: InstructionScalarWhereWithAggregatesInput | InstructionScalarWhereWithAggregatesInput[]
    description?: StringWithAggregatesFilter<"Instruction"> | string
    recipeId?: StringWithAggregatesFilter<"Instruction"> | string
    step?: IntWithAggregatesFilter<"Instruction"> | number
  }

  export type TimeAndTemperatureWhereInput = {
    AND?: TimeAndTemperatureWhereInput | TimeAndTemperatureWhereInput[]
    OR?: TimeAndTemperatureWhereInput[]
    NOT?: TimeAndTemperatureWhereInput | TimeAndTemperatureWhereInput[]
    recipeId?: StringFilter<"TimeAndTemperature"> | string
    step?: IntFilter<"TimeAndTemperature"> | number
    hours?: IntNullableFilter<"TimeAndTemperature"> | number | null
    minutes?: IntNullableFilter<"TimeAndTemperature"> | number | null
    temperature?: IntFilter<"TimeAndTemperature"> | number
    unit?: EnumTemperatureUnitNullableFilter<"TimeAndTemperature"> | $Enums.TemperatureUnit | null
    instruction?: XOR<InstructionRelationFilter, InstructionWhereInput>
  }

  export type TimeAndTemperatureOrderByWithRelationInput = {
    recipeId?: SortOrder
    step?: SortOrder
    hours?: SortOrderInput | SortOrder
    minutes?: SortOrderInput | SortOrder
    temperature?: SortOrder
    unit?: SortOrderInput | SortOrder
    instruction?: InstructionOrderByWithRelationInput
  }

  export type TimeAndTemperatureWhereUniqueInput = Prisma.AtLeast<{
    recipeId_step?: TimeAndTemperatureRecipeIdStepCompoundUniqueInput
    AND?: TimeAndTemperatureWhereInput | TimeAndTemperatureWhereInput[]
    OR?: TimeAndTemperatureWhereInput[]
    NOT?: TimeAndTemperatureWhereInput | TimeAndTemperatureWhereInput[]
    recipeId?: StringFilter<"TimeAndTemperature"> | string
    step?: IntFilter<"TimeAndTemperature"> | number
    hours?: IntNullableFilter<"TimeAndTemperature"> | number | null
    minutes?: IntNullableFilter<"TimeAndTemperature"> | number | null
    temperature?: IntFilter<"TimeAndTemperature"> | number
    unit?: EnumTemperatureUnitNullableFilter<"TimeAndTemperature"> | $Enums.TemperatureUnit | null
    instruction?: XOR<InstructionRelationFilter, InstructionWhereInput>
  }, "recipeId_step">

  export type TimeAndTemperatureOrderByWithAggregationInput = {
    recipeId?: SortOrder
    step?: SortOrder
    hours?: SortOrderInput | SortOrder
    minutes?: SortOrderInput | SortOrder
    temperature?: SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: TimeAndTemperatureCountOrderByAggregateInput
    _avg?: TimeAndTemperatureAvgOrderByAggregateInput
    _max?: TimeAndTemperatureMaxOrderByAggregateInput
    _min?: TimeAndTemperatureMinOrderByAggregateInput
    _sum?: TimeAndTemperatureSumOrderByAggregateInput
  }

  export type TimeAndTemperatureScalarWhereWithAggregatesInput = {
    AND?: TimeAndTemperatureScalarWhereWithAggregatesInput | TimeAndTemperatureScalarWhereWithAggregatesInput[]
    OR?: TimeAndTemperatureScalarWhereWithAggregatesInput[]
    NOT?: TimeAndTemperatureScalarWhereWithAggregatesInput | TimeAndTemperatureScalarWhereWithAggregatesInput[]
    recipeId?: StringWithAggregatesFilter<"TimeAndTemperature"> | string
    step?: IntWithAggregatesFilter<"TimeAndTemperature"> | number
    hours?: IntNullableWithAggregatesFilter<"TimeAndTemperature"> | number | null
    minutes?: IntNullableWithAggregatesFilter<"TimeAndTemperature"> | number | null
    temperature?: IntWithAggregatesFilter<"TimeAndTemperature"> | number
    unit?: EnumTemperatureUnitNullableWithAggregatesFilter<"TimeAndTemperature"> | $Enums.TemperatureUnit | null
  }

  export type RecipeIngredientWhereInput = {
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    recipeId?: StringFilter<"RecipeIngredient"> | string
    ingredientId?: StringFilter<"RecipeIngredient"> | string
    quantity?: IntFilter<"RecipeIngredient"> | number
    unit?: EnumIngredientUnitNullableFilter<"RecipeIngredient"> | $Enums.IngredientUnit | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }

  export type RecipeIngredientOrderByWithRelationInput = {
    recipeId?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type RecipeIngredientWhereUniqueInput = Prisma.AtLeast<{
    RecipeIngredientId?: RecipeIngredientRecipeIngredientIdCompoundUniqueInput
    AND?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    OR?: RecipeIngredientWhereInput[]
    NOT?: RecipeIngredientWhereInput | RecipeIngredientWhereInput[]
    recipeId?: StringFilter<"RecipeIngredient"> | string
    ingredientId?: StringFilter<"RecipeIngredient"> | string
    quantity?: IntFilter<"RecipeIngredient"> | number
    unit?: EnumIngredientUnitNullableFilter<"RecipeIngredient"> | $Enums.IngredientUnit | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }, "RecipeIngredientId">

  export type RecipeIngredientOrderByWithAggregationInput = {
    recipeId?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: RecipeIngredientCountOrderByAggregateInput
    _avg?: RecipeIngredientAvgOrderByAggregateInput
    _max?: RecipeIngredientMaxOrderByAggregateInput
    _min?: RecipeIngredientMinOrderByAggregateInput
    _sum?: RecipeIngredientSumOrderByAggregateInput
  }

  export type RecipeIngredientScalarWhereWithAggregatesInput = {
    AND?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    OR?: RecipeIngredientScalarWhereWithAggregatesInput[]
    NOT?: RecipeIngredientScalarWhereWithAggregatesInput | RecipeIngredientScalarWhereWithAggregatesInput[]
    recipeId?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    ingredientId?: StringWithAggregatesFilter<"RecipeIngredient"> | string
    quantity?: IntWithAggregatesFilter<"RecipeIngredient"> | number
    unit?: EnumIngredientUnitNullableWithAggregatesFilter<"RecipeIngredient"> | $Enums.IngredientUnit | null
  }

  export type ComponentWhereInput = {
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    recipeId?: StringFilter<"Component"> | string
    componentId?: StringFilter<"Component"> | string
    amount?: FloatFilter<"Component"> | number
    component?: XOR<RecipeRelationFilter, RecipeWhereInput>
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }

  export type ComponentOrderByWithRelationInput = {
    recipeId?: SortOrder
    componentId?: SortOrder
    amount?: SortOrder
    component?: RecipeOrderByWithRelationInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type ComponentWhereUniqueInput = Prisma.AtLeast<{
    RecipeComponentId?: ComponentRecipeComponentIdCompoundUniqueInput
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    recipeId?: StringFilter<"Component"> | string
    componentId?: StringFilter<"Component"> | string
    amount?: FloatFilter<"Component"> | number
    component?: XOR<RecipeRelationFilter, RecipeWhereInput>
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }, "RecipeComponentId">

  export type ComponentOrderByWithAggregationInput = {
    recipeId?: SortOrder
    componentId?: SortOrder
    amount?: SortOrder
    _count?: ComponentCountOrderByAggregateInput
    _avg?: ComponentAvgOrderByAggregateInput
    _max?: ComponentMaxOrderByAggregateInput
    _min?: ComponentMinOrderByAggregateInput
    _sum?: ComponentSumOrderByAggregateInput
  }

  export type ComponentScalarWhereWithAggregatesInput = {
    AND?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    OR?: ComponentScalarWhereWithAggregatesInput[]
    NOT?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    recipeId?: StringWithAggregatesFilter<"Component"> | string
    componentId?: StringWithAggregatesFilter<"Component"> | string
    amount?: FloatWithAggregatesFilter<"Component"> | number
  }

  export type IterationWhereInput = {
    AND?: IterationWhereInput | IterationWhereInput[]
    OR?: IterationWhereInput[]
    NOT?: IterationWhereInput | IterationWhereInput[]
    id?: StringFilter<"Iteration"> | string
    recipeId?: StringFilter<"Iteration"> | string
    createdOn?: DateTimeNullableFilter<"Iteration"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Iteration"> | Date | string | null
    parentId?: StringNullableFilter<"Iteration"> | string | null
    tag?: StringNullableFilter<"Iteration"> | string | null
    ingredients?: IngredientIterationListRelationFilter
    instructions?: InstructionIterationListRelationFilter
    parent?: XOR<IterationNullableRelationFilter, IterationWhereInput> | null
    children?: IterationListRelationFilter
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }

  export type IterationOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    createdOn?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    ingredients?: IngredientIterationOrderByRelationAggregateInput
    instructions?: InstructionIterationOrderByRelationAggregateInput
    parent?: IterationOrderByWithRelationInput
    children?: IterationOrderByRelationAggregateInput
    recipe?: RecipeOrderByWithRelationInput
  }

  export type IterationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: IterationWhereInput | IterationWhereInput[]
    OR?: IterationWhereInput[]
    NOT?: IterationWhereInput | IterationWhereInput[]
    recipeId?: StringFilter<"Iteration"> | string
    createdOn?: DateTimeNullableFilter<"Iteration"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Iteration"> | Date | string | null
    parentId?: StringNullableFilter<"Iteration"> | string | null
    tag?: StringNullableFilter<"Iteration"> | string | null
    ingredients?: IngredientIterationListRelationFilter
    instructions?: InstructionIterationListRelationFilter
    parent?: XOR<IterationNullableRelationFilter, IterationWhereInput> | null
    children?: IterationListRelationFilter
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
  }, "id">

  export type IterationOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    createdOn?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    tag?: SortOrderInput | SortOrder
    _count?: IterationCountOrderByAggregateInput
    _max?: IterationMaxOrderByAggregateInput
    _min?: IterationMinOrderByAggregateInput
  }

  export type IterationScalarWhereWithAggregatesInput = {
    AND?: IterationScalarWhereWithAggregatesInput | IterationScalarWhereWithAggregatesInput[]
    OR?: IterationScalarWhereWithAggregatesInput[]
    NOT?: IterationScalarWhereWithAggregatesInput | IterationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Iteration"> | string
    recipeId?: StringWithAggregatesFilter<"Iteration"> | string
    createdOn?: DateTimeNullableWithAggregatesFilter<"Iteration"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Iteration"> | Date | string | null
    parentId?: StringNullableWithAggregatesFilter<"Iteration"> | string | null
    tag?: StringNullableWithAggregatesFilter<"Iteration"> | string | null
  }

  export type IngredientIterationWhereInput = {
    AND?: IngredientIterationWhereInput | IngredientIterationWhereInput[]
    OR?: IngredientIterationWhereInput[]
    NOT?: IngredientIterationWhereInput | IngredientIterationWhereInput[]
    ingredientId?: StringFilter<"IngredientIteration"> | string
    quantity?: IntFilter<"IngredientIteration"> | number
    iterationId?: StringFilter<"IngredientIteration"> | string
    unit?: EnumIngredientUnitNullableFilter<"IngredientIteration"> | $Enums.IngredientUnit | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    recipe?: XOR<IterationRelationFilter, IterationWhereInput>
  }

  export type IngredientIterationOrderByWithRelationInput = {
    ingredientId?: SortOrder
    quantity?: SortOrder
    iterationId?: SortOrder
    unit?: SortOrderInput | SortOrder
    ingredient?: IngredientOrderByWithRelationInput
    recipe?: IterationOrderByWithRelationInput
  }

  export type IngredientIterationWhereUniqueInput = Prisma.AtLeast<{
    RecipeIngredientId?: IngredientIterationRecipeIngredientIdCompoundUniqueInput
    AND?: IngredientIterationWhereInput | IngredientIterationWhereInput[]
    OR?: IngredientIterationWhereInput[]
    NOT?: IngredientIterationWhereInput | IngredientIterationWhereInput[]
    ingredientId?: StringFilter<"IngredientIteration"> | string
    quantity?: IntFilter<"IngredientIteration"> | number
    iterationId?: StringFilter<"IngredientIteration"> | string
    unit?: EnumIngredientUnitNullableFilter<"IngredientIteration"> | $Enums.IngredientUnit | null
    ingredient?: XOR<IngredientRelationFilter, IngredientWhereInput>
    recipe?: XOR<IterationRelationFilter, IterationWhereInput>
  }, "RecipeIngredientId">

  export type IngredientIterationOrderByWithAggregationInput = {
    ingredientId?: SortOrder
    quantity?: SortOrder
    iterationId?: SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: IngredientIterationCountOrderByAggregateInput
    _avg?: IngredientIterationAvgOrderByAggregateInput
    _max?: IngredientIterationMaxOrderByAggregateInput
    _min?: IngredientIterationMinOrderByAggregateInput
    _sum?: IngredientIterationSumOrderByAggregateInput
  }

  export type IngredientIterationScalarWhereWithAggregatesInput = {
    AND?: IngredientIterationScalarWhereWithAggregatesInput | IngredientIterationScalarWhereWithAggregatesInput[]
    OR?: IngredientIterationScalarWhereWithAggregatesInput[]
    NOT?: IngredientIterationScalarWhereWithAggregatesInput | IngredientIterationScalarWhereWithAggregatesInput[]
    ingredientId?: StringWithAggregatesFilter<"IngredientIteration"> | string
    quantity?: IntWithAggregatesFilter<"IngredientIteration"> | number
    iterationId?: StringWithAggregatesFilter<"IngredientIteration"> | string
    unit?: EnumIngredientUnitNullableWithAggregatesFilter<"IngredientIteration"> | $Enums.IngredientUnit | null
  }

  export type InstructionIterationWhereInput = {
    AND?: InstructionIterationWhereInput | InstructionIterationWhereInput[]
    OR?: InstructionIterationWhereInput[]
    NOT?: InstructionIterationWhereInput | InstructionIterationWhereInput[]
    description?: StringFilter<"InstructionIteration"> | string
    step?: IntFilter<"InstructionIteration"> | number
    iterationId?: StringFilter<"InstructionIteration"> | string
    recipe?: XOR<IterationRelationFilter, IterationWhereInput>
    timeAndTemperature?: XOR<TimeAndTemperatureIterationNullableRelationFilter, TimeAndTemperatureIterationWhereInput> | null
  }

  export type InstructionIterationOrderByWithRelationInput = {
    description?: SortOrder
    step?: SortOrder
    iterationId?: SortOrder
    recipe?: IterationOrderByWithRelationInput
    timeAndTemperature?: TimeAndTemperatureIterationOrderByWithRelationInput
  }

  export type InstructionIterationWhereUniqueInput = Prisma.AtLeast<{
    InstructionId?: InstructionIterationInstructionIdCompoundUniqueInput
    AND?: InstructionIterationWhereInput | InstructionIterationWhereInput[]
    OR?: InstructionIterationWhereInput[]
    NOT?: InstructionIterationWhereInput | InstructionIterationWhereInput[]
    description?: StringFilter<"InstructionIteration"> | string
    step?: IntFilter<"InstructionIteration"> | number
    iterationId?: StringFilter<"InstructionIteration"> | string
    recipe?: XOR<IterationRelationFilter, IterationWhereInput>
    timeAndTemperature?: XOR<TimeAndTemperatureIterationNullableRelationFilter, TimeAndTemperatureIterationWhereInput> | null
  }, "InstructionId">

  export type InstructionIterationOrderByWithAggregationInput = {
    description?: SortOrder
    step?: SortOrder
    iterationId?: SortOrder
    _count?: InstructionIterationCountOrderByAggregateInput
    _avg?: InstructionIterationAvgOrderByAggregateInput
    _max?: InstructionIterationMaxOrderByAggregateInput
    _min?: InstructionIterationMinOrderByAggregateInput
    _sum?: InstructionIterationSumOrderByAggregateInput
  }

  export type InstructionIterationScalarWhereWithAggregatesInput = {
    AND?: InstructionIterationScalarWhereWithAggregatesInput | InstructionIterationScalarWhereWithAggregatesInput[]
    OR?: InstructionIterationScalarWhereWithAggregatesInput[]
    NOT?: InstructionIterationScalarWhereWithAggregatesInput | InstructionIterationScalarWhereWithAggregatesInput[]
    description?: StringWithAggregatesFilter<"InstructionIteration"> | string
    step?: IntWithAggregatesFilter<"InstructionIteration"> | number
    iterationId?: StringWithAggregatesFilter<"InstructionIteration"> | string
  }

  export type TimeAndTemperatureIterationWhereInput = {
    AND?: TimeAndTemperatureIterationWhereInput | TimeAndTemperatureIterationWhereInput[]
    OR?: TimeAndTemperatureIterationWhereInput[]
    NOT?: TimeAndTemperatureIterationWhereInput | TimeAndTemperatureIterationWhereInput[]
    iterationId?: StringFilter<"TimeAndTemperatureIteration"> | string
    instructionStep?: IntFilter<"TimeAndTemperatureIteration"> | number
    hours?: IntNullableFilter<"TimeAndTemperatureIteration"> | number | null
    minutes?: IntNullableFilter<"TimeAndTemperatureIteration"> | number | null
    temperature?: IntFilter<"TimeAndTemperatureIteration"> | number
    unit?: EnumTemperatureUnitNullableFilter<"TimeAndTemperatureIteration"> | $Enums.TemperatureUnit | null
    instruction?: XOR<InstructionIterationRelationFilter, InstructionIterationWhereInput>
  }

  export type TimeAndTemperatureIterationOrderByWithRelationInput = {
    iterationId?: SortOrder
    instructionStep?: SortOrder
    hours?: SortOrderInput | SortOrder
    minutes?: SortOrderInput | SortOrder
    temperature?: SortOrder
    unit?: SortOrderInput | SortOrder
    instruction?: InstructionIterationOrderByWithRelationInput
  }

  export type TimeAndTemperatureIterationWhereUniqueInput = Prisma.AtLeast<{
    iterationId_instructionStep?: TimeAndTemperatureIterationIterationIdInstructionStepCompoundUniqueInput
    AND?: TimeAndTemperatureIterationWhereInput | TimeAndTemperatureIterationWhereInput[]
    OR?: TimeAndTemperatureIterationWhereInput[]
    NOT?: TimeAndTemperatureIterationWhereInput | TimeAndTemperatureIterationWhereInput[]
    iterationId?: StringFilter<"TimeAndTemperatureIteration"> | string
    instructionStep?: IntFilter<"TimeAndTemperatureIteration"> | number
    hours?: IntNullableFilter<"TimeAndTemperatureIteration"> | number | null
    minutes?: IntNullableFilter<"TimeAndTemperatureIteration"> | number | null
    temperature?: IntFilter<"TimeAndTemperatureIteration"> | number
    unit?: EnumTemperatureUnitNullableFilter<"TimeAndTemperatureIteration"> | $Enums.TemperatureUnit | null
    instruction?: XOR<InstructionIterationRelationFilter, InstructionIterationWhereInput>
  }, "iterationId_instructionStep">

  export type TimeAndTemperatureIterationOrderByWithAggregationInput = {
    iterationId?: SortOrder
    instructionStep?: SortOrder
    hours?: SortOrderInput | SortOrder
    minutes?: SortOrderInput | SortOrder
    temperature?: SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: TimeAndTemperatureIterationCountOrderByAggregateInput
    _avg?: TimeAndTemperatureIterationAvgOrderByAggregateInput
    _max?: TimeAndTemperatureIterationMaxOrderByAggregateInput
    _min?: TimeAndTemperatureIterationMinOrderByAggregateInput
    _sum?: TimeAndTemperatureIterationSumOrderByAggregateInput
  }

  export type TimeAndTemperatureIterationScalarWhereWithAggregatesInput = {
    AND?: TimeAndTemperatureIterationScalarWhereWithAggregatesInput | TimeAndTemperatureIterationScalarWhereWithAggregatesInput[]
    OR?: TimeAndTemperatureIterationScalarWhereWithAggregatesInput[]
    NOT?: TimeAndTemperatureIterationScalarWhereWithAggregatesInput | TimeAndTemperatureIterationScalarWhereWithAggregatesInput[]
    iterationId?: StringWithAggregatesFilter<"TimeAndTemperatureIteration"> | string
    instructionStep?: IntWithAggregatesFilter<"TimeAndTemperatureIteration"> | number
    hours?: IntNullableWithAggregatesFilter<"TimeAndTemperatureIteration"> | number | null
    minutes?: IntNullableWithAggregatesFilter<"TimeAndTemperatureIteration"> | number | null
    temperature?: IntWithAggregatesFilter<"TimeAndTemperatureIteration"> | number
    unit?: EnumTemperatureUnitNullableWithAggregatesFilter<"TimeAndTemperatureIteration"> | $Enums.TemperatureUnit | null
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    recipes?: RecipeCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionUncheckedCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    recipes?: RecipeUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUncheckedUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RecipeCreateInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
  }

  export type RecipeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type IngredientCreateInput = {
    id?: string
    name: string
    iterations?: IngredientIterationCreateNestedManyWithoutIngredientInput
    recipes?: RecipeIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateInput = {
    id?: string
    name: string
    iterations?: IngredientIterationUncheckedCreateNestedManyWithoutIngredientInput
    recipes?: RecipeIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iterations?: IngredientIterationUpdateManyWithoutIngredientNestedInput
    recipes?: RecipeIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iterations?: IngredientIterationUncheckedUpdateManyWithoutIngredientNestedInput
    recipes?: RecipeIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientCreateManyInput = {
    id?: string
    name: string
  }

  export type IngredientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionCreateInput = {
    accepted?: boolean
    connectedBy: UserCreateNestedOneWithoutConnectedWithInput
    connectedWith: UserCreateNestedOneWithoutConnectedByInput
  }

  export type ConnectionUncheckedCreateInput = {
    connectedWithId: string
    connectedById: string
    accepted?: boolean
  }

  export type ConnectionUpdateInput = {
    accepted?: BoolFieldUpdateOperationsInput | boolean
    connectedBy?: UserUpdateOneRequiredWithoutConnectedWithNestedInput
    connectedWith?: UserUpdateOneRequiredWithoutConnectedByNestedInput
  }

  export type ConnectionUncheckedUpdateInput = {
    connectedWithId?: StringFieldUpdateOperationsInput | string
    connectedById?: StringFieldUpdateOperationsInput | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionCreateManyInput = {
    connectedWithId: string
    connectedById: string
    accepted?: boolean
  }

  export type ConnectionUpdateManyMutationInput = {
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionUncheckedUpdateManyInput = {
    connectedWithId?: StringFieldUpdateOperationsInput | string
    connectedById?: StringFieldUpdateOperationsInput | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TagCreateInput = {
    name: string
    recipe: RecipeCreateNestedOneWithoutTagsInput
  }

  export type TagUncheckedCreateInput = {
    recipeId: string
    name: string
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    recipe?: RecipeUpdateOneRequiredWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagCreateManyInput = {
    recipeId: string
    name: string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeEditorsCreateInput = {
    recipe: RecipeCreateNestedOneWithoutEditorsInput
    user: UserCreateNestedOneWithoutRecipeEditorsInput
  }

  export type RecipeEditorsUncheckedCreateInput = {
    recipeId: string
    userId: string
  }

  export type RecipeEditorsUpdateInput = {
    recipe?: RecipeUpdateOneRequiredWithoutEditorsNestedInput
    user?: UserUpdateOneRequiredWithoutRecipeEditorsNestedInput
  }

  export type RecipeEditorsUncheckedUpdateInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeEditorsCreateManyInput = {
    recipeId: string
    userId: string
  }

  export type RecipeEditorsUpdateManyMutationInput = {

  }

  export type RecipeEditorsUncheckedUpdateManyInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RatingCreateInput = {
    value: number
    recipe: RecipeCreateNestedOneWithoutRatingsInput
    user: UserCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    recipeId: string
    userId: string
    value: number
  }

  export type RatingUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutRatingsNestedInput
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RatingCreateManyInput = {
    recipeId: string
    userId: string
    value: number
  }

  export type RatingUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RatingUncheckedUpdateManyInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    text: string
    createdOn?: Date | string | null
    recipe: RecipeCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    recipeId: string
    userId: string
    text: string
    createdOn?: Date | string | null
  }

  export type ReviewUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipe?: RecipeUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewCreateManyInput = {
    recipeId: string
    userId: string
    text: string
    createdOn?: Date | string | null
  }

  export type ReviewUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InstructionCreateInput = {
    description: string
    step: number
    recipe: RecipeCreateNestedOneWithoutInstructionsInput
    timeAndTemperature?: TimeAndTemperatureCreateNestedOneWithoutInstructionInput
  }

  export type InstructionUncheckedCreateInput = {
    description: string
    recipeId: string
    step: number
    timeAndTemperature?: TimeAndTemperatureUncheckedCreateNestedOneWithoutInstructionInput
  }

  export type InstructionUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutInstructionsNestedInput
    timeAndTemperature?: TimeAndTemperatureUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionUncheckedUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    timeAndTemperature?: TimeAndTemperatureUncheckedUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionCreateManyInput = {
    description: string
    recipeId: string
    step: number
  }

  export type InstructionUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
  }

  export type InstructionUncheckedUpdateManyInput = {
    description?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
  }

  export type TimeAndTemperatureCreateInput = {
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
    instruction: InstructionCreateNestedOneWithoutTimeAndTemperatureInput
  }

  export type TimeAndTemperatureUncheckedCreateInput = {
    recipeId: string
    step: number
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureUpdateInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
    instruction?: InstructionUpdateOneRequiredWithoutTimeAndTemperatureNestedInput
  }

  export type TimeAndTemperatureUncheckedUpdateInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureCreateManyInput = {
    recipeId: string
    step: number
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureUpdateManyMutationInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureUncheckedUpdateManyInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type RecipeIngredientCreateInput = {
    quantity: number
    unit?: $Enums.IngredientUnit | null
    ingredient: IngredientCreateNestedOneWithoutRecipesInput
    recipe: RecipeCreateNestedOneWithoutIngredientsInput
  }

  export type RecipeIngredientUncheckedCreateInput = {
    recipeId: string
    ingredientId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type RecipeIngredientUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
    ingredient?: IngredientUpdateOneRequiredWithoutRecipesNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type RecipeIngredientUncheckedUpdateInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type RecipeIngredientCreateManyInput = {
    recipeId: string
    ingredientId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type RecipeIngredientUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type RecipeIngredientUncheckedUpdateManyInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type ComponentCreateInput = {
    amount: number
    component: RecipeCreateNestedOneWithoutParentRecipesInput
    recipe: RecipeCreateNestedOneWithoutComponentsInput
  }

  export type ComponentUncheckedCreateInput = {
    recipeId: string
    componentId: string
    amount: number
  }

  export type ComponentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    component?: RecipeUpdateOneRequiredWithoutParentRecipesNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type ComponentUncheckedUpdateInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ComponentCreateManyInput = {
    recipeId: string
    componentId: string
    amount: number
  }

  export type ComponentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ComponentUncheckedUpdateManyInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    componentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type IterationCreateInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
    ingredients?: IngredientIterationCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationCreateNestedManyWithoutRecipeInput
    parent?: IterationCreateNestedOneWithoutChildrenInput
    children?: IterationCreateNestedManyWithoutParentInput
    recipe: RecipeCreateNestedOneWithoutIterationsInput
  }

  export type IterationUncheckedCreateInput = {
    id?: string
    recipeId: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    parentId?: string | null
    tag?: string | null
    ingredients?: IngredientIterationUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationUncheckedCreateNestedManyWithoutRecipeInput
    children?: IterationUncheckedCreateNestedManyWithoutParentInput
  }

  export type IterationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUpdateManyWithoutRecipeNestedInput
    parent?: IterationUpdateOneWithoutChildrenNestedInput
    children?: IterationUpdateManyWithoutParentNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutIterationsNestedInput
  }

  export type IterationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUncheckedUpdateManyWithoutRecipeNestedInput
    children?: IterationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type IterationCreateManyInput = {
    id?: string
    recipeId: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    parentId?: string | null
    tag?: string | null
  }

  export type IterationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IterationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IngredientIterationCreateInput = {
    quantity: number
    unit?: $Enums.IngredientUnit | null
    ingredient: IngredientCreateNestedOneWithoutIterationsInput
    recipe: IterationCreateNestedOneWithoutIngredientsInput
  }

  export type IngredientIterationUncheckedCreateInput = {
    ingredientId: string
    quantity: number
    iterationId: string
    unit?: $Enums.IngredientUnit | null
  }

  export type IngredientIterationUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
    ingredient?: IngredientUpdateOneRequiredWithoutIterationsNestedInput
    recipe?: IterationUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type IngredientIterationUncheckedUpdateInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    iterationId?: StringFieldUpdateOperationsInput | string
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type IngredientIterationCreateManyInput = {
    ingredientId: string
    quantity: number
    iterationId: string
    unit?: $Enums.IngredientUnit | null
  }

  export type IngredientIterationUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type IngredientIterationUncheckedUpdateManyInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    iterationId?: StringFieldUpdateOperationsInput | string
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type InstructionIterationCreateInput = {
    description: string
    step: number
    recipe: IterationCreateNestedOneWithoutInstructionsInput
    timeAndTemperature?: TimeAndTemperatureIterationCreateNestedOneWithoutInstructionInput
  }

  export type InstructionIterationUncheckedCreateInput = {
    description: string
    step: number
    iterationId: string
    timeAndTemperature?: TimeAndTemperatureIterationUncheckedCreateNestedOneWithoutInstructionInput
  }

  export type InstructionIterationUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    recipe?: IterationUpdateOneRequiredWithoutInstructionsNestedInput
    timeAndTemperature?: TimeAndTemperatureIterationUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionIterationUncheckedUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    iterationId?: StringFieldUpdateOperationsInput | string
    timeAndTemperature?: TimeAndTemperatureIterationUncheckedUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionIterationCreateManyInput = {
    description: string
    step: number
    iterationId: string
  }

  export type InstructionIterationUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
  }

  export type InstructionIterationUncheckedUpdateManyInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    iterationId?: StringFieldUpdateOperationsInput | string
  }

  export type TimeAndTemperatureIterationCreateInput = {
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
    instruction: InstructionIterationCreateNestedOneWithoutTimeAndTemperatureInput
  }

  export type TimeAndTemperatureIterationUncheckedCreateInput = {
    iterationId: string
    instructionStep: number
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationUpdateInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
    instruction?: InstructionIterationUpdateOneRequiredWithoutTimeAndTemperatureNestedInput
  }

  export type TimeAndTemperatureIterationUncheckedUpdateInput = {
    iterationId?: StringFieldUpdateOperationsInput | string
    instructionStep?: IntFieldUpdateOperationsInput | number
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationCreateManyInput = {
    iterationId: string
    instructionStep: number
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationUpdateManyMutationInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationUncheckedUpdateManyInput = {
    iterationId?: StringFieldUpdateOperationsInput | string
    instructionStep?: IntFieldUpdateOperationsInput | number
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ConnectionListRelationFilter = {
    every?: ConnectionWhereInput
    some?: ConnectionWhereInput
    none?: ConnectionWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type RecipeEditorsListRelationFilter = {
    every?: RecipeEditorsWhereInput
    some?: RecipeEditorsWhereInput
    none?: RecipeEditorsWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeEditorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    image?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    image?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    image?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ComponentListRelationFilter = {
    every?: ComponentWhereInput
    some?: ComponentWhereInput
    none?: ComponentWhereInput
  }

  export type InstructionListRelationFilter = {
    every?: InstructionWhereInput
    some?: InstructionWhereInput
    none?: InstructionWhereInput
  }

  export type IterationListRelationFilter = {
    every?: IterationWhereInput
    some?: IterationWhereInput
    none?: IterationWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RecipeIngredientListRelationFilter = {
    every?: RecipeIngredientWhereInput
    some?: RecipeIngredientWhereInput
    none?: RecipeIngredientWhereInput
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type ComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstructionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IterationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeIngredientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    createdOn?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    image?: SortOrder
    description?: SortOrder
    public?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdOn?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    image?: SortOrder
    description?: SortOrder
    public?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    createdOn?: SortOrder
    updatedAt?: SortOrder
    title?: SortOrder
    authorId?: SortOrder
    image?: SortOrder
    description?: SortOrder
    public?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IngredientIterationListRelationFilter = {
    every?: IngredientIterationWhereInput
    some?: IngredientIterationWhereInput
    none?: IngredientIterationWhereInput
  }

  export type IngredientIterationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IngredientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type IngredientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type IngredientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ConnectionConnectionIdCompoundUniqueInput = {
    connectedWithId: string
    connectedById: string
  }

  export type ConnectionCountOrderByAggregateInput = {
    connectedWithId?: SortOrder
    connectedById?: SortOrder
    accepted?: SortOrder
  }

  export type ConnectionMaxOrderByAggregateInput = {
    connectedWithId?: SortOrder
    connectedById?: SortOrder
    accepted?: SortOrder
  }

  export type ConnectionMinOrderByAggregateInput = {
    connectedWithId?: SortOrder
    connectedById?: SortOrder
    accepted?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type TagRecipeIdNameCompoundUniqueInput = {
    recipeId: string
    name: string
  }

  export type TagCountOrderByAggregateInput = {
    recipeId?: SortOrder
    name?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    recipeId?: SortOrder
    name?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    recipeId?: SortOrder
    name?: SortOrder
  }

  export type RecipeEditorsEditorIdCompoundUniqueInput = {
    recipeId: string
    userId: string
  }

  export type RecipeEditorsCountOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
  }

  export type RecipeEditorsMaxOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
  }

  export type RecipeEditorsMinOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type RatingRatingIdCompoundUniqueInput = {
    recipeId: string
    userId: string
  }

  export type RatingCountOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    value?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ReviewReviewIdCompoundUniqueInput = {
    recipeId: string
    userId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdOn?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdOn?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    recipeId?: SortOrder
    userId?: SortOrder
    text?: SortOrder
    createdOn?: SortOrder
  }

  export type TimeAndTemperatureNullableRelationFilter = {
    is?: TimeAndTemperatureWhereInput | null
    isNot?: TimeAndTemperatureWhereInput | null
  }

  export type InstructionInstructionIdCompoundUniqueInput = {
    recipeId: string
    step: number
  }

  export type InstructionCountOrderByAggregateInput = {
    description?: SortOrder
    recipeId?: SortOrder
    step?: SortOrder
  }

  export type InstructionAvgOrderByAggregateInput = {
    step?: SortOrder
  }

  export type InstructionMaxOrderByAggregateInput = {
    description?: SortOrder
    recipeId?: SortOrder
    step?: SortOrder
  }

  export type InstructionMinOrderByAggregateInput = {
    description?: SortOrder
    recipeId?: SortOrder
    step?: SortOrder
  }

  export type InstructionSumOrderByAggregateInput = {
    step?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumTemperatureUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemperatureUnit | EnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemperatureUnitNullableFilter<$PrismaModel> | $Enums.TemperatureUnit | null
  }

  export type InstructionRelationFilter = {
    is?: InstructionWhereInput
    isNot?: InstructionWhereInput
  }

  export type TimeAndTemperatureRecipeIdStepCompoundUniqueInput = {
    recipeId: string
    step: number
  }

  export type TimeAndTemperatureCountOrderByAggregateInput = {
    recipeId?: SortOrder
    step?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
    unit?: SortOrder
  }

  export type TimeAndTemperatureAvgOrderByAggregateInput = {
    step?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
  }

  export type TimeAndTemperatureMaxOrderByAggregateInput = {
    recipeId?: SortOrder
    step?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
    unit?: SortOrder
  }

  export type TimeAndTemperatureMinOrderByAggregateInput = {
    recipeId?: SortOrder
    step?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
    unit?: SortOrder
  }

  export type TimeAndTemperatureSumOrderByAggregateInput = {
    step?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumTemperatureUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemperatureUnit | EnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemperatureUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemperatureUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemperatureUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumTemperatureUnitNullableFilter<$PrismaModel>
  }

  export type EnumIngredientUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientUnit | EnumIngredientUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIngredientUnitNullableFilter<$PrismaModel> | $Enums.IngredientUnit | null
  }

  export type IngredientRelationFilter = {
    is?: IngredientWhereInput
    isNot?: IngredientWhereInput
  }

  export type RecipeIngredientRecipeIngredientIdCompoundUniqueInput = {
    recipeId: string
    ingredientId: string
  }

  export type RecipeIngredientCountOrderByAggregateInput = {
    recipeId?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RecipeIngredientAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type RecipeIngredientMaxOrderByAggregateInput = {
    recipeId?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RecipeIngredientMinOrderByAggregateInput = {
    recipeId?: SortOrder
    ingredientId?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
  }

  export type RecipeIngredientSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumIngredientUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientUnit | EnumIngredientUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIngredientUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.IngredientUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIngredientUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumIngredientUnitNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ComponentRecipeComponentIdCompoundUniqueInput = {
    recipeId: string
    componentId: string
  }

  export type ComponentCountOrderByAggregateInput = {
    recipeId?: SortOrder
    componentId?: SortOrder
    amount?: SortOrder
  }

  export type ComponentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ComponentMaxOrderByAggregateInput = {
    recipeId?: SortOrder
    componentId?: SortOrder
    amount?: SortOrder
  }

  export type ComponentMinOrderByAggregateInput = {
    recipeId?: SortOrder
    componentId?: SortOrder
    amount?: SortOrder
  }

  export type ComponentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type InstructionIterationListRelationFilter = {
    every?: InstructionIterationWhereInput
    some?: InstructionIterationWhereInput
    none?: InstructionIterationWhereInput
  }

  export type IterationNullableRelationFilter = {
    is?: IterationWhereInput | null
    isNot?: IterationWhereInput | null
  }

  export type InstructionIterationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IterationCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    createdOn?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    tag?: SortOrder
  }

  export type IterationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    createdOn?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    tag?: SortOrder
  }

  export type IterationMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    createdOn?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    tag?: SortOrder
  }

  export type IterationRelationFilter = {
    is?: IterationWhereInput
    isNot?: IterationWhereInput
  }

  export type IngredientIterationRecipeIngredientIdCompoundUniqueInput = {
    iterationId: string
    ingredientId: string
  }

  export type IngredientIterationCountOrderByAggregateInput = {
    ingredientId?: SortOrder
    quantity?: SortOrder
    iterationId?: SortOrder
    unit?: SortOrder
  }

  export type IngredientIterationAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IngredientIterationMaxOrderByAggregateInput = {
    ingredientId?: SortOrder
    quantity?: SortOrder
    iterationId?: SortOrder
    unit?: SortOrder
  }

  export type IngredientIterationMinOrderByAggregateInput = {
    ingredientId?: SortOrder
    quantity?: SortOrder
    iterationId?: SortOrder
    unit?: SortOrder
  }

  export type IngredientIterationSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type TimeAndTemperatureIterationNullableRelationFilter = {
    is?: TimeAndTemperatureIterationWhereInput | null
    isNot?: TimeAndTemperatureIterationWhereInput | null
  }

  export type InstructionIterationInstructionIdCompoundUniqueInput = {
    iterationId: string
    step: number
  }

  export type InstructionIterationCountOrderByAggregateInput = {
    description?: SortOrder
    step?: SortOrder
    iterationId?: SortOrder
  }

  export type InstructionIterationAvgOrderByAggregateInput = {
    step?: SortOrder
  }

  export type InstructionIterationMaxOrderByAggregateInput = {
    description?: SortOrder
    step?: SortOrder
    iterationId?: SortOrder
  }

  export type InstructionIterationMinOrderByAggregateInput = {
    description?: SortOrder
    step?: SortOrder
    iterationId?: SortOrder
  }

  export type InstructionIterationSumOrderByAggregateInput = {
    step?: SortOrder
  }

  export type InstructionIterationRelationFilter = {
    is?: InstructionIterationWhereInput
    isNot?: InstructionIterationWhereInput
  }

  export type TimeAndTemperatureIterationIterationIdInstructionStepCompoundUniqueInput = {
    iterationId: string
    instructionStep: number
  }

  export type TimeAndTemperatureIterationCountOrderByAggregateInput = {
    iterationId?: SortOrder
    instructionStep?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
    unit?: SortOrder
  }

  export type TimeAndTemperatureIterationAvgOrderByAggregateInput = {
    instructionStep?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
  }

  export type TimeAndTemperatureIterationMaxOrderByAggregateInput = {
    iterationId?: SortOrder
    instructionStep?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
    unit?: SortOrder
  }

  export type TimeAndTemperatureIterationMinOrderByAggregateInput = {
    iterationId?: SortOrder
    instructionStep?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
    unit?: SortOrder
  }

  export type TimeAndTemperatureIterationSumOrderByAggregateInput = {
    instructionStep?: SortOrder
    hours?: SortOrder
    minutes?: SortOrder
    temperature?: SortOrder
  }

  export type ConnectionCreateNestedManyWithoutConnectedByInput = {
    create?: XOR<ConnectionCreateWithoutConnectedByInput, ConnectionUncheckedCreateWithoutConnectedByInput> | ConnectionCreateWithoutConnectedByInput[] | ConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedByInput | ConnectionCreateOrConnectWithoutConnectedByInput[]
    createMany?: ConnectionCreateManyConnectedByInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionCreateNestedManyWithoutConnectedWithInput = {
    create?: XOR<ConnectionCreateWithoutConnectedWithInput, ConnectionUncheckedCreateWithoutConnectedWithInput> | ConnectionCreateWithoutConnectedWithInput[] | ConnectionUncheckedCreateWithoutConnectedWithInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedWithInput | ConnectionCreateOrConnectWithoutConnectedWithInput[]
    createMany?: ConnectionCreateManyConnectedWithInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RecipeCreateWithoutAuthorInput, RecipeUncheckedCreateWithoutAuthorInput> | RecipeCreateWithoutAuthorInput[] | RecipeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutAuthorInput | RecipeCreateOrConnectWithoutAuthorInput[]
    createMany?: RecipeCreateManyAuthorInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeEditorsCreateNestedManyWithoutUserInput = {
    create?: XOR<RecipeEditorsCreateWithoutUserInput, RecipeEditorsUncheckedCreateWithoutUserInput> | RecipeEditorsCreateWithoutUserInput[] | RecipeEditorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutUserInput | RecipeEditorsCreateOrConnectWithoutUserInput[]
    createMany?: RecipeEditorsCreateManyUserInputEnvelope
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutConnectedByInput = {
    create?: XOR<ConnectionCreateWithoutConnectedByInput, ConnectionUncheckedCreateWithoutConnectedByInput> | ConnectionCreateWithoutConnectedByInput[] | ConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedByInput | ConnectionCreateOrConnectWithoutConnectedByInput[]
    createMany?: ConnectionCreateManyConnectedByInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type ConnectionUncheckedCreateNestedManyWithoutConnectedWithInput = {
    create?: XOR<ConnectionCreateWithoutConnectedWithInput, ConnectionUncheckedCreateWithoutConnectedWithInput> | ConnectionCreateWithoutConnectedWithInput[] | ConnectionUncheckedCreateWithoutConnectedWithInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedWithInput | ConnectionCreateOrConnectWithoutConnectedWithInput[]
    createMany?: ConnectionCreateManyConnectedWithInputEnvelope
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RecipeCreateWithoutAuthorInput, RecipeUncheckedCreateWithoutAuthorInput> | RecipeCreateWithoutAuthorInput[] | RecipeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutAuthorInput | RecipeCreateOrConnectWithoutAuthorInput[]
    createMany?: RecipeCreateManyAuthorInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type RecipeEditorsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RecipeEditorsCreateWithoutUserInput, RecipeEditorsUncheckedCreateWithoutUserInput> | RecipeEditorsCreateWithoutUserInput[] | RecipeEditorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutUserInput | RecipeEditorsCreateOrConnectWithoutUserInput[]
    createMany?: RecipeEditorsCreateManyUserInputEnvelope
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ConnectionUpdateManyWithoutConnectedByNestedInput = {
    create?: XOR<ConnectionCreateWithoutConnectedByInput, ConnectionUncheckedCreateWithoutConnectedByInput> | ConnectionCreateWithoutConnectedByInput[] | ConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedByInput | ConnectionCreateOrConnectWithoutConnectedByInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutConnectedByInput | ConnectionUpsertWithWhereUniqueWithoutConnectedByInput[]
    createMany?: ConnectionCreateManyConnectedByInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutConnectedByInput | ConnectionUpdateWithWhereUniqueWithoutConnectedByInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutConnectedByInput | ConnectionUpdateManyWithWhereWithoutConnectedByInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUpdateManyWithoutConnectedWithNestedInput = {
    create?: XOR<ConnectionCreateWithoutConnectedWithInput, ConnectionUncheckedCreateWithoutConnectedWithInput> | ConnectionCreateWithoutConnectedWithInput[] | ConnectionUncheckedCreateWithoutConnectedWithInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedWithInput | ConnectionCreateOrConnectWithoutConnectedWithInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutConnectedWithInput | ConnectionUpsertWithWhereUniqueWithoutConnectedWithInput[]
    createMany?: ConnectionCreateManyConnectedWithInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutConnectedWithInput | ConnectionUpdateWithWhereUniqueWithoutConnectedWithInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutConnectedWithInput | ConnectionUpdateManyWithWhereWithoutConnectedWithInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RecipeCreateWithoutAuthorInput, RecipeUncheckedCreateWithoutAuthorInput> | RecipeCreateWithoutAuthorInput[] | RecipeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutAuthorInput | RecipeCreateOrConnectWithoutAuthorInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutAuthorInput | RecipeUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RecipeCreateManyAuthorInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutAuthorInput | RecipeUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutAuthorInput | RecipeUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeEditorsUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecipeEditorsCreateWithoutUserInput, RecipeEditorsUncheckedCreateWithoutUserInput> | RecipeEditorsCreateWithoutUserInput[] | RecipeEditorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutUserInput | RecipeEditorsCreateOrConnectWithoutUserInput[]
    upsert?: RecipeEditorsUpsertWithWhereUniqueWithoutUserInput | RecipeEditorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecipeEditorsCreateManyUserInputEnvelope
    set?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    disconnect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    delete?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    update?: RecipeEditorsUpdateWithWhereUniqueWithoutUserInput | RecipeEditorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecipeEditorsUpdateManyWithWhereWithoutUserInput | RecipeEditorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecipeEditorsScalarWhereInput | RecipeEditorsScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutConnectedByNestedInput = {
    create?: XOR<ConnectionCreateWithoutConnectedByInput, ConnectionUncheckedCreateWithoutConnectedByInput> | ConnectionCreateWithoutConnectedByInput[] | ConnectionUncheckedCreateWithoutConnectedByInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedByInput | ConnectionCreateOrConnectWithoutConnectedByInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutConnectedByInput | ConnectionUpsertWithWhereUniqueWithoutConnectedByInput[]
    createMany?: ConnectionCreateManyConnectedByInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutConnectedByInput | ConnectionUpdateWithWhereUniqueWithoutConnectedByInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutConnectedByInput | ConnectionUpdateManyWithWhereWithoutConnectedByInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type ConnectionUncheckedUpdateManyWithoutConnectedWithNestedInput = {
    create?: XOR<ConnectionCreateWithoutConnectedWithInput, ConnectionUncheckedCreateWithoutConnectedWithInput> | ConnectionCreateWithoutConnectedWithInput[] | ConnectionUncheckedCreateWithoutConnectedWithInput[]
    connectOrCreate?: ConnectionCreateOrConnectWithoutConnectedWithInput | ConnectionCreateOrConnectWithoutConnectedWithInput[]
    upsert?: ConnectionUpsertWithWhereUniqueWithoutConnectedWithInput | ConnectionUpsertWithWhereUniqueWithoutConnectedWithInput[]
    createMany?: ConnectionCreateManyConnectedWithInputEnvelope
    set?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    disconnect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    delete?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    connect?: ConnectionWhereUniqueInput | ConnectionWhereUniqueInput[]
    update?: ConnectionUpdateWithWhereUniqueWithoutConnectedWithInput | ConnectionUpdateWithWhereUniqueWithoutConnectedWithInput[]
    updateMany?: ConnectionUpdateManyWithWhereWithoutConnectedWithInput | ConnectionUpdateManyWithWhereWithoutConnectedWithInput[]
    deleteMany?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput> | RatingCreateWithoutUserInput[] | RatingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutUserInput | RatingCreateOrConnectWithoutUserInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutUserInput | RatingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RatingCreateManyUserInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutUserInput | RatingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutUserInput | RatingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RecipeCreateWithoutAuthorInput, RecipeUncheckedCreateWithoutAuthorInput> | RecipeCreateWithoutAuthorInput[] | RecipeUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutAuthorInput | RecipeCreateOrConnectWithoutAuthorInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutAuthorInput | RecipeUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RecipeCreateManyAuthorInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutAuthorInput | RecipeUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutAuthorInput | RecipeUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type RecipeEditorsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RecipeEditorsCreateWithoutUserInput, RecipeEditorsUncheckedCreateWithoutUserInput> | RecipeEditorsCreateWithoutUserInput[] | RecipeEditorsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutUserInput | RecipeEditorsCreateOrConnectWithoutUserInput[]
    upsert?: RecipeEditorsUpsertWithWhereUniqueWithoutUserInput | RecipeEditorsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RecipeEditorsCreateManyUserInputEnvelope
    set?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    disconnect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    delete?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    update?: RecipeEditorsUpdateWithWhereUniqueWithoutUserInput | RecipeEditorsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RecipeEditorsUpdateManyWithWhereWithoutUserInput | RecipeEditorsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RecipeEditorsScalarWhereInput | RecipeEditorsScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ComponentCreateNestedManyWithoutComponentInput = {
    create?: XOR<ComponentCreateWithoutComponentInput, ComponentUncheckedCreateWithoutComponentInput> | ComponentCreateWithoutComponentInput[] | ComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutComponentInput | ComponentCreateOrConnectWithoutComponentInput[]
    createMany?: ComponentCreateManyComponentInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type ComponentCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ComponentCreateWithoutRecipeInput, ComponentUncheckedCreateWithoutRecipeInput> | ComponentCreateWithoutRecipeInput[] | ComponentUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutRecipeInput | ComponentCreateOrConnectWithoutRecipeInput[]
    createMany?: ComponentCreateManyRecipeInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type InstructionCreateNestedManyWithoutRecipeInput = {
    create?: XOR<InstructionCreateWithoutRecipeInput, InstructionUncheckedCreateWithoutRecipeInput> | InstructionCreateWithoutRecipeInput[] | InstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionCreateOrConnectWithoutRecipeInput | InstructionCreateOrConnectWithoutRecipeInput[]
    createMany?: InstructionCreateManyRecipeInputEnvelope
    connect?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
  }

  export type IterationCreateNestedManyWithoutRecipeInput = {
    create?: XOR<IterationCreateWithoutRecipeInput, IterationUncheckedCreateWithoutRecipeInput> | IterationCreateWithoutRecipeInput[] | IterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutRecipeInput | IterationCreateOrConnectWithoutRecipeInput[]
    createMany?: IterationCreateManyRecipeInputEnvelope
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RatingCreateWithoutRecipeInput, RatingUncheckedCreateWithoutRecipeInput> | RatingCreateWithoutRecipeInput[] | RatingUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRecipeInput | RatingCreateOrConnectWithoutRecipeInput[]
    createMany?: RatingCreateManyRecipeInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutRecipesInput = {
    create?: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipesInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeEditorsCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeEditorsCreateWithoutRecipeInput, RecipeEditorsUncheckedCreateWithoutRecipeInput> | RecipeEditorsCreateWithoutRecipeInput[] | RecipeEditorsUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutRecipeInput | RecipeEditorsCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeEditorsCreateManyRecipeInputEnvelope
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
  }

  export type RecipeIngredientCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ReviewCreateWithoutRecipeInput, ReviewUncheckedCreateWithoutRecipeInput> | ReviewCreateWithoutRecipeInput[] | ReviewUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRecipeInput | ReviewCreateOrConnectWithoutRecipeInput[]
    createMany?: ReviewCreateManyRecipeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutRecipeInput = {
    create?: XOR<TagCreateWithoutRecipeInput, TagUncheckedCreateWithoutRecipeInput> | TagCreateWithoutRecipeInput[] | TagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRecipeInput | TagCreateOrConnectWithoutRecipeInput[]
    createMany?: TagCreateManyRecipeInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type ComponentUncheckedCreateNestedManyWithoutComponentInput = {
    create?: XOR<ComponentCreateWithoutComponentInput, ComponentUncheckedCreateWithoutComponentInput> | ComponentCreateWithoutComponentInput[] | ComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutComponentInput | ComponentCreateOrConnectWithoutComponentInput[]
    createMany?: ComponentCreateManyComponentInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type ComponentUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ComponentCreateWithoutRecipeInput, ComponentUncheckedCreateWithoutRecipeInput> | ComponentCreateWithoutRecipeInput[] | ComponentUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutRecipeInput | ComponentCreateOrConnectWithoutRecipeInput[]
    createMany?: ComponentCreateManyRecipeInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type InstructionUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<InstructionCreateWithoutRecipeInput, InstructionUncheckedCreateWithoutRecipeInput> | InstructionCreateWithoutRecipeInput[] | InstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionCreateOrConnectWithoutRecipeInput | InstructionCreateOrConnectWithoutRecipeInput[]
    createMany?: InstructionCreateManyRecipeInputEnvelope
    connect?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
  }

  export type IterationUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<IterationCreateWithoutRecipeInput, IterationUncheckedCreateWithoutRecipeInput> | IterationCreateWithoutRecipeInput[] | IterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutRecipeInput | IterationCreateOrConnectWithoutRecipeInput[]
    createMany?: IterationCreateManyRecipeInputEnvelope
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RatingCreateWithoutRecipeInput, RatingUncheckedCreateWithoutRecipeInput> | RatingCreateWithoutRecipeInput[] | RatingUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRecipeInput | RatingCreateOrConnectWithoutRecipeInput[]
    createMany?: RatingCreateManyRecipeInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeEditorsCreateWithoutRecipeInput, RecipeEditorsUncheckedCreateWithoutRecipeInput> | RecipeEditorsCreateWithoutRecipeInput[] | RecipeEditorsUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutRecipeInput | RecipeEditorsCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeEditorsCreateManyRecipeInputEnvelope
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<ReviewCreateWithoutRecipeInput, ReviewUncheckedCreateWithoutRecipeInput> | ReviewCreateWithoutRecipeInput[] | ReviewUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRecipeInput | ReviewCreateOrConnectWithoutRecipeInput[]
    createMany?: ReviewCreateManyRecipeInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<TagCreateWithoutRecipeInput, TagUncheckedCreateWithoutRecipeInput> | TagCreateWithoutRecipeInput[] | TagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRecipeInput | TagCreateOrConnectWithoutRecipeInput[]
    createMany?: TagCreateManyRecipeInputEnvelope
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ComponentUpdateManyWithoutComponentNestedInput = {
    create?: XOR<ComponentCreateWithoutComponentInput, ComponentUncheckedCreateWithoutComponentInput> | ComponentCreateWithoutComponentInput[] | ComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutComponentInput | ComponentCreateOrConnectWithoutComponentInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutComponentInput | ComponentUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: ComponentCreateManyComponentInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutComponentInput | ComponentUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutComponentInput | ComponentUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type ComponentUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ComponentCreateWithoutRecipeInput, ComponentUncheckedCreateWithoutRecipeInput> | ComponentCreateWithoutRecipeInput[] | ComponentUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutRecipeInput | ComponentCreateOrConnectWithoutRecipeInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutRecipeInput | ComponentUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ComponentCreateManyRecipeInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutRecipeInput | ComponentUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutRecipeInput | ComponentUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type InstructionUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<InstructionCreateWithoutRecipeInput, InstructionUncheckedCreateWithoutRecipeInput> | InstructionCreateWithoutRecipeInput[] | InstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionCreateOrConnectWithoutRecipeInput | InstructionCreateOrConnectWithoutRecipeInput[]
    upsert?: InstructionUpsertWithWhereUniqueWithoutRecipeInput | InstructionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: InstructionCreateManyRecipeInputEnvelope
    set?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    disconnect?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    delete?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    connect?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    update?: InstructionUpdateWithWhereUniqueWithoutRecipeInput | InstructionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: InstructionUpdateManyWithWhereWithoutRecipeInput | InstructionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: InstructionScalarWhereInput | InstructionScalarWhereInput[]
  }

  export type IterationUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<IterationCreateWithoutRecipeInput, IterationUncheckedCreateWithoutRecipeInput> | IterationCreateWithoutRecipeInput[] | IterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutRecipeInput | IterationCreateOrConnectWithoutRecipeInput[]
    upsert?: IterationUpsertWithWhereUniqueWithoutRecipeInput | IterationUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: IterationCreateManyRecipeInputEnvelope
    set?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    disconnect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    delete?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    update?: IterationUpdateWithWhereUniqueWithoutRecipeInput | IterationUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: IterationUpdateManyWithWhereWithoutRecipeInput | IterationUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: IterationScalarWhereInput | IterationScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RatingCreateWithoutRecipeInput, RatingUncheckedCreateWithoutRecipeInput> | RatingCreateWithoutRecipeInput[] | RatingUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRecipeInput | RatingCreateOrConnectWithoutRecipeInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutRecipeInput | RatingUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RatingCreateManyRecipeInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutRecipeInput | RatingUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutRecipeInput | RatingUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipesInput
    upsert?: UserUpsertWithoutRecipesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipesInput, UserUpdateWithoutRecipesInput>, UserUncheckedUpdateWithoutRecipesInput>
  }

  export type RecipeEditorsUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeEditorsCreateWithoutRecipeInput, RecipeEditorsUncheckedCreateWithoutRecipeInput> | RecipeEditorsCreateWithoutRecipeInput[] | RecipeEditorsUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutRecipeInput | RecipeEditorsCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeEditorsUpsertWithWhereUniqueWithoutRecipeInput | RecipeEditorsUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeEditorsCreateManyRecipeInputEnvelope
    set?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    disconnect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    delete?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    update?: RecipeEditorsUpdateWithWhereUniqueWithoutRecipeInput | RecipeEditorsUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeEditorsUpdateManyWithWhereWithoutRecipeInput | RecipeEditorsUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeEditorsScalarWhereInput | RecipeEditorsScalarWhereInput[]
  }

  export type RecipeIngredientUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ReviewCreateWithoutRecipeInput, ReviewUncheckedCreateWithoutRecipeInput> | ReviewCreateWithoutRecipeInput[] | ReviewUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRecipeInput | ReviewCreateOrConnectWithoutRecipeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRecipeInput | ReviewUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ReviewCreateManyRecipeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRecipeInput | ReviewUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRecipeInput | ReviewUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TagUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<TagCreateWithoutRecipeInput, TagUncheckedCreateWithoutRecipeInput> | TagCreateWithoutRecipeInput[] | TagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRecipeInput | TagCreateOrConnectWithoutRecipeInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutRecipeInput | TagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: TagCreateManyRecipeInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutRecipeInput | TagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: TagUpdateManyWithWhereWithoutRecipeInput | TagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type ComponentUncheckedUpdateManyWithoutComponentNestedInput = {
    create?: XOR<ComponentCreateWithoutComponentInput, ComponentUncheckedCreateWithoutComponentInput> | ComponentCreateWithoutComponentInput[] | ComponentUncheckedCreateWithoutComponentInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutComponentInput | ComponentCreateOrConnectWithoutComponentInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutComponentInput | ComponentUpsertWithWhereUniqueWithoutComponentInput[]
    createMany?: ComponentCreateManyComponentInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutComponentInput | ComponentUpdateWithWhereUniqueWithoutComponentInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutComponentInput | ComponentUpdateManyWithWhereWithoutComponentInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type ComponentUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ComponentCreateWithoutRecipeInput, ComponentUncheckedCreateWithoutRecipeInput> | ComponentCreateWithoutRecipeInput[] | ComponentUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutRecipeInput | ComponentCreateOrConnectWithoutRecipeInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutRecipeInput | ComponentUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ComponentCreateManyRecipeInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutRecipeInput | ComponentUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutRecipeInput | ComponentUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type InstructionUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<InstructionCreateWithoutRecipeInput, InstructionUncheckedCreateWithoutRecipeInput> | InstructionCreateWithoutRecipeInput[] | InstructionUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionCreateOrConnectWithoutRecipeInput | InstructionCreateOrConnectWithoutRecipeInput[]
    upsert?: InstructionUpsertWithWhereUniqueWithoutRecipeInput | InstructionUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: InstructionCreateManyRecipeInputEnvelope
    set?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    disconnect?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    delete?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    connect?: InstructionWhereUniqueInput | InstructionWhereUniqueInput[]
    update?: InstructionUpdateWithWhereUniqueWithoutRecipeInput | InstructionUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: InstructionUpdateManyWithWhereWithoutRecipeInput | InstructionUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: InstructionScalarWhereInput | InstructionScalarWhereInput[]
  }

  export type IterationUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<IterationCreateWithoutRecipeInput, IterationUncheckedCreateWithoutRecipeInput> | IterationCreateWithoutRecipeInput[] | IterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutRecipeInput | IterationCreateOrConnectWithoutRecipeInput[]
    upsert?: IterationUpsertWithWhereUniqueWithoutRecipeInput | IterationUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: IterationCreateManyRecipeInputEnvelope
    set?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    disconnect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    delete?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    update?: IterationUpdateWithWhereUniqueWithoutRecipeInput | IterationUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: IterationUpdateManyWithWhereWithoutRecipeInput | IterationUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: IterationScalarWhereInput | IterationScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RatingCreateWithoutRecipeInput, RatingUncheckedCreateWithoutRecipeInput> | RatingCreateWithoutRecipeInput[] | RatingUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRecipeInput | RatingCreateOrConnectWithoutRecipeInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutRecipeInput | RatingUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RatingCreateManyRecipeInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutRecipeInput | RatingUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutRecipeInput | RatingUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeEditorsCreateWithoutRecipeInput, RecipeEditorsUncheckedCreateWithoutRecipeInput> | RecipeEditorsCreateWithoutRecipeInput[] | RecipeEditorsUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeEditorsCreateOrConnectWithoutRecipeInput | RecipeEditorsCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeEditorsUpsertWithWhereUniqueWithoutRecipeInput | RecipeEditorsUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeEditorsCreateManyRecipeInputEnvelope
    set?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    disconnect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    delete?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    connect?: RecipeEditorsWhereUniqueInput | RecipeEditorsWhereUniqueInput[]
    update?: RecipeEditorsUpdateWithWhereUniqueWithoutRecipeInput | RecipeEditorsUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeEditorsUpdateManyWithWhereWithoutRecipeInput | RecipeEditorsUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeEditorsScalarWhereInput | RecipeEditorsScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput> | RecipeIngredientCreateWithoutRecipeInput[] | RecipeIngredientUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutRecipeInput | RecipeIngredientCreateOrConnectWithoutRecipeInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: RecipeIngredientCreateManyRecipeInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput | RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutRecipeInput | RecipeIngredientUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<ReviewCreateWithoutRecipeInput, ReviewUncheckedCreateWithoutRecipeInput> | ReviewCreateWithoutRecipeInput[] | ReviewUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutRecipeInput | ReviewCreateOrConnectWithoutRecipeInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutRecipeInput | ReviewUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: ReviewCreateManyRecipeInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutRecipeInput | ReviewUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutRecipeInput | ReviewUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<TagCreateWithoutRecipeInput, TagUncheckedCreateWithoutRecipeInput> | TagCreateWithoutRecipeInput[] | TagUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: TagCreateOrConnectWithoutRecipeInput | TagCreateOrConnectWithoutRecipeInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutRecipeInput | TagUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: TagCreateManyRecipeInputEnvelope
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutRecipeInput | TagUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: TagUpdateManyWithWhereWithoutRecipeInput | TagUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type IngredientIterationCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientIterationCreateWithoutIngredientInput, IngredientIterationUncheckedCreateWithoutIngredientInput> | IngredientIterationCreateWithoutIngredientInput[] | IngredientIterationUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutIngredientInput | IngredientIterationCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientIterationCreateManyIngredientInputEnvelope
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
  }

  export type RecipeIngredientCreateNestedManyWithoutIngredientInput = {
    create?: XOR<RecipeIngredientCreateWithoutIngredientInput, RecipeIngredientUncheckedCreateWithoutIngredientInput> | RecipeIngredientCreateWithoutIngredientInput[] | RecipeIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutIngredientInput | RecipeIngredientCreateOrConnectWithoutIngredientInput[]
    createMany?: RecipeIngredientCreateManyIngredientInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type IngredientIterationUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<IngredientIterationCreateWithoutIngredientInput, IngredientIterationUncheckedCreateWithoutIngredientInput> | IngredientIterationCreateWithoutIngredientInput[] | IngredientIterationUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutIngredientInput | IngredientIterationCreateOrConnectWithoutIngredientInput[]
    createMany?: IngredientIterationCreateManyIngredientInputEnvelope
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
  }

  export type RecipeIngredientUncheckedCreateNestedManyWithoutIngredientInput = {
    create?: XOR<RecipeIngredientCreateWithoutIngredientInput, RecipeIngredientUncheckedCreateWithoutIngredientInput> | RecipeIngredientCreateWithoutIngredientInput[] | RecipeIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutIngredientInput | RecipeIngredientCreateOrConnectWithoutIngredientInput[]
    createMany?: RecipeIngredientCreateManyIngredientInputEnvelope
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
  }

  export type IngredientIterationUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientIterationCreateWithoutIngredientInput, IngredientIterationUncheckedCreateWithoutIngredientInput> | IngredientIterationCreateWithoutIngredientInput[] | IngredientIterationUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutIngredientInput | IngredientIterationCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientIterationUpsertWithWhereUniqueWithoutIngredientInput | IngredientIterationUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientIterationCreateManyIngredientInputEnvelope
    set?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    disconnect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    delete?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    update?: IngredientIterationUpdateWithWhereUniqueWithoutIngredientInput | IngredientIterationUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientIterationUpdateManyWithWhereWithoutIngredientInput | IngredientIterationUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientIterationScalarWhereInput | IngredientIterationScalarWhereInput[]
  }

  export type RecipeIngredientUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutIngredientInput, RecipeIngredientUncheckedCreateWithoutIngredientInput> | RecipeIngredientCreateWithoutIngredientInput[] | RecipeIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutIngredientInput | RecipeIngredientCreateOrConnectWithoutIngredientInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutIngredientInput | RecipeIngredientUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: RecipeIngredientCreateManyIngredientInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutIngredientInput | RecipeIngredientUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutIngredientInput | RecipeIngredientUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type IngredientIterationUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<IngredientIterationCreateWithoutIngredientInput, IngredientIterationUncheckedCreateWithoutIngredientInput> | IngredientIterationCreateWithoutIngredientInput[] | IngredientIterationUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutIngredientInput | IngredientIterationCreateOrConnectWithoutIngredientInput[]
    upsert?: IngredientIterationUpsertWithWhereUniqueWithoutIngredientInput | IngredientIterationUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: IngredientIterationCreateManyIngredientInputEnvelope
    set?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    disconnect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    delete?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    update?: IngredientIterationUpdateWithWhereUniqueWithoutIngredientInput | IngredientIterationUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: IngredientIterationUpdateManyWithWhereWithoutIngredientInput | IngredientIterationUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: IngredientIterationScalarWhereInput | IngredientIterationScalarWhereInput[]
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutIngredientNestedInput = {
    create?: XOR<RecipeIngredientCreateWithoutIngredientInput, RecipeIngredientUncheckedCreateWithoutIngredientInput> | RecipeIngredientCreateWithoutIngredientInput[] | RecipeIngredientUncheckedCreateWithoutIngredientInput[]
    connectOrCreate?: RecipeIngredientCreateOrConnectWithoutIngredientInput | RecipeIngredientCreateOrConnectWithoutIngredientInput[]
    upsert?: RecipeIngredientUpsertWithWhereUniqueWithoutIngredientInput | RecipeIngredientUpsertWithWhereUniqueWithoutIngredientInput[]
    createMany?: RecipeIngredientCreateManyIngredientInputEnvelope
    set?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    disconnect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    delete?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    connect?: RecipeIngredientWhereUniqueInput | RecipeIngredientWhereUniqueInput[]
    update?: RecipeIngredientUpdateWithWhereUniqueWithoutIngredientInput | RecipeIngredientUpdateWithWhereUniqueWithoutIngredientInput[]
    updateMany?: RecipeIngredientUpdateManyWithWhereWithoutIngredientInput | RecipeIngredientUpdateManyWithWhereWithoutIngredientInput[]
    deleteMany?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConnectedWithInput = {
    create?: XOR<UserCreateWithoutConnectedWithInput, UserUncheckedCreateWithoutConnectedWithInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectedWithInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConnectedByInput = {
    create?: XOR<UserCreateWithoutConnectedByInput, UserUncheckedCreateWithoutConnectedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectedByInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutConnectedWithNestedInput = {
    create?: XOR<UserCreateWithoutConnectedWithInput, UserUncheckedCreateWithoutConnectedWithInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectedWithInput
    upsert?: UserUpsertWithoutConnectedWithInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectedWithInput, UserUpdateWithoutConnectedWithInput>, UserUncheckedUpdateWithoutConnectedWithInput>
  }

  export type UserUpdateOneRequiredWithoutConnectedByNestedInput = {
    create?: XOR<UserCreateWithoutConnectedByInput, UserUncheckedCreateWithoutConnectedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutConnectedByInput
    upsert?: UserUpsertWithoutConnectedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConnectedByInput, UserUpdateWithoutConnectedByInput>, UserUncheckedUpdateWithoutConnectedByInput>
  }

  export type RecipeCreateNestedOneWithoutTagsInput = {
    create?: XOR<RecipeCreateWithoutTagsInput, RecipeUncheckedCreateWithoutTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutTagsInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<RecipeCreateWithoutTagsInput, RecipeUncheckedCreateWithoutTagsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutTagsInput
    upsert?: RecipeUpsertWithoutTagsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutTagsInput, RecipeUpdateWithoutTagsInput>, RecipeUncheckedUpdateWithoutTagsInput>
  }

  export type RecipeCreateNestedOneWithoutEditorsInput = {
    create?: XOR<RecipeCreateWithoutEditorsInput, RecipeUncheckedCreateWithoutEditorsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutEditorsInput
    connect?: RecipeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRecipeEditorsInput = {
    create?: XOR<UserCreateWithoutRecipeEditorsInput, UserUncheckedCreateWithoutRecipeEditorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeEditorsInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutEditorsNestedInput = {
    create?: XOR<RecipeCreateWithoutEditorsInput, RecipeUncheckedCreateWithoutEditorsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutEditorsInput
    upsert?: RecipeUpsertWithoutEditorsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutEditorsInput, RecipeUpdateWithoutEditorsInput>, RecipeUncheckedUpdateWithoutEditorsInput>
  }

  export type UserUpdateOneRequiredWithoutRecipeEditorsNestedInput = {
    create?: XOR<UserCreateWithoutRecipeEditorsInput, UserUncheckedCreateWithoutRecipeEditorsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRecipeEditorsInput
    upsert?: UserUpsertWithoutRecipeEditorsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRecipeEditorsInput, UserUpdateWithoutRecipeEditorsInput>, UserUncheckedUpdateWithoutRecipeEditorsInput>
  }

  export type RecipeCreateNestedOneWithoutRatingsInput = {
    create?: XOR<RecipeCreateWithoutRatingsInput, RecipeUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutRatingsInput
    connect?: RecipeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRatingsInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RecipeUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<RecipeCreateWithoutRatingsInput, RecipeUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutRatingsInput
    upsert?: RecipeUpsertWithoutRatingsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutRatingsInput, RecipeUpdateWithoutRatingsInput>, RecipeUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutRatingsNestedInput = {
    create?: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRatingsInput
    upsert?: UserUpsertWithoutRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRatingsInput, UserUpdateWithoutRatingsInput>, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type RecipeCreateNestedOneWithoutReviewsInput = {
    create?: XOR<RecipeCreateWithoutReviewsInput, RecipeUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutReviewsInput
    connect?: RecipeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<RecipeCreateWithoutReviewsInput, RecipeUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutReviewsInput
    upsert?: RecipeUpsertWithoutReviewsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutReviewsInput, RecipeUpdateWithoutReviewsInput>, RecipeUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type RecipeCreateNestedOneWithoutInstructionsInput = {
    create?: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInstructionsInput
    connect?: RecipeWhereUniqueInput
  }

  export type TimeAndTemperatureCreateNestedOneWithoutInstructionInput = {
    create?: XOR<TimeAndTemperatureCreateWithoutInstructionInput, TimeAndTemperatureUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureCreateOrConnectWithoutInstructionInput
    connect?: TimeAndTemperatureWhereUniqueInput
  }

  export type TimeAndTemperatureUncheckedCreateNestedOneWithoutInstructionInput = {
    create?: XOR<TimeAndTemperatureCreateWithoutInstructionInput, TimeAndTemperatureUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureCreateOrConnectWithoutInstructionInput
    connect?: TimeAndTemperatureWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutInstructionsNestedInput = {
    create?: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInstructionsInput
    upsert?: RecipeUpsertWithoutInstructionsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutInstructionsInput, RecipeUpdateWithoutInstructionsInput>, RecipeUncheckedUpdateWithoutInstructionsInput>
  }

  export type TimeAndTemperatureUpdateOneWithoutInstructionNestedInput = {
    create?: XOR<TimeAndTemperatureCreateWithoutInstructionInput, TimeAndTemperatureUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureCreateOrConnectWithoutInstructionInput
    upsert?: TimeAndTemperatureUpsertWithoutInstructionInput
    disconnect?: TimeAndTemperatureWhereInput | boolean
    delete?: TimeAndTemperatureWhereInput | boolean
    connect?: TimeAndTemperatureWhereUniqueInput
    update?: XOR<XOR<TimeAndTemperatureUpdateToOneWithWhereWithoutInstructionInput, TimeAndTemperatureUpdateWithoutInstructionInput>, TimeAndTemperatureUncheckedUpdateWithoutInstructionInput>
  }

  export type TimeAndTemperatureUncheckedUpdateOneWithoutInstructionNestedInput = {
    create?: XOR<TimeAndTemperatureCreateWithoutInstructionInput, TimeAndTemperatureUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureCreateOrConnectWithoutInstructionInput
    upsert?: TimeAndTemperatureUpsertWithoutInstructionInput
    disconnect?: TimeAndTemperatureWhereInput | boolean
    delete?: TimeAndTemperatureWhereInput | boolean
    connect?: TimeAndTemperatureWhereUniqueInput
    update?: XOR<XOR<TimeAndTemperatureUpdateToOneWithWhereWithoutInstructionInput, TimeAndTemperatureUpdateWithoutInstructionInput>, TimeAndTemperatureUncheckedUpdateWithoutInstructionInput>
  }

  export type InstructionCreateNestedOneWithoutTimeAndTemperatureInput = {
    create?: XOR<InstructionCreateWithoutTimeAndTemperatureInput, InstructionUncheckedCreateWithoutTimeAndTemperatureInput>
    connectOrCreate?: InstructionCreateOrConnectWithoutTimeAndTemperatureInput
    connect?: InstructionWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumTemperatureUnitFieldUpdateOperationsInput = {
    set?: $Enums.TemperatureUnit | null
  }

  export type InstructionUpdateOneRequiredWithoutTimeAndTemperatureNestedInput = {
    create?: XOR<InstructionCreateWithoutTimeAndTemperatureInput, InstructionUncheckedCreateWithoutTimeAndTemperatureInput>
    connectOrCreate?: InstructionCreateOrConnectWithoutTimeAndTemperatureInput
    upsert?: InstructionUpsertWithoutTimeAndTemperatureInput
    connect?: InstructionWhereUniqueInput
    update?: XOR<XOR<InstructionUpdateToOneWithWhereWithoutTimeAndTemperatureInput, InstructionUpdateWithoutTimeAndTemperatureInput>, InstructionUncheckedUpdateWithoutTimeAndTemperatureInput>
  }

  export type IngredientCreateNestedOneWithoutRecipesInput = {
    create?: XOR<IngredientCreateWithoutRecipesInput, IngredientUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutRecipesInput
    connect?: IngredientWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutIngredientsInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
  }

  export type NullableEnumIngredientUnitFieldUpdateOperationsInput = {
    set?: $Enums.IngredientUnit | null
  }

  export type IngredientUpdateOneRequiredWithoutRecipesNestedInput = {
    create?: XOR<IngredientCreateWithoutRecipesInput, IngredientUncheckedCreateWithoutRecipesInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutRecipesInput
    upsert?: IngredientUpsertWithoutRecipesInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutRecipesInput, IngredientUpdateWithoutRecipesInput>, IngredientUncheckedUpdateWithoutRecipesInput>
  }

  export type RecipeUpdateOneRequiredWithoutIngredientsNestedInput = {
    create?: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIngredientsInput
    upsert?: RecipeUpsertWithoutIngredientsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutIngredientsInput, RecipeUpdateWithoutIngredientsInput>, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type RecipeCreateNestedOneWithoutParentRecipesInput = {
    create?: XOR<RecipeCreateWithoutParentRecipesInput, RecipeUncheckedCreateWithoutParentRecipesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutParentRecipesInput
    connect?: RecipeWhereUniqueInput
  }

  export type RecipeCreateNestedOneWithoutComponentsInput = {
    create?: XOR<RecipeCreateWithoutComponentsInput, RecipeUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutComponentsInput
    connect?: RecipeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RecipeUpdateOneRequiredWithoutParentRecipesNestedInput = {
    create?: XOR<RecipeCreateWithoutParentRecipesInput, RecipeUncheckedCreateWithoutParentRecipesInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutParentRecipesInput
    upsert?: RecipeUpsertWithoutParentRecipesInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutParentRecipesInput, RecipeUpdateWithoutParentRecipesInput>, RecipeUncheckedUpdateWithoutParentRecipesInput>
  }

  export type RecipeUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<RecipeCreateWithoutComponentsInput, RecipeUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutComponentsInput
    upsert?: RecipeUpsertWithoutComponentsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutComponentsInput, RecipeUpdateWithoutComponentsInput>, RecipeUncheckedUpdateWithoutComponentsInput>
  }

  export type IngredientIterationCreateNestedManyWithoutRecipeInput = {
    create?: XOR<IngredientIterationCreateWithoutRecipeInput, IngredientIterationUncheckedCreateWithoutRecipeInput> | IngredientIterationCreateWithoutRecipeInput[] | IngredientIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutRecipeInput | IngredientIterationCreateOrConnectWithoutRecipeInput[]
    createMany?: IngredientIterationCreateManyRecipeInputEnvelope
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
  }

  export type InstructionIterationCreateNestedManyWithoutRecipeInput = {
    create?: XOR<InstructionIterationCreateWithoutRecipeInput, InstructionIterationUncheckedCreateWithoutRecipeInput> | InstructionIterationCreateWithoutRecipeInput[] | InstructionIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionIterationCreateOrConnectWithoutRecipeInput | InstructionIterationCreateOrConnectWithoutRecipeInput[]
    createMany?: InstructionIterationCreateManyRecipeInputEnvelope
    connect?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
  }

  export type IterationCreateNestedOneWithoutChildrenInput = {
    create?: XOR<IterationCreateWithoutChildrenInput, IterationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: IterationCreateOrConnectWithoutChildrenInput
    connect?: IterationWhereUniqueInput
  }

  export type IterationCreateNestedManyWithoutParentInput = {
    create?: XOR<IterationCreateWithoutParentInput, IterationUncheckedCreateWithoutParentInput> | IterationCreateWithoutParentInput[] | IterationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutParentInput | IterationCreateOrConnectWithoutParentInput[]
    createMany?: IterationCreateManyParentInputEnvelope
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
  }

  export type RecipeCreateNestedOneWithoutIterationsInput = {
    create?: XOR<RecipeCreateWithoutIterationsInput, RecipeUncheckedCreateWithoutIterationsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIterationsInput
    connect?: RecipeWhereUniqueInput
  }

  export type IngredientIterationUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<IngredientIterationCreateWithoutRecipeInput, IngredientIterationUncheckedCreateWithoutRecipeInput> | IngredientIterationCreateWithoutRecipeInput[] | IngredientIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutRecipeInput | IngredientIterationCreateOrConnectWithoutRecipeInput[]
    createMany?: IngredientIterationCreateManyRecipeInputEnvelope
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
  }

  export type InstructionIterationUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<InstructionIterationCreateWithoutRecipeInput, InstructionIterationUncheckedCreateWithoutRecipeInput> | InstructionIterationCreateWithoutRecipeInput[] | InstructionIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionIterationCreateOrConnectWithoutRecipeInput | InstructionIterationCreateOrConnectWithoutRecipeInput[]
    createMany?: InstructionIterationCreateManyRecipeInputEnvelope
    connect?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
  }

  export type IterationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<IterationCreateWithoutParentInput, IterationUncheckedCreateWithoutParentInput> | IterationCreateWithoutParentInput[] | IterationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutParentInput | IterationCreateOrConnectWithoutParentInput[]
    createMany?: IterationCreateManyParentInputEnvelope
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
  }

  export type IngredientIterationUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<IngredientIterationCreateWithoutRecipeInput, IngredientIterationUncheckedCreateWithoutRecipeInput> | IngredientIterationCreateWithoutRecipeInput[] | IngredientIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutRecipeInput | IngredientIterationCreateOrConnectWithoutRecipeInput[]
    upsert?: IngredientIterationUpsertWithWhereUniqueWithoutRecipeInput | IngredientIterationUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: IngredientIterationCreateManyRecipeInputEnvelope
    set?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    disconnect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    delete?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    update?: IngredientIterationUpdateWithWhereUniqueWithoutRecipeInput | IngredientIterationUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: IngredientIterationUpdateManyWithWhereWithoutRecipeInput | IngredientIterationUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: IngredientIterationScalarWhereInput | IngredientIterationScalarWhereInput[]
  }

  export type InstructionIterationUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<InstructionIterationCreateWithoutRecipeInput, InstructionIterationUncheckedCreateWithoutRecipeInput> | InstructionIterationCreateWithoutRecipeInput[] | InstructionIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionIterationCreateOrConnectWithoutRecipeInput | InstructionIterationCreateOrConnectWithoutRecipeInput[]
    upsert?: InstructionIterationUpsertWithWhereUniqueWithoutRecipeInput | InstructionIterationUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: InstructionIterationCreateManyRecipeInputEnvelope
    set?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    disconnect?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    delete?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    connect?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    update?: InstructionIterationUpdateWithWhereUniqueWithoutRecipeInput | InstructionIterationUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: InstructionIterationUpdateManyWithWhereWithoutRecipeInput | InstructionIterationUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: InstructionIterationScalarWhereInput | InstructionIterationScalarWhereInput[]
  }

  export type IterationUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<IterationCreateWithoutChildrenInput, IterationUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: IterationCreateOrConnectWithoutChildrenInput
    upsert?: IterationUpsertWithoutChildrenInput
    disconnect?: IterationWhereInput | boolean
    delete?: IterationWhereInput | boolean
    connect?: IterationWhereUniqueInput
    update?: XOR<XOR<IterationUpdateToOneWithWhereWithoutChildrenInput, IterationUpdateWithoutChildrenInput>, IterationUncheckedUpdateWithoutChildrenInput>
  }

  export type IterationUpdateManyWithoutParentNestedInput = {
    create?: XOR<IterationCreateWithoutParentInput, IterationUncheckedCreateWithoutParentInput> | IterationCreateWithoutParentInput[] | IterationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutParentInput | IterationCreateOrConnectWithoutParentInput[]
    upsert?: IterationUpsertWithWhereUniqueWithoutParentInput | IterationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: IterationCreateManyParentInputEnvelope
    set?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    disconnect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    delete?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    update?: IterationUpdateWithWhereUniqueWithoutParentInput | IterationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: IterationUpdateManyWithWhereWithoutParentInput | IterationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: IterationScalarWhereInput | IterationScalarWhereInput[]
  }

  export type RecipeUpdateOneRequiredWithoutIterationsNestedInput = {
    create?: XOR<RecipeCreateWithoutIterationsInput, RecipeUncheckedCreateWithoutIterationsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutIterationsInput
    upsert?: RecipeUpsertWithoutIterationsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutIterationsInput, RecipeUpdateWithoutIterationsInput>, RecipeUncheckedUpdateWithoutIterationsInput>
  }

  export type IngredientIterationUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<IngredientIterationCreateWithoutRecipeInput, IngredientIterationUncheckedCreateWithoutRecipeInput> | IngredientIterationCreateWithoutRecipeInput[] | IngredientIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: IngredientIterationCreateOrConnectWithoutRecipeInput | IngredientIterationCreateOrConnectWithoutRecipeInput[]
    upsert?: IngredientIterationUpsertWithWhereUniqueWithoutRecipeInput | IngredientIterationUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: IngredientIterationCreateManyRecipeInputEnvelope
    set?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    disconnect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    delete?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    connect?: IngredientIterationWhereUniqueInput | IngredientIterationWhereUniqueInput[]
    update?: IngredientIterationUpdateWithWhereUniqueWithoutRecipeInput | IngredientIterationUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: IngredientIterationUpdateManyWithWhereWithoutRecipeInput | IngredientIterationUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: IngredientIterationScalarWhereInput | IngredientIterationScalarWhereInput[]
  }

  export type InstructionIterationUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<InstructionIterationCreateWithoutRecipeInput, InstructionIterationUncheckedCreateWithoutRecipeInput> | InstructionIterationCreateWithoutRecipeInput[] | InstructionIterationUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: InstructionIterationCreateOrConnectWithoutRecipeInput | InstructionIterationCreateOrConnectWithoutRecipeInput[]
    upsert?: InstructionIterationUpsertWithWhereUniqueWithoutRecipeInput | InstructionIterationUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: InstructionIterationCreateManyRecipeInputEnvelope
    set?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    disconnect?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    delete?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    connect?: InstructionIterationWhereUniqueInput | InstructionIterationWhereUniqueInput[]
    update?: InstructionIterationUpdateWithWhereUniqueWithoutRecipeInput | InstructionIterationUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: InstructionIterationUpdateManyWithWhereWithoutRecipeInput | InstructionIterationUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: InstructionIterationScalarWhereInput | InstructionIterationScalarWhereInput[]
  }

  export type IterationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<IterationCreateWithoutParentInput, IterationUncheckedCreateWithoutParentInput> | IterationCreateWithoutParentInput[] | IterationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: IterationCreateOrConnectWithoutParentInput | IterationCreateOrConnectWithoutParentInput[]
    upsert?: IterationUpsertWithWhereUniqueWithoutParentInput | IterationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: IterationCreateManyParentInputEnvelope
    set?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    disconnect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    delete?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    connect?: IterationWhereUniqueInput | IterationWhereUniqueInput[]
    update?: IterationUpdateWithWhereUniqueWithoutParentInput | IterationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: IterationUpdateManyWithWhereWithoutParentInput | IterationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: IterationScalarWhereInput | IterationScalarWhereInput[]
  }

  export type IngredientCreateNestedOneWithoutIterationsInput = {
    create?: XOR<IngredientCreateWithoutIterationsInput, IngredientUncheckedCreateWithoutIterationsInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIterationsInput
    connect?: IngredientWhereUniqueInput
  }

  export type IterationCreateNestedOneWithoutIngredientsInput = {
    create?: XOR<IterationCreateWithoutIngredientsInput, IterationUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: IterationCreateOrConnectWithoutIngredientsInput
    connect?: IterationWhereUniqueInput
  }

  export type IngredientUpdateOneRequiredWithoutIterationsNestedInput = {
    create?: XOR<IngredientCreateWithoutIterationsInput, IngredientUncheckedCreateWithoutIterationsInput>
    connectOrCreate?: IngredientCreateOrConnectWithoutIterationsInput
    upsert?: IngredientUpsertWithoutIterationsInput
    connect?: IngredientWhereUniqueInput
    update?: XOR<XOR<IngredientUpdateToOneWithWhereWithoutIterationsInput, IngredientUpdateWithoutIterationsInput>, IngredientUncheckedUpdateWithoutIterationsInput>
  }

  export type IterationUpdateOneRequiredWithoutIngredientsNestedInput = {
    create?: XOR<IterationCreateWithoutIngredientsInput, IterationUncheckedCreateWithoutIngredientsInput>
    connectOrCreate?: IterationCreateOrConnectWithoutIngredientsInput
    upsert?: IterationUpsertWithoutIngredientsInput
    connect?: IterationWhereUniqueInput
    update?: XOR<XOR<IterationUpdateToOneWithWhereWithoutIngredientsInput, IterationUpdateWithoutIngredientsInput>, IterationUncheckedUpdateWithoutIngredientsInput>
  }

  export type IterationCreateNestedOneWithoutInstructionsInput = {
    create?: XOR<IterationCreateWithoutInstructionsInput, IterationUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: IterationCreateOrConnectWithoutInstructionsInput
    connect?: IterationWhereUniqueInput
  }

  export type TimeAndTemperatureIterationCreateNestedOneWithoutInstructionInput = {
    create?: XOR<TimeAndTemperatureIterationCreateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureIterationCreateOrConnectWithoutInstructionInput
    connect?: TimeAndTemperatureIterationWhereUniqueInput
  }

  export type TimeAndTemperatureIterationUncheckedCreateNestedOneWithoutInstructionInput = {
    create?: XOR<TimeAndTemperatureIterationCreateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureIterationCreateOrConnectWithoutInstructionInput
    connect?: TimeAndTemperatureIterationWhereUniqueInput
  }

  export type IterationUpdateOneRequiredWithoutInstructionsNestedInput = {
    create?: XOR<IterationCreateWithoutInstructionsInput, IterationUncheckedCreateWithoutInstructionsInput>
    connectOrCreate?: IterationCreateOrConnectWithoutInstructionsInput
    upsert?: IterationUpsertWithoutInstructionsInput
    connect?: IterationWhereUniqueInput
    update?: XOR<XOR<IterationUpdateToOneWithWhereWithoutInstructionsInput, IterationUpdateWithoutInstructionsInput>, IterationUncheckedUpdateWithoutInstructionsInput>
  }

  export type TimeAndTemperatureIterationUpdateOneWithoutInstructionNestedInput = {
    create?: XOR<TimeAndTemperatureIterationCreateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureIterationCreateOrConnectWithoutInstructionInput
    upsert?: TimeAndTemperatureIterationUpsertWithoutInstructionInput
    disconnect?: TimeAndTemperatureIterationWhereInput | boolean
    delete?: TimeAndTemperatureIterationWhereInput | boolean
    connect?: TimeAndTemperatureIterationWhereUniqueInput
    update?: XOR<XOR<TimeAndTemperatureIterationUpdateToOneWithWhereWithoutInstructionInput, TimeAndTemperatureIterationUpdateWithoutInstructionInput>, TimeAndTemperatureIterationUncheckedUpdateWithoutInstructionInput>
  }

  export type TimeAndTemperatureIterationUncheckedUpdateOneWithoutInstructionNestedInput = {
    create?: XOR<TimeAndTemperatureIterationCreateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedCreateWithoutInstructionInput>
    connectOrCreate?: TimeAndTemperatureIterationCreateOrConnectWithoutInstructionInput
    upsert?: TimeAndTemperatureIterationUpsertWithoutInstructionInput
    disconnect?: TimeAndTemperatureIterationWhereInput | boolean
    delete?: TimeAndTemperatureIterationWhereInput | boolean
    connect?: TimeAndTemperatureIterationWhereUniqueInput
    update?: XOR<XOR<TimeAndTemperatureIterationUpdateToOneWithWhereWithoutInstructionInput, TimeAndTemperatureIterationUpdateWithoutInstructionInput>, TimeAndTemperatureIterationUncheckedUpdateWithoutInstructionInput>
  }

  export type InstructionIterationCreateNestedOneWithoutTimeAndTemperatureInput = {
    create?: XOR<InstructionIterationCreateWithoutTimeAndTemperatureInput, InstructionIterationUncheckedCreateWithoutTimeAndTemperatureInput>
    connectOrCreate?: InstructionIterationCreateOrConnectWithoutTimeAndTemperatureInput
    connect?: InstructionIterationWhereUniqueInput
  }

  export type InstructionIterationUpdateOneRequiredWithoutTimeAndTemperatureNestedInput = {
    create?: XOR<InstructionIterationCreateWithoutTimeAndTemperatureInput, InstructionIterationUncheckedCreateWithoutTimeAndTemperatureInput>
    connectOrCreate?: InstructionIterationCreateOrConnectWithoutTimeAndTemperatureInput
    upsert?: InstructionIterationUpsertWithoutTimeAndTemperatureInput
    connect?: InstructionIterationWhereUniqueInput
    update?: XOR<XOR<InstructionIterationUpdateToOneWithWhereWithoutTimeAndTemperatureInput, InstructionIterationUpdateWithoutTimeAndTemperatureInput>, InstructionIterationUncheckedUpdateWithoutTimeAndTemperatureInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumTemperatureUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TemperatureUnit | EnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemperatureUnitNullableFilter<$PrismaModel> | $Enums.TemperatureUnit | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTemperatureUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TemperatureUnit | EnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TemperatureUnit[] | ListEnumTemperatureUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTemperatureUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.TemperatureUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTemperatureUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumTemperatureUnitNullableFilter<$PrismaModel>
  }

  export type NestedEnumIngredientUnitNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientUnit | EnumIngredientUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIngredientUnitNullableFilter<$PrismaModel> | $Enums.IngredientUnit | null
  }

  export type NestedEnumIngredientUnitNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IngredientUnit | EnumIngredientUnitFieldRefInput<$PrismaModel> | null
    in?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.IngredientUnit[] | ListEnumIngredientUnitFieldRefInput<$PrismaModel> | null
    not?: NestedEnumIngredientUnitNullableWithAggregatesFilter<$PrismaModel> | $Enums.IngredientUnit | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumIngredientUnitNullableFilter<$PrismaModel>
    _max?: NestedEnumIngredientUnitNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ConnectionCreateWithoutConnectedByInput = {
    accepted?: boolean
    connectedWith: UserCreateNestedOneWithoutConnectedByInput
  }

  export type ConnectionUncheckedCreateWithoutConnectedByInput = {
    connectedWithId: string
    accepted?: boolean
  }

  export type ConnectionCreateOrConnectWithoutConnectedByInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutConnectedByInput, ConnectionUncheckedCreateWithoutConnectedByInput>
  }

  export type ConnectionCreateManyConnectedByInputEnvelope = {
    data: ConnectionCreateManyConnectedByInput | ConnectionCreateManyConnectedByInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionCreateWithoutConnectedWithInput = {
    accepted?: boolean
    connectedBy: UserCreateNestedOneWithoutConnectedWithInput
  }

  export type ConnectionUncheckedCreateWithoutConnectedWithInput = {
    connectedById: string
    accepted?: boolean
  }

  export type ConnectionCreateOrConnectWithoutConnectedWithInput = {
    where: ConnectionWhereUniqueInput
    create: XOR<ConnectionCreateWithoutConnectedWithInput, ConnectionUncheckedCreateWithoutConnectedWithInput>
  }

  export type ConnectionCreateManyConnectedWithInputEnvelope = {
    data: ConnectionCreateManyConnectedWithInput | ConnectionCreateManyConnectedWithInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutUserInput = {
    value: number
    recipe: RecipeCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutUserInput = {
    recipeId: string
    value: number
  }

  export type RatingCreateOrConnectWithoutUserInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingCreateManyUserInputEnvelope = {
    data: RatingCreateManyUserInput | RatingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutAuthorInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutAuthorInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutAuthorInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutAuthorInput, RecipeUncheckedCreateWithoutAuthorInput>
  }

  export type RecipeCreateManyAuthorInputEnvelope = {
    data: RecipeCreateManyAuthorInput | RecipeCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type RecipeEditorsCreateWithoutUserInput = {
    recipe: RecipeCreateNestedOneWithoutEditorsInput
  }

  export type RecipeEditorsUncheckedCreateWithoutUserInput = {
    recipeId: string
  }

  export type RecipeEditorsCreateOrConnectWithoutUserInput = {
    where: RecipeEditorsWhereUniqueInput
    create: XOR<RecipeEditorsCreateWithoutUserInput, RecipeEditorsUncheckedCreateWithoutUserInput>
  }

  export type RecipeEditorsCreateManyUserInputEnvelope = {
    data: RecipeEditorsCreateManyUserInput | RecipeEditorsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    text: string
    createdOn?: Date | string | null
    recipe: RecipeCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    recipeId: string
    text: string
    createdOn?: Date | string | null
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ConnectionUpsertWithWhereUniqueWithoutConnectedByInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutConnectedByInput, ConnectionUncheckedUpdateWithoutConnectedByInput>
    create: XOR<ConnectionCreateWithoutConnectedByInput, ConnectionUncheckedCreateWithoutConnectedByInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutConnectedByInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutConnectedByInput, ConnectionUncheckedUpdateWithoutConnectedByInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutConnectedByInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutConnectedByInput>
  }

  export type ConnectionScalarWhereInput = {
    AND?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    OR?: ConnectionScalarWhereInput[]
    NOT?: ConnectionScalarWhereInput | ConnectionScalarWhereInput[]
    connectedWithId?: StringFilter<"Connection"> | string
    connectedById?: StringFilter<"Connection"> | string
    accepted?: BoolFilter<"Connection"> | boolean
  }

  export type ConnectionUpsertWithWhereUniqueWithoutConnectedWithInput = {
    where: ConnectionWhereUniqueInput
    update: XOR<ConnectionUpdateWithoutConnectedWithInput, ConnectionUncheckedUpdateWithoutConnectedWithInput>
    create: XOR<ConnectionCreateWithoutConnectedWithInput, ConnectionUncheckedCreateWithoutConnectedWithInput>
  }

  export type ConnectionUpdateWithWhereUniqueWithoutConnectedWithInput = {
    where: ConnectionWhereUniqueInput
    data: XOR<ConnectionUpdateWithoutConnectedWithInput, ConnectionUncheckedUpdateWithoutConnectedWithInput>
  }

  export type ConnectionUpdateManyWithWhereWithoutConnectedWithInput = {
    where: ConnectionScalarWhereInput
    data: XOR<ConnectionUpdateManyMutationInput, ConnectionUncheckedUpdateManyWithoutConnectedWithInput>
  }

  export type RatingUpsertWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
    create: XOR<RatingCreateWithoutUserInput, RatingUncheckedCreateWithoutUserInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutUserInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutUserInput, RatingUncheckedUpdateWithoutUserInput>
  }

  export type RatingUpdateManyWithWhereWithoutUserInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutUserInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    recipeId?: StringFilter<"Rating"> | string
    userId?: StringFilter<"Rating"> | string
    value?: IntFilter<"Rating"> | number
  }

  export type RecipeUpsertWithWhereUniqueWithoutAuthorInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutAuthorInput, RecipeUncheckedUpdateWithoutAuthorInput>
    create: XOR<RecipeCreateWithoutAuthorInput, RecipeUncheckedCreateWithoutAuthorInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutAuthorInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutAuthorInput, RecipeUncheckedUpdateWithoutAuthorInput>
  }

  export type RecipeUpdateManyWithWhereWithoutAuthorInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutAuthorInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    id?: StringFilter<"Recipe"> | string
    createdOn?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Recipe"> | Date | string | null
    title?: StringFilter<"Recipe"> | string
    authorId?: StringFilter<"Recipe"> | string
    image?: StringNullableFilter<"Recipe"> | string | null
    description?: StringNullableFilter<"Recipe"> | string | null
    public?: BoolNullableFilter<"Recipe"> | boolean | null
  }

  export type RecipeEditorsUpsertWithWhereUniqueWithoutUserInput = {
    where: RecipeEditorsWhereUniqueInput
    update: XOR<RecipeEditorsUpdateWithoutUserInput, RecipeEditorsUncheckedUpdateWithoutUserInput>
    create: XOR<RecipeEditorsCreateWithoutUserInput, RecipeEditorsUncheckedCreateWithoutUserInput>
  }

  export type RecipeEditorsUpdateWithWhereUniqueWithoutUserInput = {
    where: RecipeEditorsWhereUniqueInput
    data: XOR<RecipeEditorsUpdateWithoutUserInput, RecipeEditorsUncheckedUpdateWithoutUserInput>
  }

  export type RecipeEditorsUpdateManyWithWhereWithoutUserInput = {
    where: RecipeEditorsScalarWhereInput
    data: XOR<RecipeEditorsUpdateManyMutationInput, RecipeEditorsUncheckedUpdateManyWithoutUserInput>
  }

  export type RecipeEditorsScalarWhereInput = {
    AND?: RecipeEditorsScalarWhereInput | RecipeEditorsScalarWhereInput[]
    OR?: RecipeEditorsScalarWhereInput[]
    NOT?: RecipeEditorsScalarWhereInput | RecipeEditorsScalarWhereInput[]
    recipeId?: StringFilter<"RecipeEditors"> | string
    userId?: StringFilter<"RecipeEditors"> | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    recipeId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    text?: StringFilter<"Review"> | string
    createdOn?: DateTimeNullableFilter<"Review"> | Date | string | null
  }

  export type ComponentCreateWithoutComponentInput = {
    amount: number
    recipe: RecipeCreateNestedOneWithoutComponentsInput
  }

  export type ComponentUncheckedCreateWithoutComponentInput = {
    recipeId: string
    amount: number
  }

  export type ComponentCreateOrConnectWithoutComponentInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutComponentInput, ComponentUncheckedCreateWithoutComponentInput>
  }

  export type ComponentCreateManyComponentInputEnvelope = {
    data: ComponentCreateManyComponentInput | ComponentCreateManyComponentInput[]
    skipDuplicates?: boolean
  }

  export type ComponentCreateWithoutRecipeInput = {
    amount: number
    component: RecipeCreateNestedOneWithoutParentRecipesInput
  }

  export type ComponentUncheckedCreateWithoutRecipeInput = {
    componentId: string
    amount: number
  }

  export type ComponentCreateOrConnectWithoutRecipeInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutRecipeInput, ComponentUncheckedCreateWithoutRecipeInput>
  }

  export type ComponentCreateManyRecipeInputEnvelope = {
    data: ComponentCreateManyRecipeInput | ComponentCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type InstructionCreateWithoutRecipeInput = {
    description: string
    step: number
    timeAndTemperature?: TimeAndTemperatureCreateNestedOneWithoutInstructionInput
  }

  export type InstructionUncheckedCreateWithoutRecipeInput = {
    description: string
    step: number
    timeAndTemperature?: TimeAndTemperatureUncheckedCreateNestedOneWithoutInstructionInput
  }

  export type InstructionCreateOrConnectWithoutRecipeInput = {
    where: InstructionWhereUniqueInput
    create: XOR<InstructionCreateWithoutRecipeInput, InstructionUncheckedCreateWithoutRecipeInput>
  }

  export type InstructionCreateManyRecipeInputEnvelope = {
    data: InstructionCreateManyRecipeInput | InstructionCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type IterationCreateWithoutRecipeInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
    ingredients?: IngredientIterationCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationCreateNestedManyWithoutRecipeInput
    parent?: IterationCreateNestedOneWithoutChildrenInput
    children?: IterationCreateNestedManyWithoutParentInput
  }

  export type IterationUncheckedCreateWithoutRecipeInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    parentId?: string | null
    tag?: string | null
    ingredients?: IngredientIterationUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationUncheckedCreateNestedManyWithoutRecipeInput
    children?: IterationUncheckedCreateNestedManyWithoutParentInput
  }

  export type IterationCreateOrConnectWithoutRecipeInput = {
    where: IterationWhereUniqueInput
    create: XOR<IterationCreateWithoutRecipeInput, IterationUncheckedCreateWithoutRecipeInput>
  }

  export type IterationCreateManyRecipeInputEnvelope = {
    data: IterationCreateManyRecipeInput | IterationCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type RatingCreateWithoutRecipeInput = {
    value: number
    user: UserCreateNestedOneWithoutRatingsInput
  }

  export type RatingUncheckedCreateWithoutRecipeInput = {
    userId: string
    value: number
  }

  export type RatingCreateOrConnectWithoutRecipeInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutRecipeInput, RatingUncheckedCreateWithoutRecipeInput>
  }

  export type RatingCreateManyRecipeInputEnvelope = {
    data: RatingCreateManyRecipeInput | RatingCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRecipesInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    recipeEditors?: RecipeEditorsCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecipesInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionUncheckedCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    recipeEditors?: RecipeEditorsUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecipesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeEditorsCreateWithoutRecipeInput = {
    user: UserCreateNestedOneWithoutRecipeEditorsInput
  }

  export type RecipeEditorsUncheckedCreateWithoutRecipeInput = {
    userId: string
  }

  export type RecipeEditorsCreateOrConnectWithoutRecipeInput = {
    where: RecipeEditorsWhereUniqueInput
    create: XOR<RecipeEditorsCreateWithoutRecipeInput, RecipeEditorsUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeEditorsCreateManyRecipeInputEnvelope = {
    data: RecipeEditorsCreateManyRecipeInput | RecipeEditorsCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type RecipeIngredientCreateWithoutRecipeInput = {
    quantity: number
    unit?: $Enums.IngredientUnit | null
    ingredient: IngredientCreateNestedOneWithoutRecipesInput
  }

  export type RecipeIngredientUncheckedCreateWithoutRecipeInput = {
    ingredientId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type RecipeIngredientCreateOrConnectWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientCreateManyRecipeInputEnvelope = {
    data: RecipeIngredientCreateManyRecipeInput | RecipeIngredientCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutRecipeInput = {
    text: string
    createdOn?: Date | string | null
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutRecipeInput = {
    userId: string
    text: string
    createdOn?: Date | string | null
  }

  export type ReviewCreateOrConnectWithoutRecipeInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutRecipeInput, ReviewUncheckedCreateWithoutRecipeInput>
  }

  export type ReviewCreateManyRecipeInputEnvelope = {
    data: ReviewCreateManyRecipeInput | ReviewCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutRecipeInput = {
    name: string
  }

  export type TagUncheckedCreateWithoutRecipeInput = {
    name: string
  }

  export type TagCreateOrConnectWithoutRecipeInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutRecipeInput, TagUncheckedCreateWithoutRecipeInput>
  }

  export type TagCreateManyRecipeInputEnvelope = {
    data: TagCreateManyRecipeInput | TagCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type ComponentUpsertWithWhereUniqueWithoutComponentInput = {
    where: ComponentWhereUniqueInput
    update: XOR<ComponentUpdateWithoutComponentInput, ComponentUncheckedUpdateWithoutComponentInput>
    create: XOR<ComponentCreateWithoutComponentInput, ComponentUncheckedCreateWithoutComponentInput>
  }

  export type ComponentUpdateWithWhereUniqueWithoutComponentInput = {
    where: ComponentWhereUniqueInput
    data: XOR<ComponentUpdateWithoutComponentInput, ComponentUncheckedUpdateWithoutComponentInput>
  }

  export type ComponentUpdateManyWithWhereWithoutComponentInput = {
    where: ComponentScalarWhereInput
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyWithoutComponentInput>
  }

  export type ComponentScalarWhereInput = {
    AND?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    OR?: ComponentScalarWhereInput[]
    NOT?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    recipeId?: StringFilter<"Component"> | string
    componentId?: StringFilter<"Component"> | string
    amount?: FloatFilter<"Component"> | number
  }

  export type ComponentUpsertWithWhereUniqueWithoutRecipeInput = {
    where: ComponentWhereUniqueInput
    update: XOR<ComponentUpdateWithoutRecipeInput, ComponentUncheckedUpdateWithoutRecipeInput>
    create: XOR<ComponentCreateWithoutRecipeInput, ComponentUncheckedCreateWithoutRecipeInput>
  }

  export type ComponentUpdateWithWhereUniqueWithoutRecipeInput = {
    where: ComponentWhereUniqueInput
    data: XOR<ComponentUpdateWithoutRecipeInput, ComponentUncheckedUpdateWithoutRecipeInput>
  }

  export type ComponentUpdateManyWithWhereWithoutRecipeInput = {
    where: ComponentScalarWhereInput
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyWithoutRecipeInput>
  }

  export type InstructionUpsertWithWhereUniqueWithoutRecipeInput = {
    where: InstructionWhereUniqueInput
    update: XOR<InstructionUpdateWithoutRecipeInput, InstructionUncheckedUpdateWithoutRecipeInput>
    create: XOR<InstructionCreateWithoutRecipeInput, InstructionUncheckedCreateWithoutRecipeInput>
  }

  export type InstructionUpdateWithWhereUniqueWithoutRecipeInput = {
    where: InstructionWhereUniqueInput
    data: XOR<InstructionUpdateWithoutRecipeInput, InstructionUncheckedUpdateWithoutRecipeInput>
  }

  export type InstructionUpdateManyWithWhereWithoutRecipeInput = {
    where: InstructionScalarWhereInput
    data: XOR<InstructionUpdateManyMutationInput, InstructionUncheckedUpdateManyWithoutRecipeInput>
  }

  export type InstructionScalarWhereInput = {
    AND?: InstructionScalarWhereInput | InstructionScalarWhereInput[]
    OR?: InstructionScalarWhereInput[]
    NOT?: InstructionScalarWhereInput | InstructionScalarWhereInput[]
    description?: StringFilter<"Instruction"> | string
    recipeId?: StringFilter<"Instruction"> | string
    step?: IntFilter<"Instruction"> | number
  }

  export type IterationUpsertWithWhereUniqueWithoutRecipeInput = {
    where: IterationWhereUniqueInput
    update: XOR<IterationUpdateWithoutRecipeInput, IterationUncheckedUpdateWithoutRecipeInput>
    create: XOR<IterationCreateWithoutRecipeInput, IterationUncheckedCreateWithoutRecipeInput>
  }

  export type IterationUpdateWithWhereUniqueWithoutRecipeInput = {
    where: IterationWhereUniqueInput
    data: XOR<IterationUpdateWithoutRecipeInput, IterationUncheckedUpdateWithoutRecipeInput>
  }

  export type IterationUpdateManyWithWhereWithoutRecipeInput = {
    where: IterationScalarWhereInput
    data: XOR<IterationUpdateManyMutationInput, IterationUncheckedUpdateManyWithoutRecipeInput>
  }

  export type IterationScalarWhereInput = {
    AND?: IterationScalarWhereInput | IterationScalarWhereInput[]
    OR?: IterationScalarWhereInput[]
    NOT?: IterationScalarWhereInput | IterationScalarWhereInput[]
    id?: StringFilter<"Iteration"> | string
    recipeId?: StringFilter<"Iteration"> | string
    createdOn?: DateTimeNullableFilter<"Iteration"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Iteration"> | Date | string | null
    parentId?: StringNullableFilter<"Iteration"> | string | null
    tag?: StringNullableFilter<"Iteration"> | string | null
  }

  export type RatingUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutRecipeInput, RatingUncheckedUpdateWithoutRecipeInput>
    create: XOR<RatingCreateWithoutRecipeInput, RatingUncheckedCreateWithoutRecipeInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutRecipeInput, RatingUncheckedUpdateWithoutRecipeInput>
  }

  export type RatingUpdateManyWithWhereWithoutRecipeInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutRecipeInput>
  }

  export type UserUpsertWithoutRecipesInput = {
    update: XOR<UserUpdateWithoutRecipesInput, UserUncheckedUpdateWithoutRecipesInput>
    create: XOR<UserCreateWithoutRecipesInput, UserUncheckedCreateWithoutRecipesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipesInput, UserUncheckedUpdateWithoutRecipesInput>
  }

  export type UserUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    recipeEditors?: RecipeEditorsUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUncheckedUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    recipeEditors?: RecipeEditorsUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeEditorsUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeEditorsWhereUniqueInput
    update: XOR<RecipeEditorsUpdateWithoutRecipeInput, RecipeEditorsUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeEditorsCreateWithoutRecipeInput, RecipeEditorsUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeEditorsUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeEditorsWhereUniqueInput
    data: XOR<RecipeEditorsUpdateWithoutRecipeInput, RecipeEditorsUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeEditorsUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeEditorsScalarWhereInput
    data: XOR<RecipeEditorsUpdateManyMutationInput, RecipeEditorsUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
    create: XOR<RecipeIngredientCreateWithoutRecipeInput, RecipeIngredientUncheckedCreateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutRecipeInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutRecipeInput, RecipeIngredientUncheckedUpdateWithoutRecipeInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutRecipeInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeIngredientScalarWhereInput = {
    AND?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    OR?: RecipeIngredientScalarWhereInput[]
    NOT?: RecipeIngredientScalarWhereInput | RecipeIngredientScalarWhereInput[]
    recipeId?: StringFilter<"RecipeIngredient"> | string
    ingredientId?: StringFilter<"RecipeIngredient"> | string
    quantity?: IntFilter<"RecipeIngredient"> | number
    unit?: EnumIngredientUnitNullableFilter<"RecipeIngredient"> | $Enums.IngredientUnit | null
  }

  export type ReviewUpsertWithWhereUniqueWithoutRecipeInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutRecipeInput, ReviewUncheckedUpdateWithoutRecipeInput>
    create: XOR<ReviewCreateWithoutRecipeInput, ReviewUncheckedCreateWithoutRecipeInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutRecipeInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutRecipeInput, ReviewUncheckedUpdateWithoutRecipeInput>
  }

  export type ReviewUpdateManyWithWhereWithoutRecipeInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutRecipeInput>
  }

  export type TagUpsertWithWhereUniqueWithoutRecipeInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutRecipeInput, TagUncheckedUpdateWithoutRecipeInput>
    create: XOR<TagCreateWithoutRecipeInput, TagUncheckedCreateWithoutRecipeInput>
  }

  export type TagUpdateWithWhereUniqueWithoutRecipeInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutRecipeInput, TagUncheckedUpdateWithoutRecipeInput>
  }

  export type TagUpdateManyWithWhereWithoutRecipeInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutRecipeInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    recipeId?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
  }

  export type IngredientIterationCreateWithoutIngredientInput = {
    quantity: number
    unit?: $Enums.IngredientUnit | null
    recipe: IterationCreateNestedOneWithoutIngredientsInput
  }

  export type IngredientIterationUncheckedCreateWithoutIngredientInput = {
    quantity: number
    iterationId: string
    unit?: $Enums.IngredientUnit | null
  }

  export type IngredientIterationCreateOrConnectWithoutIngredientInput = {
    where: IngredientIterationWhereUniqueInput
    create: XOR<IngredientIterationCreateWithoutIngredientInput, IngredientIterationUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientIterationCreateManyIngredientInputEnvelope = {
    data: IngredientIterationCreateManyIngredientInput | IngredientIterationCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type RecipeIngredientCreateWithoutIngredientInput = {
    quantity: number
    unit?: $Enums.IngredientUnit | null
    recipe: RecipeCreateNestedOneWithoutIngredientsInput
  }

  export type RecipeIngredientUncheckedCreateWithoutIngredientInput = {
    recipeId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type RecipeIngredientCreateOrConnectWithoutIngredientInput = {
    where: RecipeIngredientWhereUniqueInput
    create: XOR<RecipeIngredientCreateWithoutIngredientInput, RecipeIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type RecipeIngredientCreateManyIngredientInputEnvelope = {
    data: RecipeIngredientCreateManyIngredientInput | RecipeIngredientCreateManyIngredientInput[]
    skipDuplicates?: boolean
  }

  export type IngredientIterationUpsertWithWhereUniqueWithoutIngredientInput = {
    where: IngredientIterationWhereUniqueInput
    update: XOR<IngredientIterationUpdateWithoutIngredientInput, IngredientIterationUncheckedUpdateWithoutIngredientInput>
    create: XOR<IngredientIterationCreateWithoutIngredientInput, IngredientIterationUncheckedCreateWithoutIngredientInput>
  }

  export type IngredientIterationUpdateWithWhereUniqueWithoutIngredientInput = {
    where: IngredientIterationWhereUniqueInput
    data: XOR<IngredientIterationUpdateWithoutIngredientInput, IngredientIterationUncheckedUpdateWithoutIngredientInput>
  }

  export type IngredientIterationUpdateManyWithWhereWithoutIngredientInput = {
    where: IngredientIterationScalarWhereInput
    data: XOR<IngredientIterationUpdateManyMutationInput, IngredientIterationUncheckedUpdateManyWithoutIngredientInput>
  }

  export type IngredientIterationScalarWhereInput = {
    AND?: IngredientIterationScalarWhereInput | IngredientIterationScalarWhereInput[]
    OR?: IngredientIterationScalarWhereInput[]
    NOT?: IngredientIterationScalarWhereInput | IngredientIterationScalarWhereInput[]
    ingredientId?: StringFilter<"IngredientIteration"> | string
    quantity?: IntFilter<"IngredientIteration"> | number
    iterationId?: StringFilter<"IngredientIteration"> | string
    unit?: EnumIngredientUnitNullableFilter<"IngredientIteration"> | $Enums.IngredientUnit | null
  }

  export type RecipeIngredientUpsertWithWhereUniqueWithoutIngredientInput = {
    where: RecipeIngredientWhereUniqueInput
    update: XOR<RecipeIngredientUpdateWithoutIngredientInput, RecipeIngredientUncheckedUpdateWithoutIngredientInput>
    create: XOR<RecipeIngredientCreateWithoutIngredientInput, RecipeIngredientUncheckedCreateWithoutIngredientInput>
  }

  export type RecipeIngredientUpdateWithWhereUniqueWithoutIngredientInput = {
    where: RecipeIngredientWhereUniqueInput
    data: XOR<RecipeIngredientUpdateWithoutIngredientInput, RecipeIngredientUncheckedUpdateWithoutIngredientInput>
  }

  export type RecipeIngredientUpdateManyWithWhereWithoutIngredientInput = {
    where: RecipeIngredientScalarWhereInput
    data: XOR<RecipeIngredientUpdateManyMutationInput, RecipeIngredientUncheckedUpdateManyWithoutIngredientInput>
  }

  export type UserCreateWithoutConnectedWithInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedBy?: ConnectionCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    recipes?: RecipeCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConnectedWithInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedBy?: ConnectionUncheckedCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConnectedWithInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectedWithInput, UserUncheckedCreateWithoutConnectedWithInput>
  }

  export type UserCreateWithoutConnectedByInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionCreateNestedManyWithoutConnectedByInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    recipes?: RecipeCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConnectedByInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConnectedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConnectedByInput, UserUncheckedCreateWithoutConnectedByInput>
  }

  export type UserUpsertWithoutConnectedWithInput = {
    update: XOR<UserUpdateWithoutConnectedWithInput, UserUncheckedUpdateWithoutConnectedWithInput>
    create: XOR<UserCreateWithoutConnectedWithInput, UserUncheckedCreateWithoutConnectedWithInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectedWithInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectedWithInput, UserUncheckedUpdateWithoutConnectedWithInput>
  }

  export type UserUpdateWithoutConnectedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedBy?: ConnectionUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    recipes?: RecipeUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectedWithInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedBy?: ConnectionUncheckedUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutConnectedByInput = {
    update: XOR<UserUpdateWithoutConnectedByInput, UserUncheckedUpdateWithoutConnectedByInput>
    create: XOR<UserCreateWithoutConnectedByInput, UserUncheckedCreateWithoutConnectedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConnectedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConnectedByInput, UserUncheckedUpdateWithoutConnectedByInput>
  }

  export type UserUpdateWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUpdateManyWithoutConnectedByNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    recipes?: RecipeUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConnectedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeCreateWithoutTagsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutTagsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutTagsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutTagsInput, RecipeUncheckedCreateWithoutTagsInput>
  }

  export type RecipeUpsertWithoutTagsInput = {
    update: XOR<RecipeUpdateWithoutTagsInput, RecipeUncheckedUpdateWithoutTagsInput>
    create: XOR<RecipeCreateWithoutTagsInput, RecipeUncheckedCreateWithoutTagsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutTagsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutTagsInput, RecipeUncheckedUpdateWithoutTagsInput>
  }

  export type RecipeUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateWithoutEditorsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutEditorsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutEditorsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutEditorsInput, RecipeUncheckedCreateWithoutEditorsInput>
  }

  export type UserCreateWithoutRecipeEditorsInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    recipes?: RecipeCreateNestedManyWithoutAuthorInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRecipeEditorsInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionUncheckedCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutAuthorInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRecipeEditorsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRecipeEditorsInput, UserUncheckedCreateWithoutRecipeEditorsInput>
  }

  export type RecipeUpsertWithoutEditorsInput = {
    update: XOR<RecipeUpdateWithoutEditorsInput, RecipeUncheckedUpdateWithoutEditorsInput>
    create: XOR<RecipeCreateWithoutEditorsInput, RecipeUncheckedCreateWithoutEditorsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutEditorsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutEditorsInput, RecipeUncheckedUpdateWithoutEditorsInput>
  }

  export type RecipeUpdateWithoutEditorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutEditorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type UserUpsertWithoutRecipeEditorsInput = {
    update: XOR<UserUpdateWithoutRecipeEditorsInput, UserUncheckedUpdateWithoutRecipeEditorsInput>
    create: XOR<UserCreateWithoutRecipeEditorsInput, UserUncheckedCreateWithoutRecipeEditorsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRecipeEditorsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRecipeEditorsInput, UserUncheckedUpdateWithoutRecipeEditorsInput>
  }

  export type UserUpdateWithoutRecipeEditorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    recipes?: RecipeUpdateManyWithoutAuthorNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRecipeEditorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUncheckedUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutAuthorNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeCreateWithoutRatingsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutRatingsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutRatingsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutRatingsInput, RecipeUncheckedCreateWithoutRatingsInput>
  }

  export type UserCreateWithoutRatingsInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionCreateNestedManyWithoutConnectedWithInput
    recipes?: RecipeCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRatingsInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionUncheckedCreateNestedManyWithoutConnectedWithInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
  }

  export type RecipeUpsertWithoutRatingsInput = {
    update: XOR<RecipeUpdateWithoutRatingsInput, RecipeUncheckedUpdateWithoutRatingsInput>
    create: XOR<RecipeCreateWithoutRatingsInput, RecipeUncheckedCreateWithoutRatingsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutRatingsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutRatingsInput, RecipeUncheckedUpdateWithoutRatingsInput>
  }

  export type RecipeUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type UserUpsertWithoutRatingsInput = {
    update: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
    create: XOR<UserCreateWithoutRatingsInput, UserUncheckedCreateWithoutRatingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRatingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRatingsInput, UserUncheckedUpdateWithoutRatingsInput>
  }

  export type UserUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUpdateManyWithoutConnectedWithNestedInput
    recipes?: RecipeUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRatingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUncheckedUpdateManyWithoutConnectedWithNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeCreateWithoutReviewsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutReviewsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutReviewsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutReviewsInput, RecipeUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingCreateNestedManyWithoutUserInput
    recipes?: RecipeCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    username: string
    password: string
    salt: string
    image?: string | null
    connectedWith?: ConnectionUncheckedCreateNestedManyWithoutConnectedByInput
    connectedBy?: ConnectionUncheckedCreateNestedManyWithoutConnectedWithInput
    ratings?: RatingUncheckedCreateNestedManyWithoutUserInput
    recipes?: RecipeUncheckedCreateNestedManyWithoutAuthorInput
    recipeEditors?: RecipeEditorsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type RecipeUpsertWithoutReviewsInput = {
    update: XOR<RecipeUpdateWithoutReviewsInput, RecipeUncheckedUpdateWithoutReviewsInput>
    create: XOR<RecipeCreateWithoutReviewsInput, RecipeUncheckedCreateWithoutReviewsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutReviewsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutReviewsInput, RecipeUncheckedUpdateWithoutReviewsInput>
  }

  export type RecipeUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUpdateManyWithoutUserNestedInput
    recipes?: RecipeUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    connectedWith?: ConnectionUncheckedUpdateManyWithoutConnectedByNestedInput
    connectedBy?: ConnectionUncheckedUpdateManyWithoutConnectedWithNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutUserNestedInput
    recipes?: RecipeUncheckedUpdateManyWithoutAuthorNestedInput
    recipeEditors?: RecipeEditorsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RecipeCreateWithoutInstructionsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutInstructionsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutInstructionsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
  }

  export type TimeAndTemperatureCreateWithoutInstructionInput = {
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureUncheckedCreateWithoutInstructionInput = {
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureCreateOrConnectWithoutInstructionInput = {
    where: TimeAndTemperatureWhereUniqueInput
    create: XOR<TimeAndTemperatureCreateWithoutInstructionInput, TimeAndTemperatureUncheckedCreateWithoutInstructionInput>
  }

  export type RecipeUpsertWithoutInstructionsInput = {
    update: XOR<RecipeUpdateWithoutInstructionsInput, RecipeUncheckedUpdateWithoutInstructionsInput>
    create: XOR<RecipeCreateWithoutInstructionsInput, RecipeUncheckedCreateWithoutInstructionsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutInstructionsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutInstructionsInput, RecipeUncheckedUpdateWithoutInstructionsInput>
  }

  export type RecipeUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type TimeAndTemperatureUpsertWithoutInstructionInput = {
    update: XOR<TimeAndTemperatureUpdateWithoutInstructionInput, TimeAndTemperatureUncheckedUpdateWithoutInstructionInput>
    create: XOR<TimeAndTemperatureCreateWithoutInstructionInput, TimeAndTemperatureUncheckedCreateWithoutInstructionInput>
    where?: TimeAndTemperatureWhereInput
  }

  export type TimeAndTemperatureUpdateToOneWithWhereWithoutInstructionInput = {
    where?: TimeAndTemperatureWhereInput
    data: XOR<TimeAndTemperatureUpdateWithoutInstructionInput, TimeAndTemperatureUncheckedUpdateWithoutInstructionInput>
  }

  export type TimeAndTemperatureUpdateWithoutInstructionInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureUncheckedUpdateWithoutInstructionInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type InstructionCreateWithoutTimeAndTemperatureInput = {
    description: string
    step: number
    recipe: RecipeCreateNestedOneWithoutInstructionsInput
  }

  export type InstructionUncheckedCreateWithoutTimeAndTemperatureInput = {
    description: string
    recipeId: string
    step: number
  }

  export type InstructionCreateOrConnectWithoutTimeAndTemperatureInput = {
    where: InstructionWhereUniqueInput
    create: XOR<InstructionCreateWithoutTimeAndTemperatureInput, InstructionUncheckedCreateWithoutTimeAndTemperatureInput>
  }

  export type InstructionUpsertWithoutTimeAndTemperatureInput = {
    update: XOR<InstructionUpdateWithoutTimeAndTemperatureInput, InstructionUncheckedUpdateWithoutTimeAndTemperatureInput>
    create: XOR<InstructionCreateWithoutTimeAndTemperatureInput, InstructionUncheckedCreateWithoutTimeAndTemperatureInput>
    where?: InstructionWhereInput
  }

  export type InstructionUpdateToOneWithWhereWithoutTimeAndTemperatureInput = {
    where?: InstructionWhereInput
    data: XOR<InstructionUpdateWithoutTimeAndTemperatureInput, InstructionUncheckedUpdateWithoutTimeAndTemperatureInput>
  }

  export type InstructionUpdateWithoutTimeAndTemperatureInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutInstructionsNestedInput
  }

  export type InstructionUncheckedUpdateWithoutTimeAndTemperatureInput = {
    description?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
  }

  export type IngredientCreateWithoutRecipesInput = {
    id?: string
    name: string
    iterations?: IngredientIterationCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutRecipesInput = {
    id?: string
    name: string
    iterations?: IngredientIterationUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutRecipesInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutRecipesInput, IngredientUncheckedCreateWithoutRecipesInput>
  }

  export type RecipeCreateWithoutIngredientsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutIngredientsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutIngredientsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
  }

  export type IngredientUpsertWithoutRecipesInput = {
    update: XOR<IngredientUpdateWithoutRecipesInput, IngredientUncheckedUpdateWithoutRecipesInput>
    create: XOR<IngredientCreateWithoutRecipesInput, IngredientUncheckedCreateWithoutRecipesInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutRecipesInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutRecipesInput, IngredientUncheckedUpdateWithoutRecipesInput>
  }

  export type IngredientUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iterations?: IngredientIterationUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    iterations?: IngredientIterationUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type RecipeUpsertWithoutIngredientsInput = {
    update: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
    create: XOR<RecipeCreateWithoutIngredientsInput, RecipeUncheckedCreateWithoutIngredientsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutIngredientsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutIngredientsInput, RecipeUncheckedUpdateWithoutIngredientsInput>
  }

  export type RecipeUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateWithoutParentRecipesInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutParentRecipesInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutParentRecipesInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutParentRecipesInput, RecipeUncheckedCreateWithoutParentRecipesInput>
  }

  export type RecipeCreateWithoutComponentsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    iterations?: IterationCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutComponentsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    iterations?: IterationUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutComponentsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutComponentsInput, RecipeUncheckedCreateWithoutComponentsInput>
  }

  export type RecipeUpsertWithoutParentRecipesInput = {
    update: XOR<RecipeUpdateWithoutParentRecipesInput, RecipeUncheckedUpdateWithoutParentRecipesInput>
    create: XOR<RecipeCreateWithoutParentRecipesInput, RecipeUncheckedCreateWithoutParentRecipesInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutParentRecipesInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutParentRecipesInput, RecipeUncheckedUpdateWithoutParentRecipesInput>
  }

  export type RecipeUpdateWithoutParentRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutParentRecipesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUpsertWithoutComponentsInput = {
    update: XOR<RecipeUpdateWithoutComponentsInput, RecipeUncheckedUpdateWithoutComponentsInput>
    create: XOR<RecipeCreateWithoutComponentsInput, RecipeUncheckedCreateWithoutComponentsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutComponentsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutComponentsInput, RecipeUncheckedUpdateWithoutComponentsInput>
  }

  export type RecipeUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutComponentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type IngredientIterationCreateWithoutRecipeInput = {
    quantity: number
    unit?: $Enums.IngredientUnit | null
    ingredient: IngredientCreateNestedOneWithoutIterationsInput
  }

  export type IngredientIterationUncheckedCreateWithoutRecipeInput = {
    ingredientId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type IngredientIterationCreateOrConnectWithoutRecipeInput = {
    where: IngredientIterationWhereUniqueInput
    create: XOR<IngredientIterationCreateWithoutRecipeInput, IngredientIterationUncheckedCreateWithoutRecipeInput>
  }

  export type IngredientIterationCreateManyRecipeInputEnvelope = {
    data: IngredientIterationCreateManyRecipeInput | IngredientIterationCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type InstructionIterationCreateWithoutRecipeInput = {
    description: string
    step: number
    timeAndTemperature?: TimeAndTemperatureIterationCreateNestedOneWithoutInstructionInput
  }

  export type InstructionIterationUncheckedCreateWithoutRecipeInput = {
    description: string
    step: number
    timeAndTemperature?: TimeAndTemperatureIterationUncheckedCreateNestedOneWithoutInstructionInput
  }

  export type InstructionIterationCreateOrConnectWithoutRecipeInput = {
    where: InstructionIterationWhereUniqueInput
    create: XOR<InstructionIterationCreateWithoutRecipeInput, InstructionIterationUncheckedCreateWithoutRecipeInput>
  }

  export type InstructionIterationCreateManyRecipeInputEnvelope = {
    data: InstructionIterationCreateManyRecipeInput | InstructionIterationCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type IterationCreateWithoutChildrenInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
    ingredients?: IngredientIterationCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationCreateNestedManyWithoutRecipeInput
    parent?: IterationCreateNestedOneWithoutChildrenInput
    recipe: RecipeCreateNestedOneWithoutIterationsInput
  }

  export type IterationUncheckedCreateWithoutChildrenInput = {
    id?: string
    recipeId: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    parentId?: string | null
    tag?: string | null
    ingredients?: IngredientIterationUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type IterationCreateOrConnectWithoutChildrenInput = {
    where: IterationWhereUniqueInput
    create: XOR<IterationCreateWithoutChildrenInput, IterationUncheckedCreateWithoutChildrenInput>
  }

  export type IterationCreateWithoutParentInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
    ingredients?: IngredientIterationCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationCreateNestedManyWithoutRecipeInput
    children?: IterationCreateNestedManyWithoutParentInput
    recipe: RecipeCreateNestedOneWithoutIterationsInput
  }

  export type IterationUncheckedCreateWithoutParentInput = {
    id?: string
    recipeId: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
    ingredients?: IngredientIterationUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionIterationUncheckedCreateNestedManyWithoutRecipeInput
    children?: IterationUncheckedCreateNestedManyWithoutParentInput
  }

  export type IterationCreateOrConnectWithoutParentInput = {
    where: IterationWhereUniqueInput
    create: XOR<IterationCreateWithoutParentInput, IterationUncheckedCreateWithoutParentInput>
  }

  export type IterationCreateManyParentInputEnvelope = {
    data: IterationCreateManyParentInput | IterationCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutIterationsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentCreateNestedManyWithoutComponentInput
    components?: ComponentCreateNestedManyWithoutRecipeInput
    instructions?: InstructionCreateNestedManyWithoutRecipeInput
    ratings?: RatingCreateNestedManyWithoutRecipeInput
    author: UserCreateNestedOneWithoutRecipesInput
    editors?: RecipeEditorsCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientCreateNestedManyWithoutRecipeInput
    reviews?: ReviewCreateNestedManyWithoutRecipeInput
    tags?: TagCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutIterationsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    authorId: string
    image?: string | null
    description?: string | null
    public?: boolean | null
    parentRecipes?: ComponentUncheckedCreateNestedManyWithoutComponentInput
    components?: ComponentUncheckedCreateNestedManyWithoutRecipeInput
    instructions?: InstructionUncheckedCreateNestedManyWithoutRecipeInput
    ratings?: RatingUncheckedCreateNestedManyWithoutRecipeInput
    editors?: RecipeEditorsUncheckedCreateNestedManyWithoutRecipeInput
    ingredients?: RecipeIngredientUncheckedCreateNestedManyWithoutRecipeInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutRecipeInput
    tags?: TagUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutIterationsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutIterationsInput, RecipeUncheckedCreateWithoutIterationsInput>
  }

  export type IngredientIterationUpsertWithWhereUniqueWithoutRecipeInput = {
    where: IngredientIterationWhereUniqueInput
    update: XOR<IngredientIterationUpdateWithoutRecipeInput, IngredientIterationUncheckedUpdateWithoutRecipeInput>
    create: XOR<IngredientIterationCreateWithoutRecipeInput, IngredientIterationUncheckedCreateWithoutRecipeInput>
  }

  export type IngredientIterationUpdateWithWhereUniqueWithoutRecipeInput = {
    where: IngredientIterationWhereUniqueInput
    data: XOR<IngredientIterationUpdateWithoutRecipeInput, IngredientIterationUncheckedUpdateWithoutRecipeInput>
  }

  export type IngredientIterationUpdateManyWithWhereWithoutRecipeInput = {
    where: IngredientIterationScalarWhereInput
    data: XOR<IngredientIterationUpdateManyMutationInput, IngredientIterationUncheckedUpdateManyWithoutRecipeInput>
  }

  export type InstructionIterationUpsertWithWhereUniqueWithoutRecipeInput = {
    where: InstructionIterationWhereUniqueInput
    update: XOR<InstructionIterationUpdateWithoutRecipeInput, InstructionIterationUncheckedUpdateWithoutRecipeInput>
    create: XOR<InstructionIterationCreateWithoutRecipeInput, InstructionIterationUncheckedCreateWithoutRecipeInput>
  }

  export type InstructionIterationUpdateWithWhereUniqueWithoutRecipeInput = {
    where: InstructionIterationWhereUniqueInput
    data: XOR<InstructionIterationUpdateWithoutRecipeInput, InstructionIterationUncheckedUpdateWithoutRecipeInput>
  }

  export type InstructionIterationUpdateManyWithWhereWithoutRecipeInput = {
    where: InstructionIterationScalarWhereInput
    data: XOR<InstructionIterationUpdateManyMutationInput, InstructionIterationUncheckedUpdateManyWithoutRecipeInput>
  }

  export type InstructionIterationScalarWhereInput = {
    AND?: InstructionIterationScalarWhereInput | InstructionIterationScalarWhereInput[]
    OR?: InstructionIterationScalarWhereInput[]
    NOT?: InstructionIterationScalarWhereInput | InstructionIterationScalarWhereInput[]
    description?: StringFilter<"InstructionIteration"> | string
    step?: IntFilter<"InstructionIteration"> | number
    iterationId?: StringFilter<"InstructionIteration"> | string
  }

  export type IterationUpsertWithoutChildrenInput = {
    update: XOR<IterationUpdateWithoutChildrenInput, IterationUncheckedUpdateWithoutChildrenInput>
    create: XOR<IterationCreateWithoutChildrenInput, IterationUncheckedCreateWithoutChildrenInput>
    where?: IterationWhereInput
  }

  export type IterationUpdateToOneWithWhereWithoutChildrenInput = {
    where?: IterationWhereInput
    data: XOR<IterationUpdateWithoutChildrenInput, IterationUncheckedUpdateWithoutChildrenInput>
  }

  export type IterationUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUpdateManyWithoutRecipeNestedInput
    parent?: IterationUpdateOneWithoutChildrenNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutIterationsNestedInput
  }

  export type IterationUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type IterationUpsertWithWhereUniqueWithoutParentInput = {
    where: IterationWhereUniqueInput
    update: XOR<IterationUpdateWithoutParentInput, IterationUncheckedUpdateWithoutParentInput>
    create: XOR<IterationCreateWithoutParentInput, IterationUncheckedCreateWithoutParentInput>
  }

  export type IterationUpdateWithWhereUniqueWithoutParentInput = {
    where: IterationWhereUniqueInput
    data: XOR<IterationUpdateWithoutParentInput, IterationUncheckedUpdateWithoutParentInput>
  }

  export type IterationUpdateManyWithWhereWithoutParentInput = {
    where: IterationScalarWhereInput
    data: XOR<IterationUpdateManyMutationInput, IterationUncheckedUpdateManyWithoutParentInput>
  }

  export type RecipeUpsertWithoutIterationsInput = {
    update: XOR<RecipeUpdateWithoutIterationsInput, RecipeUncheckedUpdateWithoutIterationsInput>
    create: XOR<RecipeCreateWithoutIterationsInput, RecipeUncheckedCreateWithoutIterationsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutIterationsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutIterationsInput, RecipeUncheckedUpdateWithoutIterationsInput>
  }

  export type RecipeUpdateWithoutIterationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    author?: UserUpdateOneRequiredWithoutRecipesNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutIterationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type IngredientCreateWithoutIterationsInput = {
    id?: string
    name: string
    recipes?: RecipeIngredientCreateNestedManyWithoutIngredientInput
  }

  export type IngredientUncheckedCreateWithoutIterationsInput = {
    id?: string
    name: string
    recipes?: RecipeIngredientUncheckedCreateNestedManyWithoutIngredientInput
  }

  export type IngredientCreateOrConnectWithoutIterationsInput = {
    where: IngredientWhereUniqueInput
    create: XOR<IngredientCreateWithoutIterationsInput, IngredientUncheckedCreateWithoutIterationsInput>
  }

  export type IterationCreateWithoutIngredientsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
    instructions?: InstructionIterationCreateNestedManyWithoutRecipeInput
    parent?: IterationCreateNestedOneWithoutChildrenInput
    children?: IterationCreateNestedManyWithoutParentInput
    recipe: RecipeCreateNestedOneWithoutIterationsInput
  }

  export type IterationUncheckedCreateWithoutIngredientsInput = {
    id?: string
    recipeId: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    parentId?: string | null
    tag?: string | null
    instructions?: InstructionIterationUncheckedCreateNestedManyWithoutRecipeInput
    children?: IterationUncheckedCreateNestedManyWithoutParentInput
  }

  export type IterationCreateOrConnectWithoutIngredientsInput = {
    where: IterationWhereUniqueInput
    create: XOR<IterationCreateWithoutIngredientsInput, IterationUncheckedCreateWithoutIngredientsInput>
  }

  export type IngredientUpsertWithoutIterationsInput = {
    update: XOR<IngredientUpdateWithoutIterationsInput, IngredientUncheckedUpdateWithoutIterationsInput>
    create: XOR<IngredientCreateWithoutIterationsInput, IngredientUncheckedCreateWithoutIterationsInput>
    where?: IngredientWhereInput
  }

  export type IngredientUpdateToOneWithWhereWithoutIterationsInput = {
    where?: IngredientWhereInput
    data: XOR<IngredientUpdateWithoutIterationsInput, IngredientUncheckedUpdateWithoutIterationsInput>
  }

  export type IngredientUpdateWithoutIterationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recipes?: RecipeIngredientUpdateManyWithoutIngredientNestedInput
  }

  export type IngredientUncheckedUpdateWithoutIterationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    recipes?: RecipeIngredientUncheckedUpdateManyWithoutIngredientNestedInput
  }

  export type IterationUpsertWithoutIngredientsInput = {
    update: XOR<IterationUpdateWithoutIngredientsInput, IterationUncheckedUpdateWithoutIngredientsInput>
    create: XOR<IterationCreateWithoutIngredientsInput, IterationUncheckedCreateWithoutIngredientsInput>
    where?: IterationWhereInput
  }

  export type IterationUpdateToOneWithWhereWithoutIngredientsInput = {
    where?: IterationWhereInput
    data: XOR<IterationUpdateWithoutIngredientsInput, IterationUncheckedUpdateWithoutIngredientsInput>
  }

  export type IterationUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: InstructionIterationUpdateManyWithoutRecipeNestedInput
    parent?: IterationUpdateOneWithoutChildrenNestedInput
    children?: IterationUpdateManyWithoutParentNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutIterationsNestedInput
  }

  export type IterationUncheckedUpdateWithoutIngredientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: InstructionIterationUncheckedUpdateManyWithoutRecipeNestedInput
    children?: IterationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type IterationCreateWithoutInstructionsInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
    ingredients?: IngredientIterationCreateNestedManyWithoutRecipeInput
    parent?: IterationCreateNestedOneWithoutChildrenInput
    children?: IterationCreateNestedManyWithoutParentInput
    recipe: RecipeCreateNestedOneWithoutIterationsInput
  }

  export type IterationUncheckedCreateWithoutInstructionsInput = {
    id?: string
    recipeId: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    parentId?: string | null
    tag?: string | null
    ingredients?: IngredientIterationUncheckedCreateNestedManyWithoutRecipeInput
    children?: IterationUncheckedCreateNestedManyWithoutParentInput
  }

  export type IterationCreateOrConnectWithoutInstructionsInput = {
    where: IterationWhereUniqueInput
    create: XOR<IterationCreateWithoutInstructionsInput, IterationUncheckedCreateWithoutInstructionsInput>
  }

  export type TimeAndTemperatureIterationCreateWithoutInstructionInput = {
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationUncheckedCreateWithoutInstructionInput = {
    hours?: number | null
    minutes?: number | null
    temperature: number
    unit?: $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationCreateOrConnectWithoutInstructionInput = {
    where: TimeAndTemperatureIterationWhereUniqueInput
    create: XOR<TimeAndTemperatureIterationCreateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedCreateWithoutInstructionInput>
  }

  export type IterationUpsertWithoutInstructionsInput = {
    update: XOR<IterationUpdateWithoutInstructionsInput, IterationUncheckedUpdateWithoutInstructionsInput>
    create: XOR<IterationCreateWithoutInstructionsInput, IterationUncheckedCreateWithoutInstructionsInput>
    where?: IterationWhereInput
  }

  export type IterationUpdateToOneWithWhereWithoutInstructionsInput = {
    where?: IterationWhereInput
    data: XOR<IterationUpdateWithoutInstructionsInput, IterationUncheckedUpdateWithoutInstructionsInput>
  }

  export type IterationUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUpdateManyWithoutRecipeNestedInput
    parent?: IterationUpdateOneWithoutChildrenNestedInput
    children?: IterationUpdateManyWithoutParentNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutIterationsNestedInput
  }

  export type IterationUncheckedUpdateWithoutInstructionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUncheckedUpdateManyWithoutRecipeNestedInput
    children?: IterationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TimeAndTemperatureIterationUpsertWithoutInstructionInput = {
    update: XOR<TimeAndTemperatureIterationUpdateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedUpdateWithoutInstructionInput>
    create: XOR<TimeAndTemperatureIterationCreateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedCreateWithoutInstructionInput>
    where?: TimeAndTemperatureIterationWhereInput
  }

  export type TimeAndTemperatureIterationUpdateToOneWithWhereWithoutInstructionInput = {
    where?: TimeAndTemperatureIterationWhereInput
    data: XOR<TimeAndTemperatureIterationUpdateWithoutInstructionInput, TimeAndTemperatureIterationUncheckedUpdateWithoutInstructionInput>
  }

  export type TimeAndTemperatureIterationUpdateWithoutInstructionInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type TimeAndTemperatureIterationUncheckedUpdateWithoutInstructionInput = {
    hours?: NullableIntFieldUpdateOperationsInput | number | null
    minutes?: NullableIntFieldUpdateOperationsInput | number | null
    temperature?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumTemperatureUnitFieldUpdateOperationsInput | $Enums.TemperatureUnit | null
  }

  export type InstructionIterationCreateWithoutTimeAndTemperatureInput = {
    description: string
    step: number
    recipe: IterationCreateNestedOneWithoutInstructionsInput
  }

  export type InstructionIterationUncheckedCreateWithoutTimeAndTemperatureInput = {
    description: string
    step: number
    iterationId: string
  }

  export type InstructionIterationCreateOrConnectWithoutTimeAndTemperatureInput = {
    where: InstructionIterationWhereUniqueInput
    create: XOR<InstructionIterationCreateWithoutTimeAndTemperatureInput, InstructionIterationUncheckedCreateWithoutTimeAndTemperatureInput>
  }

  export type InstructionIterationUpsertWithoutTimeAndTemperatureInput = {
    update: XOR<InstructionIterationUpdateWithoutTimeAndTemperatureInput, InstructionIterationUncheckedUpdateWithoutTimeAndTemperatureInput>
    create: XOR<InstructionIterationCreateWithoutTimeAndTemperatureInput, InstructionIterationUncheckedCreateWithoutTimeAndTemperatureInput>
    where?: InstructionIterationWhereInput
  }

  export type InstructionIterationUpdateToOneWithWhereWithoutTimeAndTemperatureInput = {
    where?: InstructionIterationWhereInput
    data: XOR<InstructionIterationUpdateWithoutTimeAndTemperatureInput, InstructionIterationUncheckedUpdateWithoutTimeAndTemperatureInput>
  }

  export type InstructionIterationUpdateWithoutTimeAndTemperatureInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    recipe?: IterationUpdateOneRequiredWithoutInstructionsNestedInput
  }

  export type InstructionIterationUncheckedUpdateWithoutTimeAndTemperatureInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    iterationId?: StringFieldUpdateOperationsInput | string
  }

  export type ConnectionCreateManyConnectedByInput = {
    connectedWithId: string
    accepted?: boolean
  }

  export type ConnectionCreateManyConnectedWithInput = {
    connectedById: string
    accepted?: boolean
  }

  export type RatingCreateManyUserInput = {
    recipeId: string
    value: number
  }

  export type RecipeCreateManyAuthorInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    title: string
    image?: string | null
    description?: string | null
    public?: boolean | null
  }

  export type RecipeEditorsCreateManyUserInput = {
    recipeId: string
  }

  export type ReviewCreateManyUserInput = {
    recipeId: string
    text: string
    createdOn?: Date | string | null
  }

  export type ConnectionUpdateWithoutConnectedByInput = {
    accepted?: BoolFieldUpdateOperationsInput | boolean
    connectedWith?: UserUpdateOneRequiredWithoutConnectedByNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutConnectedByInput = {
    connectedWithId?: StringFieldUpdateOperationsInput | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionUncheckedUpdateManyWithoutConnectedByInput = {
    connectedWithId?: StringFieldUpdateOperationsInput | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionUpdateWithoutConnectedWithInput = {
    accepted?: BoolFieldUpdateOperationsInput | boolean
    connectedBy?: UserUpdateOneRequiredWithoutConnectedWithNestedInput
  }

  export type ConnectionUncheckedUpdateWithoutConnectedWithInput = {
    connectedById?: StringFieldUpdateOperationsInput | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConnectionUncheckedUpdateManyWithoutConnectedWithInput = {
    connectedById?: StringFieldUpdateOperationsInput | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RatingUpdateWithoutUserInput = {
    value?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutUserInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RatingUncheckedUpdateManyWithoutUserInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUpdateManyWithoutComponentNestedInput
    components?: ComponentUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUpdateManyWithoutRecipeNestedInput
    tags?: TagUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
    parentRecipes?: ComponentUncheckedUpdateManyWithoutComponentNestedInput
    components?: ComponentUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionUncheckedUpdateManyWithoutRecipeNestedInput
    iterations?: IterationUncheckedUpdateManyWithoutRecipeNestedInput
    ratings?: RatingUncheckedUpdateManyWithoutRecipeNestedInput
    editors?: RecipeEditorsUncheckedUpdateManyWithoutRecipeNestedInput
    ingredients?: RecipeIngredientUncheckedUpdateManyWithoutRecipeNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutRecipeNestedInput
    tags?: TagUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    title?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    public?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type RecipeEditorsUpdateWithoutUserInput = {
    recipe?: RecipeUpdateOneRequiredWithoutEditorsNestedInput
  }

  export type RecipeEditorsUncheckedUpdateWithoutUserInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeEditorsUncheckedUpdateManyWithoutUserInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
  }

  export type ReviewUpdateWithoutUserInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipe?: RecipeUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComponentCreateManyComponentInput = {
    recipeId: string
    amount: number
  }

  export type ComponentCreateManyRecipeInput = {
    componentId: string
    amount: number
  }

  export type InstructionCreateManyRecipeInput = {
    description: string
    step: number
  }

  export type IterationCreateManyRecipeInput = {
    id?: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    parentId?: string | null
    tag?: string | null
  }

  export type RatingCreateManyRecipeInput = {
    userId: string
    value: number
  }

  export type RecipeEditorsCreateManyRecipeInput = {
    userId: string
  }

  export type RecipeIngredientCreateManyRecipeInput = {
    ingredientId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type ReviewCreateManyRecipeInput = {
    userId: string
    text: string
    createdOn?: Date | string | null
  }

  export type TagCreateManyRecipeInput = {
    name: string
  }

  export type ComponentUpdateWithoutComponentInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type ComponentUncheckedUpdateWithoutComponentInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ComponentUncheckedUpdateManyWithoutComponentInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ComponentUpdateWithoutRecipeInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    component?: RecipeUpdateOneRequiredWithoutParentRecipesNestedInput
  }

  export type ComponentUncheckedUpdateWithoutRecipeInput = {
    componentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type ComponentUncheckedUpdateManyWithoutRecipeInput = {
    componentId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
  }

  export type InstructionUpdateWithoutRecipeInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    timeAndTemperature?: TimeAndTemperatureUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionUncheckedUpdateWithoutRecipeInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    timeAndTemperature?: TimeAndTemperatureUncheckedUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionUncheckedUpdateManyWithoutRecipeInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
  }

  export type IterationUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUpdateManyWithoutRecipeNestedInput
    parent?: IterationUpdateOneWithoutChildrenNestedInput
    children?: IterationUpdateManyWithoutParentNestedInput
  }

  export type IterationUncheckedUpdateWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUncheckedUpdateManyWithoutRecipeNestedInput
    children?: IterationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type IterationUncheckedUpdateManyWithoutRecipeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RatingUpdateWithoutRecipeInput = {
    value?: IntFieldUpdateOperationsInput | number
    user?: UserUpdateOneRequiredWithoutRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutRecipeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RatingUncheckedUpdateManyWithoutRecipeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeEditorsUpdateWithoutRecipeInput = {
    user?: UserUpdateOneRequiredWithoutRecipeEditorsNestedInput
  }

  export type RecipeEditorsUncheckedUpdateWithoutRecipeInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeEditorsUncheckedUpdateManyWithoutRecipeInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type RecipeIngredientUpdateWithoutRecipeInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
    ingredient?: IngredientUpdateOneRequiredWithoutRecipesNestedInput
  }

  export type RecipeIngredientUncheckedUpdateWithoutRecipeInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutRecipeInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type ReviewUpdateWithoutRecipeInput = {
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutRecipeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutRecipeInput = {
    userId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TagUpdateWithoutRecipeInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutRecipeInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyWithoutRecipeInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IngredientIterationCreateManyIngredientInput = {
    quantity: number
    iterationId: string
    unit?: $Enums.IngredientUnit | null
  }

  export type RecipeIngredientCreateManyIngredientInput = {
    recipeId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type IngredientIterationUpdateWithoutIngredientInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
    recipe?: IterationUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type IngredientIterationUncheckedUpdateWithoutIngredientInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    iterationId?: StringFieldUpdateOperationsInput | string
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type IngredientIterationUncheckedUpdateManyWithoutIngredientInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    iterationId?: StringFieldUpdateOperationsInput | string
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type RecipeIngredientUpdateWithoutIngredientInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
    recipe?: RecipeUpdateOneRequiredWithoutIngredientsNestedInput
  }

  export type RecipeIngredientUncheckedUpdateWithoutIngredientInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type RecipeIngredientUncheckedUpdateManyWithoutIngredientInput = {
    recipeId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type IngredientIterationCreateManyRecipeInput = {
    ingredientId: string
    quantity: number
    unit?: $Enums.IngredientUnit | null
  }

  export type InstructionIterationCreateManyRecipeInput = {
    description: string
    step: number
  }

  export type IterationCreateManyParentInput = {
    id?: string
    recipeId: string
    createdOn?: Date | string | null
    updatedAt?: Date | string | null
    tag?: string | null
  }

  export type IngredientIterationUpdateWithoutRecipeInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
    ingredient?: IngredientUpdateOneRequiredWithoutIterationsNestedInput
  }

  export type IngredientIterationUncheckedUpdateWithoutRecipeInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type IngredientIterationUncheckedUpdateManyWithoutRecipeInput = {
    ingredientId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unit?: NullableEnumIngredientUnitFieldUpdateOperationsInput | $Enums.IngredientUnit | null
  }

  export type InstructionIterationUpdateWithoutRecipeInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    timeAndTemperature?: TimeAndTemperatureIterationUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionIterationUncheckedUpdateWithoutRecipeInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    timeAndTemperature?: TimeAndTemperatureIterationUncheckedUpdateOneWithoutInstructionNestedInput
  }

  export type InstructionIterationUncheckedUpdateManyWithoutRecipeInput = {
    description?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
  }

  export type IterationUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUpdateManyWithoutRecipeNestedInput
    children?: IterationUpdateManyWithoutParentNestedInput
    recipe?: RecipeUpdateOneRequiredWithoutIterationsNestedInput
  }

  export type IterationUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    ingredients?: IngredientIterationUncheckedUpdateManyWithoutRecipeNestedInput
    instructions?: InstructionIterationUncheckedUpdateManyWithoutRecipeNestedInput
    children?: IterationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type IterationUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipeId?: StringFieldUpdateOperationsInput | string
    createdOn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tag?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientCountOutputTypeDefaultArgs instead
     */
    export type IngredientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IterationCountOutputTypeDefaultArgs instead
     */
    export type IterationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IterationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientDefaultArgs instead
     */
    export type IngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConnectionDefaultArgs instead
     */
    export type ConnectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConnectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TagDefaultArgs instead
     */
    export type TagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeEditorsDefaultArgs instead
     */
    export type RecipeEditorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeEditorsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RatingDefaultArgs instead
     */
    export type RatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReviewDefaultArgs instead
     */
    export type ReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstructionDefaultArgs instead
     */
    export type InstructionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstructionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeAndTemperatureDefaultArgs instead
     */
    export type TimeAndTemperatureArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeAndTemperatureDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeIngredientDefaultArgs instead
     */
    export type RecipeIngredientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeIngredientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComponentDefaultArgs instead
     */
    export type ComponentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComponentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IterationDefaultArgs instead
     */
    export type IterationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IterationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IngredientIterationDefaultArgs instead
     */
    export type IngredientIterationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IngredientIterationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstructionIterationDefaultArgs instead
     */
    export type InstructionIterationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstructionIterationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeAndTemperatureIterationDefaultArgs instead
     */
    export type TimeAndTemperatureIterationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeAndTemperatureIterationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}